<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>KI Regel-Labor</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        /* Spezifische Overrides f√ºr das Lab Layout */
        .col-game {
            /* Fixe Breite etwas verkleinert, damit Platz f√ºr Regeln bleibt */
            flex: 0 0 420px; 
            min-width: 420px;
            width: 420px; /* Explizit setzen */
        }
        
        /* Damit Canvas nicht ausbricht */
        .canvas-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 10px 0;
        }
        
        canvas {
            max-width: 100%;
            height: auto; /* Aspect Ratio erhalten */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        
        /* Tree Container Styles */
        .tree-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        
        /* Flowchart Styles */
        .fc-node {
            margin-bottom: 12px;
            padding: 12px;
            border: 1px solid #ddd;
            border-left: 4px solid #3498db;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .fc-node:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .fc-node.checking {
            background: #fffacd;
            border-left-color: #f39c12;
        }
        
        .fc-node.success {
            background: #d4edda;
            border-left-color: #28a745;
        }
        
        .fc-node.fc-type-group {
            border-left-color: #9b59b6;
        }
        
        .fc-node.fc-type-cond {
            border-left-color: #e74c3c;
        }
        
        .fc-content {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
        }
        
        .fc-children {
            margin-left: 20px;
            margin-top: 8px;
        }
        
        .fc-node.inactive {
            opacity: 0.6;
            filter: grayscale(50%);
        }
    </style>
</head>
<body class="lab-page">

    <div class="lab-toolbar">
        <a href="../index.html" class="viz-btn btn-back">‚¨Ö Men√º</a>
        
        <div class="viz-control-group" style="margin-left: 20px;">
            <label class="viz-label">Szenario:</label>
            <select id="gameTypeSelector" class="viz-select" onchange="Lab.changeGameType()">
                <option value="regular">Klassik 3x3</option>
                <option value="3d">3D 3x3x3</option>
                <option value="ultimate">Ultimate</option>
            </select>
        </div>

        <div style="flex-grow: 1;"></div> 

        <div class="viz-control-group">
            <button class="viz-btn viz-btn-action" onclick="Lab.stepAI()">‚ñ∂ Schritt</button>
            <button class="viz-btn viz-btn-action" id="btnAuto" onclick="Lab.toggleAutoMatch()">‚è© Auto</button>
            <button class="viz-btn viz-btn-restart" onclick="Lab.reset()">‚Ü∫ Reset</button>
        </div>

        <div class="viz-control-group" style="margin-left: 20px;">
            <label class="viz-label">‚è± KI Tempo:</label>
            <input type="range" id="speedSlider" min="50" max="1500" value="900" 
                   style="width:150px; cursor:pointer;" onchange="Lab.setDelay(this.value)">
        </div>
    </div>

    <div class="lab-grid">
        
        <div class="col-tree">
            <div class="panel-header" style="border-left: 5px solid #3498db;">
                <span>üß†</span> KI Blau
            </div>
            <div class="tree-container" id="treeDisplayP1"></div>
        </div>

        <div class="col-game">
            <div class="game-card">
                <div id="controls3D" class="view-controls hidden">
                    <button class="view-btn active" onclick="Lab.setAxis('z')">Ebenen</button>
                    <button class="view-btn" onclick="Lab.setAxis('y')">Vorne</button>
                    <button class="view-btn" onclick="Lab.setAxis('x')">Seite</button>
                </div>

                <div class="canvas-container">
                    <canvas id="gameCanvas" width="400" height="400"></canvas>
                </div>
                
                <div id="statusText" class="stats-display" style="margin-top:10px;">Bereit</div>
            </div>

            <div class="log-box" id="log">
                <div class="log-line">System bereit.</div>
            </div>
        </div>

        <div class="col-tree">
            <div class="panel-header" style="border-left: 5px solid #e74c3c;">
                <span>ü§ñ</span> KI Rot
            </div>
            <div class="tree-container" id="treeDisplayP2"></div>
        </div>
    </div>

    <script src="../js/core/game-state.js"></script>
    <script src="../js/core/agent.js"></script>
    <script src="../js/core/game-adapter.js"></script>
    <script src="../js/core/base-game-controller.js"></script>
    
    <script src="../js/ai/agents/random-agent.js"></script>
    <script src="../js/ai/agents/rule-based-agent.js"></script>
    <script src="../js/ai/minimax.js"></script>
    <script src="../js/ai/agents/minimax-agent.js"></script>
    <script src="../js/ai/heuristics/base.js"></script>
    <script src="../js/ai/heuristics/ttt.js"></script>
    
    <script src="../js/games/tictactoe/logic.js"></script>
    <script src="../js/games/tictactoe/renderer.js"></script>
    
    <script src="../js/ai/rules/rule-structure.js"></script>
    <script src="../js/ai/rules/ttt-rules.js"></script>
    
    <script src="../js/viz/specializers/flowchart/flowchart-visualizer.js"></script>

    <script>
        /**
         * @fileoverview Rules-Lab - Visualisiert die Regel-Evaluierung.
         * 
         * Nutzt GameAdapter f√ºr einheitliche Spiellogik.
         * Fokussiert nur auf Visualisierung des Entscheidungsbaums.
         */
        const Lab = {
            adapter: null,  // GameAdapter - die einheitliche Schnittstelle
            canvas: null,
            vizP1: null, vizP2: null,
            trees: { 1: null, 2: null },
            gameType: 'regular',
            axis3D: 'z',
            isAuto: false,
            delay: 600,

            init() {
                this.canvas = document.getElementById('gameCanvas');
                this.changeGameType();
            },

            changeGameType() {
                this.gameType = document.getElementById('gameTypeSelector').value;
                const controls = document.getElementById('controls3D');

                // Canvas-Gr√∂√üe anpassen
                this.canvas.width = 400;
                this.canvas.height = 400;

                if (this.gameType === '3d') {
                    controls.classList.remove('hidden');
                    this.canvas.height = 250;
                } else if (this.gameType === 'ultimate') {
                    controls.classList.add('hidden');
                    this.canvas.width = 600;
                    this.canvas.height = 600;
                } else {
                    controls.classList.add('hidden');
                }

                // B√§ume laden
                this.trees[1] = createStrategyTree(this.gameType);
                this.trees[2] = createStrategyTree(this.gameType);

                this.vizP1 = new FlowchartVisualizer('treeDisplayP1', this.trees[1], (n) => this.toggleRule(1, n));
                this.vizP2 = new FlowchartVisualizer('treeDisplayP2', this.trees[2], (n) => this.toggleRule(2, n));

                this.vizP1.render();
                this.vizP2.render();

                this.reset();
            },

            reset() {
                // ‚úÖ Nutze GameAdapter statt direkt neue Boards zu erstellen
                let gameBoard;
                if (this.gameType === 'regular') gameBoard = new TTTRegularBoard();
                else if (this.gameType === '3d') gameBoard = new TTT3DBoard(3);
                else gameBoard = new UltimateBoard();

                this.adapter = new GameAdapter(gameBoard, this.gameType);

                this.isAuto = false;
                document.getElementById('btnAuto').innerText = "‚è© Auto";
                document.getElementById('log').innerHTML = '';
                this.log("--- NEUES SPIEL ---");

                this.vizP1.clearHighlights();
                this.vizP2.clearHighlights();
                this.draw();
                this.updateStatus();
            },

            toggleRule(player, name) {
                const toggle = (n) => {
                    if (n.name === name) {
                        n.active = !n.active;
                        console.log(`‚úÖ Toggled rule "${name}" to ${n.active}`);
                    }
                    if (n.children) n.children.forEach(toggle);
                    if (n.thenNode) toggle(n.thenNode);
                    if (n.elseNode) toggle(n.elseNode);
                };
                toggle(this.trees[player].root);
                if (player === 1) {
                    this.vizP1.render();
                } else {
                    this.vizP2.render();
                }
            },

            setAxis(axis) {
                this.axis3D = axis;
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                const idx = axis === 'z' ? 0 : axis === 'y' ? 1 : 2;
                document.querySelectorAll('.view-btn')[idx].classList.add('active');
                this.draw();
            },

            setDelay(value) {
                this.delay = 1550 - parseInt(value);
            },

            /**
             * KI-Zug mit Visualisierung.
             * ‚úÖ WICHTIG: Nutzt den GLEICHEN Code-Pfad wie normale Spiele!
             * Agent.getAction() macht die Entscheidung
             * evaluateVisual() macht nur Visualisierung/Highlighting
             */
            async stepAI(fast = false) {
                // ‚úÖ Pr√ºfe winner ERST hier (nicht am Anfang der Funktion)
                if (this.adapter.isGameOver()) return;

                const stepBtn = document.querySelector('[onclick="Lab.stepAI()"]');
                stepBtn.disabled = true;
                stepBtn.style.opacity = '0.5';
                stepBtn.style.cursor = 'not-allowed';

                try {
                    const player = this.adapter.getCurrentPlayer();
                    const viz = player === 1 ? this.vizP1 : this.vizP2;
                    const tree = this.trees[player];
                    const gameBoard = this.adapter.getBoard();

                    // üîç DEBUG: Zeige verf√ºgbare Z√ºge VOR Evaluation
                    const validMovesBefore = this.adapter.getValidMoves();
                    
                    // ‚úÖ Z√§hle freie Zellen - unterschiedlich je nach Spieltyp
                    let freeCells = 0;
                    if (this.gameType === 'ultimate') {
                        // Ultimate: Z√§hle √ºber alle 9 boards
                        for (let b = 0; b < 9; b++) {
                            freeCells += gameBoard.boards[b].filter(c => c === 0).length;
                        }
                    } else {
                        // Regular/3D: Einfach grid z√§hlen
                        freeCells = gameBoard.grid.filter(c => c === 0).length;
                    }
                    
                    const winnerBefore = this.adapter.getWinner();
                    
                    this.log(`üîç DEBUG: Freie Felder=${freeCells}, ValidMoves=${validMovesBefore.length}, Winner=${winnerBefore}`);
                    if (winnerBefore !== 0) {
                        this.log(`‚ö†Ô∏è WARNUNG: Spiel ist schon vorbei! (Winner=${winnerBefore})`);
                        return;
                    }

                    viz.clearHighlights();
                    this.updateStatus(`KI ${player === 1 ? 'Blau' : 'Rot'} rechnet... (${freeCells} frei, ${validMovesBefore.length} valid)`);

                    // ‚úÖ Verwende Agent.getAction() genau wie normale Spiele!
                    let action = null;
                    try {
                        const agent = new RuleBasedAgent(tree);
                        action = agent.getAction(gameBoard);
                    } catch (e) {
                        this.log(`‚ùå FEHLER in Agent.getAction(): ${e.message}`);
                        console.error('Agent Error:', e);
                        return;
                    }
                    
                    const move = action?.move;

                    this.log(`üîç Agent gibt: ${JSON.stringify(move)}`);

                    // ‚úÖ Visualisiere die Evaluation NACHDEM wir den Zug kennen
                    if (fast === false && move !== undefined && move !== null) {
                        // Nur wenn wir Zeit haben, zeige die Evaluation
                        try {
                            await this.visualizeEvaluationPath(tree.root, gameBoard, viz, move);
                        } catch (e) {
                            this.log(`‚ö†Ô∏è Visualisierung fehlgeschlagen: ${e.message}`);
                        }
                    }

                    // ‚úÖ Setze den Zug mit robuster Pr√ºfung
                    if (move !== undefined && move !== null) {
                        this.log(`ü§ñ KI ${player} Zug: ${JSON.stringify(move)}`);
                        const success = this.adapter.makeMove(move);  // ‚úÖ GameAdapter API!
                        if (success) {
                            this.draw();
                            this.checkWin();
                        } else {
                            this.log(`‚ùå Zug war ung√ºltig: ${JSON.stringify(move)}`);
                        }
                    } else {
                        this.log(`‚ùå KI ${player} findet keinen Zug!`);
                        const validMovesAfter = this.adapter.getValidMoves();
                        this.log(`Valid: ${JSON.stringify(validMovesAfter.slice(0, 10))}`);
                    }
                } catch (e) {
                    this.log(`‚ùå KRITISCHER FEHLER in stepAI: ${e.message}`);
                    console.error('stepAI Error:', e);
                } finally {
                    stepBtn.disabled = false;
                    stepBtn.style.opacity = '1';
                    stepBtn.style.cursor = 'pointer';
                }
            },

            /**
             * Visualisiere welche Regeln gecheckt wurden bis zum gefundenen Zug.
             * Das ist nur f√ºr Visualisierung, die echte Entscheidung ist schon gemacht!
             */
            async visualizeEvaluationPath(node, gameState, viz, targetMove) {
                if (!node || !node.active) return;

                const traverse = async (n) => {
                    if (!n || !n.active) return false;

                    // Highlight diese Regel beim Checking
                    viz.highlightCheck(n.name);
                    await new Promise(r => setTimeout(r, this.delay));

                    // Condition
                    if (n.conditionFn) {
                        const res = n.conditionFn(gameState);
                        const targetNode = res ? n.thenNode : n.elseNode;
                        const found = await traverse(targetNode);
                        if (!found) {
                            viz._removeClass(n.name, 'checking');
                        }
                        return found;
                    }

                    // Group
                    if (n.children && n.children.length > 0) {
                        for (const child of n.children) {
                            const found = await traverse(child);
                            if (found) return true;
                            viz._removeClass(child.name, 'checking');
                        }
                        viz._removeClass(n.name, 'checking');
                        return false;
                    }

                    // Atomic Rule - pr√ºfe ob DIESE Regel den Zug liefert
                    const result = n.evaluate(gameState);
                    
                    // ‚úÖ Vergleiche Z√ºge korrekt (auch Objekte bei Ultimate!)
                    let moveMatches = false;
                    if (result && result.move !== undefined && result.move !== null) {
                        if (typeof result.move === 'object' && typeof targetMove === 'object') {
                            // Ultimate: Objekt-Vergleich
                            moveMatches = result.move.big === targetMove.big && 
                                         result.move.small === targetMove.small;
                        } else {
                            // Regular/3D: Primitive Vergleich
                            moveMatches = result.move === targetMove;
                        }
                    }
                    
                    if (moveMatches) {
                        // ‚úÖ DAS ist die Regel die den Zug lieferte!
                        viz.highlightSuccess(n.name);
                        return true;
                    } else {
                        viz._removeClass(n.name, 'checking');
                        return false;
                    }
                };

                await traverse(node);
            },

            /**
             * VERALTET: evaluateVisual wird nicht mehr verwendet.
             * Behielt f√ºr Referenzen, falls n√∂tig.
             * 
             * @deprecated Verwende stattdessen Agent.getAction() + visualizeEvaluationPath()
             */
            async evaluateVisual(node, gameState, viz, ms) {
                if (!node || !node.active) return null;

                const traverse = async (n) => {
                    if (!n || !n.active) return null;

                    if (ms > 0) {
                        viz.highlightCheck(n.name);
                        await new Promise(r => setTimeout(r, ms));
                    }

                    // Condition
                    if (n.conditionFn) {
                        const res = n.conditionFn(gameState);
                        const targetNode = res ? n.thenNode : n.elseNode;
                        const result = await traverse(targetNode);
                        if (!result && ms > 0) {
                            viz._removeClass(n.name, 'checking');
                        }
                        return result;
                    }

                    // Group
                    if (n.children && n.children.length > 0) {
                        for (const child of n.children) {
                            const result = await traverse(child);
                            if (result) return result;
                            if (ms > 0) viz._removeClass(child.name, 'checking');
                        }
                        if (ms > 0) viz._removeClass(n.name, 'checking');
                        return null;
                    }

                    // Atomic Rule
                    const result = n.evaluate(gameState);
                    if (result) {
                        if (ms > 0) viz.highlightSuccess(n.name);
                        return result.move;
                    } else {
                        if (ms > 0) viz._removeClass(n.name, 'checking');
                        return null;
                    }
                };

                return await traverse(node);
            },

            toggleAutoMatch() {
                this.isAuto = !this.isAuto;
                const btn = document.getElementById('btnAuto');
                if (this.isAuto) {
                    btn.innerHTML = "‚èπ Stopp";
                    btn.style.background = "#c0392b";
                    this.loop();
                } else {
                    btn.innerHTML = "‚è© Auto";
                    btn.style.background = "#8e44ad";
                }
            },

            /**
             * Auto-Loop f√ºr durchgehendes Spielen.
             * ‚úÖ Pr√ºfe winner NACH jedem stepAI, nicht davor
             */
            loop() {
                if (!this.isAuto) {
                    this.isAuto = false;
                    document.getElementById('btnAuto').innerText = "‚è© Auto";
                    document.getElementById('btnAuto').style.background = "#8e44ad";
                    return;
                }

                this.stepAI(false).then(() => {
                    // ‚úÖ NOW: Nach stepAI pr√ºfen, ob Spiel vorbei ist
                    if (this.adapter.isGameOver()) {
                        this.isAuto = false;
                        document.getElementById('btnAuto').innerText = "‚è© Auto";
                        document.getElementById('btnAuto').style.background = "#8e44ad";
                        return;
                    }
                    if (this.isAuto) setTimeout(() => this.loop(), 200);
                });
            },

            checkWin() {
                if (this.adapter.isGameOver()) {
                    const winner = this.adapter.getWinner();
                    const msg = winner === 3 ? "Remis" : `Sieg ${winner === 1 ? 'Blau' : 'Rot'}`;
                    this.updateStatus(msg);
                    this.log(msg);
                } else {
                    const player = this.adapter.getCurrentPlayer();
                    this.updateStatus(`${player === 1 ? 'Blau' : 'Rot'} ist dran`);
                }
            },

            updateStatus(msg) {
                document.getElementById('statusText').innerText = msg || "Bereit";
            },

            log(msg) {
                const l = document.getElementById('log');
                l.innerHTML += `<div class="log-entry">${msg}</div>`;
                l.scrollTop = l.scrollHeight;
            },

            draw() {
                const gameBoard = this.adapter.getBoard();
                const c = this.canvas;

                if (this.gameType === 'regular') {
                    TTTRenderer.drawRegular(c, gameBoard);
                } else if (this.gameType === '3d') {
                    TTTRenderer.draw3DSlices(c, gameBoard, this.axis3D);
                } else if (this.gameType === 'ultimate') {
                    TTTRenderer.drawUltimate(c, gameBoard);
                }
            }
        };

        window.onload = () => Lab.init();
    </script>
</body>
</html>