<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>KI Regel-Labor</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        /* Spezifische Overrides f√ºr das Lab Layout */
        .col-game {
            /* Fixe Breite etwas verkleinert, damit Platz f√ºr Regeln bleibt */
            flex: 0 0 420px; 
            min-width: 420px;
            width: 420px; /* Explizit setzen */
        }
        
        /* Damit Canvas nicht ausbricht */
        .canvas-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 10px 0;
        }
        
        canvas {
            max-width: 100%;
            height: auto; /* Aspect Ratio erhalten */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        
        /* Tree Container Styles */
        .tree-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        
        /* Flowchart Styles */
        .fc-node {
            margin-bottom: 12px;
            padding: 12px;
            border: 1px solid #ddd;
            border-left: 4px solid #3498db;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .fc-node:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .fc-node.checking {
            background: #fffacd;
            border-left-color: #f39c12;
        }
        
        .fc-node.success {
            background: #d4edda;
            border-left-color: #28a745;
        }
        
        .fc-node.fc-type-group {
            border-left-color: #9b59b6;
        }
        
        .fc-node.fc-type-cond {
            border-left-color: #e74c3c;
        }
        
        .fc-content {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
        }
        
        .fc-children {
            margin-left: 20px;
            margin-top: 8px;
        }
        
        .fc-node.inactive {
            opacity: 0.6;
            filter: grayscale(50%);
        }
    </style>
</head>
<body class="lab-page">

    <div class="lab-toolbar">
        <a href="../index.html" class="viz-btn btn-back">‚¨Ö Men√º</a>
        
        <div class="viz-control-group" style="margin-left: 20px;">
            <label class="viz-label">Szenario:</label>
            <select id="gameTypeSelector" class="viz-select" onchange="Lab.changeGameType()">
                <option value="regular">Klassik 3x3</option>
                <option value="3d">3D 3x3x3</option>
                <option value="ultimate">Ultimate</option>
            </select>
        </div>

        <div style="flex-grow: 1;"></div> 

        <div class="viz-control-group">
            <button class="viz-btn viz-btn-action" onclick="Lab.stepAI()">‚ñ∂ Schritt</button>
            <button class="viz-btn viz-btn-action" id="btnAuto" onclick="Lab.toggleAutoMatch()">‚è© Auto</button>
            <button class="viz-btn viz-btn-restart" onclick="Lab.reset()">‚Ü∫ Reset</button>
        </div>

        <div class="viz-control-group" style="margin-left: 20px;">
            <label class="viz-label">‚è± KI Tempo:</label>
            <input type="range" id="speedSlider" min="50" max="1500" value="900" 
                   style="width:150px; cursor:pointer;" onchange="Lab.setDelay(this.value)">
        </div>
    </div>

    <div class="lab-grid">
        
        <div class="col-tree">
            <div class="panel-header" style="border-left: 5px solid #3498db;">
                <span>üß†</span> KI Blau
            </div>
            <div class="tree-container" id="treeDisplayP1"></div>
        </div>

        <div class="col-game">
            <div class="game-card">
                <div id="controls3D" class="view-controls hidden">
                    <button class="view-btn active" onclick="Lab.setAxis('z')">Ebenen</button>
                    <button class="view-btn" onclick="Lab.setAxis('y')">Vorne</button>
                    <button class="view-btn" onclick="Lab.setAxis('x')">Seite</button>
                </div>

                <div class="canvas-container">
                    <canvas id="gameCanvas" width="400" height="400"></canvas>
                </div>
                
                <div id="statusText" class="stats-display" style="margin-top:10px;">Bereit</div>
            </div>

            <div class="log-box" id="log">
                <div class="log-line">System bereit.</div>
            </div>
        </div>

        <div class="col-tree">
            <div class="panel-header" style="border-left: 5px solid #e74c3c;">
                <span>ü§ñ</span> KI Rot
            </div>
            <div class="tree-container" id="treeDisplayP2"></div>
        </div>
    </div>

    <script src="../js/core/game-state.js"></script>
    
    <script src="../js/games/tictactoe/logic.js"></script>
    <script src="../js/games/tictactoe/renderer.js"></script>
    
    <script src="../js/ai/rules/rule-structure.js"></script>
    <script src="../js/ai/rules/ttt-rules.js"></script>
    
    <script src="../js/viz/flowchart-visualizer.js"></script>

    <script>
        const Lab = {
            game: null, canvas: null,
            vizP1: null, vizP2: null, trees: { 1: null, 2: null },
            gameType: 'regular', axis3D: 'z', isAuto: false,
            
            // Verz√∂gerung f√ºr Auto-Mode (in ms)
            // L√§nger, damit man das Highlighting sieht
            delay: 600, 

            init() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.addEventListener('mousedown', (e) => this.handleClick(e));
                this.changeGameType();
            },

            changeGameType() {
                this.gameType = document.getElementById('gameTypeSelector').value;
                const controls = document.getElementById('controls3D');
                
                // Canvas Gr√∂√üen Reset
                this.canvas.width = 400; 
                this.canvas.height = 400;

                if (this.gameType === '3d') {
                    controls.classList.remove('hidden');
                    // Slices brauchen weniger H√∂he (rechteckig)
                    this.canvas.height = 250; 
                } else if (this.gameType === 'ultimate') {
                    controls.classList.add('hidden');
                    // Ultimate braucht mehr Details -> Gr√∂√üeres internes Canvas (wird per CSS runterskaliert)
                    this.canvas.width = 600; 
                    this.canvas.height = 600;
                } else {
                    controls.classList.add('hidden');
                }

                // B√§ume neu laden
                this.trees[1] = createStrategyTree(this.gameType);
                this.trees[2] = createStrategyTree(this.gameType);
                
                this.vizP1 = new FlowchartVisualizer('treeDisplayP1', this.trees[1], (n) => this.toggleRule(1, n));
                this.vizP2 = new FlowchartVisualizer('treeDisplayP2', this.trees[2], (n) => this.toggleRule(2, n));
                
                this.vizP1.render();
                this.vizP2.render();
                
                this.reset();
            },

            reset() {
                if(this.gameType === 'regular') this.game = new TTTRegularBoard();
                else if(this.gameType === '3d') this.game = new TTT3DBoard(3);
                else this.game = new UltimateBoard();
                
                this.isAuto = false;
                document.getElementById('btnAuto').innerText = "‚è© Auto";
                document.getElementById('log').innerHTML = ''; // Log leeren
                this.log("--- NEUES SPIEL ---");
                
                this.vizP1.clearHighlights();
                this.vizP2.clearHighlights();
                this.draw();
                this.updateStatus();
            },

            toggleRule(player, name) {
                const toggle = (n) => {
                    if (n.name === name) n.active = !n.active;
                    if (n.children) n.children.forEach(toggle);
                    if (n.thenNode) toggle(n.thenNode);
                    if (n.elseNode) toggle(n.elseNode);
                };
                toggle(this.trees[player].root);
                if(player===1) this.vizP1.render(); else this.vizP2.render();
            },

            setAxis(axis) {
                this.axis3D = axis;
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                // Button Index Hack (z=0, y=1, x=2)
                const idx = axis==='z'?0 : axis==='y'?1 : 2;
                document.querySelectorAll('.view-btn')[idx].classList.add('active');
                this.draw();
            },

            /** Input Handler mit korrekter 3D-Berechnung */
            handleClick(e) {
                if (this.game.winner !== 0 || this.isAuto) return;

                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const mx = (e.clientX - rect.left) * scaleX;
                const my = (e.clientY - rect.top) * scaleY;

                let success = false;

                if (this.gameType === '3d') {
                    // 3D Layout Berechnung (Analog Renderer)
                    const s = 3; 
                    const w = this.canvas.width, h = this.canvas.height;
                    const pad = 20;
                    const availW = w - (pad*2), availH = h - (pad*2);
                    const boxSize = Math.min(availW/s, availH); // Max Boxgr√∂√üe
                    const gap = boxSize * 0.1;
                    const boardS = boxSize - gap;
                    
                    // Zentrierung
                    const startX = (w - s*boxSize)/2 + gap/2;
                    const startY = (h - boardS)/2 + 10;

                    for(let k=0; k<s; k++) {
                        const ox = startX + k*boxSize;
                        if(mx >= ox && mx <= ox+boardS && my >= startY && my <= startY+boardS) {
                            const c = Math.floor((mx-ox)/(boardS/s));
                            const r = Math.floor((my-startY)/(boardS/s));
                            let x,y,z;
                            if(this.axis3D==='z') { z=k; y=r; x=c; }
                            else if(this.axis3D==='y') { y=k; x=c; z=(s-1)-r; }
                            else { x=k; y=c; z=(s-1)-r; }
                            success = this.game.makeMove(z*9 + y*3 + x);
                            break;
                        }
                    }
                } 
                else if (this.gameType === 'ultimate') {
                    const bigS = this.canvas.width/3, smallS = bigS/3;
                    const bx = Math.floor(mx/bigS), by = Math.floor(my/bigS);
                    const sx = Math.floor((mx%bigS)/smallS), sy = Math.floor((my%bigS)/smallS);
                    if(bx>=0 && bx<3 && by>=0 && by<3) {
                        success = this.game.makeMove(by*3+bx, sy*3+sx);
                    }
                } 
                else { // Regular
                    const s = this.canvas.width/3;
                    const c = Math.floor(mx/s), r = Math.floor(my/s);
                    if(c>=0 && c<3 && r>=0 && r<3) success = this.game.makeMove(r*3+c);
                }

                if(success) {
                    this.draw();
                    this.checkWin();
                }
            },

            draw() {
                const c = this.canvas;
                if(this.gameType === 'regular') TTTRenderer.drawRegular(c, this.game);
                else if(this.gameType === 'ultimate') TTTRenderer.drawUltimate(c, this.game);
                else TTTRenderer.draw3DSlices(c, this.game, this.axis3D);
            },

            // --- KI ---
            setDelay(value) {
                this.delay = 1550 - parseInt(value);
            },

            async stepAI(fast = false) {
                if(this.game.winner !== 0) return;
                
                // Button-Blockierung w√§hrend KI l√§uft (Punkt l)
                const stepBtn = document.querySelector('[onclick="Lab.stepAI()"]');
                stepBtn.disabled = true;
                stepBtn.style.opacity = '0.5';
                stepBtn.style.cursor = 'not-allowed';
                
                try {
                    const p = this.game.currentPlayer;
                    const viz = (p===1) ? this.vizP1 : this.vizP2;
                    const tree = this.trees[p];

                    viz.clearHighlights();
                    this.updateStatus(`KI ${p===1?'Blau':'Rot'} rechnet...`);

                    const move = await this.evaluateVisual(tree.root, this.game, viz, fast ? 0 : this.delay);

                    if (move) {
                        if (this.gameType === 'ultimate' && typeof move === 'object') 
                            this.game.makeMove(move.big, move.small);
                        else 
                            this.game.makeMove(move);
                        
                        this.draw();
                        this.checkWin();
                    } else {
                        this.log(`KI ${p} findet keinen Zug!`);
                    }
                } finally {
                    // Button wieder aktivieren
                    stepBtn.disabled = false;
                    stepBtn.style.opacity = '1';
                    stepBtn.style.cursor = 'pointer';
                }
            },

            async evaluateVisual(node, gameState, viz, ms) {
                if (!node || !node.active) return null;
                
                // Punkt j) FIX: Tracking f√ºr korrekte Cleanup
                const traverse = async (n) => {
                    if (!n || !n.active) return null;
                    
                    // Highlighting
                    if (ms > 0) {
                        viz.highlightCheck(n.name);
                        await new Promise(r => setTimeout(r, ms));
                    }

                    // Condition (If-Then-Else)
                    if (n.conditionFn) {
                        const res = n.conditionFn(gameState);
                        const targetNode = res ? n.thenNode : n.elseNode;
                        const result = await traverse(targetNode);
                        
                        // Wenn nicht erfolgreich, cleanup
                        if (!result && ms > 0) {
                            viz._removeClass(n.name, 'checking');
                        }
                        return result;
                    }
                    
                    // Group (iterate children with cleanup)
                    if (n.children && n.children.length > 0) {
                        for (const child of n.children) {
                            const result = await traverse(child);
                            if (result) {
                                return result;  // Nur Gewinner-Pfad
                            }
                            // Child nicht erfolgreich ‚Üí cleanup
                            if (ms > 0) {
                                viz._removeClass(child.name, 'checking');
                            }
                        }
                        // Keine Kinder erfolgreich
                        if (ms > 0) viz._removeClass(n.name, 'checking');
                        return null;
                    }

                    // Rule (atomic)
                    const result = n.evaluate(gameState);
                    if (result) {
                        // SUCCESS!
                        if (ms > 0) viz.highlightSuccess(n.name);
                        return result.move;
                    } else {
                        // Rule nicht erfolgreich
                        if (ms > 0) viz._removeClass(n.name, 'checking');
                        return null;
                    }
                };
                
                return await traverse(node);
            },

            toggleAutoMatch() {
                this.isAuto = !this.isAuto;
                const btn = document.getElementById('btnAuto');
                if (this.isAuto) {
                    btn.innerHTML = "‚èπ Stopp";
                    btn.style.background = "#c0392b";
                    this.loop();
                } else {
                    btn.innerHTML = "‚è© Auto";
                    btn.style.background = "#8e44ad";
                }
            },

            loop() {
                if(!this.isAuto || this.game.winner !== 0) {
                    this.isAuto = false;
                    document.getElementById('btnAuto').innerText = "‚è© Auto";
                    document.getElementById('btnAuto').style.background = "#8e44ad";
                    return;
                }
                // Wir rufen stepAI mit fast=false auf, damit man das Highlighting sieht!
                // Aber wir warten, bis der Step fertig ist (Async)
                this.stepAI(false).then(() => {
                    if(this.isAuto) setTimeout(() => this.loop(), 200);
                });
            },

            checkWin() {
                if(this.game.winner) {
                    const w = this.game.winner;
                    const msg = w===3 ? "Remis" : `Sieg ${w===1?'Blau':'Rot'}`;
                    this.updateStatus(msg);
                    this.log(msg);
                } else {
                    const p = this.game.currentPlayer;
                    this.updateStatus(`${p===1?'Blau':'Rot'} ist dran`);
                }
            },
            updateStatus(msg) { document.getElementById('statusText').innerText = msg || "Bereit"; },
            log(msg) { 
                const l = document.getElementById('log'); 
                l.innerHTML += `<div class="log-entry">${msg}</div>`; 
                l.scrollTop = l.scrollHeight;
            }
        };
        window.onload = () => Lab.init();
    </script>
</body>
</html>