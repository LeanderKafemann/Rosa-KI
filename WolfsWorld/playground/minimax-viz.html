<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimax Algorithmus Visualisierung</title>
    
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/tree-viz.css">
    
    <style>
        /* General Layout */
        body { 
            margin: 0; 
            font-family: 'Segoe UI', sans-serif; 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden; 
            background: #f0f3f4; 
        }
        
        .nav-header { 
            background: #2c3e50; 
            color: white; 
            padding: 0 20px; 
            display: flex; 
            align-items: center; 
            gap: 20px; 
            height: 50px; 
            flex-shrink: 0; 
        }
        .nav-header h1 { 
            margin: 0; 
            font-size: 1.2rem; 
            font-weight: normal; 
        }
        .btn-back { 
            text-decoration: none; 
            color: white; 
            border: 1px solid rgba(255,255,255,0.3); 
            padding: 5px 10px; 
            border-radius: 4px; 
            font-size: 0.9rem; 
        }
        .btn-back:hover { 
            background: rgba(255,255,255,0.1); 
        }

        /* Toolbar */
        .viz-toolbar { 
            background: white; 
            padding: 10px 20px; 
            border-bottom: 1px solid #ddd; 
            display: flex; 
            gap: 20px; 
            align-items: center; 
            flex-wrap: wrap; 
            flex-shrink: 0; 
            justify-content: space-between; 
        }
        .toolbar-group { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }
        .viz-select, .viz-input { 
            padding: 6px; 
            border: 1px solid #bdc3c7; 
            border-radius: 4px; 
            font-size: 0.95rem; 
        }
        .viz-toggle {
            transform: scale(1.1);
            cursor: pointer;
        }
        .viz-label { 
            font-size: 0.9rem; 
            font-weight: 600; 
            color: #34495e; 
        }
        .viz-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: background 0.2s;
            font-weight: 500;
        }
        .btn-primary { background: #3498db; color: white; }
        .btn-primary:hover { background: #2980b9; }
        .btn-secondary { background: #95a5a6; color: white; }
        .btn-secondary:hover { background: #7f8c8d; }
        
        #stats {
            font-size: 0.9rem;
            color: #7f8c8d;
            font-family: 'Courier New', monospace;
        }

        /* Split View */
        .split-container { 
            flex: 1; 
            display: flex; 
            min-height: 0; 
        }
        .tree-pane { 
            flex: 1; 
            border-right: 1px solid #bdc3c7; 
            background: #fff; 
            position: relative; 
        }
        .board-pane { 
            width: 450px; 
            background: #ecf0f1; 
            display: flex; 
            flex-direction: column; 
            flex-shrink: 0; 
            overflow-y: auto; 
            align-items: center; 
            padding: 20px; 
        }
        
        #vizFrame { 
            width: 100%; 
            height: 100%; 
            border: none; 
        }
        
        /* Board Area */
        .board-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 400px;
            box-sizing: border-box;
        }

        .board-container {
            width: 100%;
            aspect-ratio: 1;
            position: relative;
        }

        canvas { 
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 4px;
            cursor: pointer;
        }

        .board-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 0.95rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #ecf0f1;
        }

        .info-label {
            font-weight: 600;
            color: #7f8c8d;
        }

        .info-value {
            color: #2c3e50;
            font-family: 'Courier New', monospace;
        }

        .board-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .abp-help {
            margin-top: 8px;
            padding: 8px;
            background: #f8f9fa;
            border: 1px solid #dfe6e9;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #4b5563;
            line-height: 1.35;
        }

        .abp-help strong {
            color: #2c3e50;
        }
    </style>
</head>
<body>

    <!-- Header -->
    <div class="nav-header">
        <a href="../index.html" class="btn-back">‚¨Ö Men√º</a>
        <h1>Minimax Algorithmus Visualisierung</h1>
    </div>

    <!-- Toolbar -->
    <div class="viz-toolbar">
        <div class="toolbar-group">
            <label class="viz-label">Spiel</label>
            <select id="gameSelect" class="viz-select">
                <option value="regular">TicTacToe 3x3</option>
                <option value="3d">TicTacToe 3D</option>
            </select>
        </div>

        <div class="toolbar-group">
            <label class="viz-label">Algorithmus</label>
            <select id="algoSelect" class="viz-select">
                <option value="minimax">Minimax (Standard)</option>
                <option value="limited">Tiefenbegrenzung</option>
            </select>
        </div>

        <div class="toolbar-group">
            <label class="viz-label" for="abpToggle">AB-Pruning</label>
            <input type="checkbox" id="abpToggle" class="viz-toggle">
            <label class="viz-label" for="abOrderMode">Reihenfolge</label>
            <select id="abOrderMode" class="viz-select">
                <option value="free">frei</option>
                <option value="optimal">heuristisch g√ºnstig</option>
                <option value="strict">strikt (erzwingen)</option>
            </select>
        </div>

        <div class="toolbar-group">
            <label class="viz-label">Max. Tiefe</label>
            <input type="number" id="depthInput" value="2" min="1" max="9" class="viz-input" style="width: 60px;">
        </div>

        <div class="toolbar-group">
            <button id="btnNewGame" class="viz-btn btn-primary">üîÑ Neues Spiel</button>
            <button id="btnReset" class="viz-btn btn-secondary">üóë Baum l√∂schen</button>
        </div>

        <div id="stats">Bereit. Klicke auf das Board um zu spielen.</div>
    </div>

    <!-- Split Container -->
    <div class="split-container">
        <!-- Tree Pane (Left) -->
        <div class="tree-pane">
            <iframe id="vizFrame" src="tree-viz-v2.html?v=3.0&autoFitZoom=false"></iframe>
        </div>

        <!-- Board Pane (Right) -->
        <div class="board-pane">
            <div class="board-card">
                <h3 style="margin: 0; text-align: center; color: #2c3e50;">Spielbrett</h3>
                
                <div class="board-container">
                    <canvas id="boardCanvas" width="400" height="400"></canvas>
                </div>

                <div class="board-info">
                    <div class="info-row">
                        <span class="info-label">Aktiver Knoten Œ±:</span>
                        <span class="info-value" id="activeAlpha">n/a</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Aktiver Knoten Œ≤:</span>
                        <span class="info-value" id="activeBeta">n/a</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Œ±Œ≤-Einfluss:</span>
                        <span class="info-value" id="abInfluence">n/a</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Pruning-Status:</span>
                        <span class="info-value" id="abPruneStatus">n/a</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Geprunte Knoten:</span>
                        <span class="info-value" id="resultPruned">0</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Pruning-Quote:</span>
                        <span class="info-value" id="resultPruneRate">0%</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Quote-Basis:</span>
                        <span class="info-value" id="resultPruneBasis">pruned / (evaluated + pruned)</span>
                    </div>

                    <div class="abp-help" id="abpHelpText">
                        <strong>Alpha-Beta kurz erkl√§rt:</strong><br>
                        Œ± = beste bereits gefundene Untergrenze f√ºr MAX, Œ≤ = beste Obergrenze f√ºr MIN.<br>
                        Pruning bedeutet: ein Ast kann das Ergebnis nicht mehr verbessern und wird nicht weiter bewertet.<br>
                        Nutzen: gleiche Entscheidung wie Minimax, aber mit weniger berechneten Knoten.<br>
                        Bounds werden vom Elternknoten an noch offene Kinder weitergegeben.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <!-- ===== STEP 1: ZENTRALE KONSTANTEN (M√úSSEN ALS ERSTES!) ===== -->
    <script src="../js/config/debug-config.js"></script>
    <script src="../js/config/constants.js"></script>
    <script src="../js/ai/heuristics/config/ttt-heuristics-config.js"></script>
    
    <!-- ===== STEP 2: GAME LOGIC ===== -->
    <script src="../js/games/tictactoe/logic.js"></script>
    <script src="../js/games/tictactoe/renderer.js"></script>
    
    <!-- AI -->
    <script src="../js/ai/heuristics.js"></script>
    <script src="../js/ai/minimax.js"></script>
    
    <!-- Tree Visualization Utilities -->
    <script src="../js/viz/tree-viz/utils/node-status-manager.js"></script>
    <script src="../js/viz/shared/tree-analysis-utils.js"></script>
    
    <!-- Tree Adapter -->
    <script src="../js/viz/adapters/tree-adapters/base-tree-adapter.js"></script>
    <script src="../js/viz/adapters/tree-adapters/minimax-tree-adapter.js"></script>
    <script src="../js/viz/adapters/tree-adapters/alpha-beta-tree-adapter.js"></script>

    <script>
        /**
         * @fileoverview Minimax Visualisierung - Hauptlogik
         * Verbindet TicTacToe Board mit Minimax Tree Visualisierung
         */

        // ============================================================================
        // GLOBALS
        // ============================================================================
        const canvas = document.getElementById('boardCanvas');
        const iframe = document.getElementById('vizFrame');

        /** @type {{RETRY_DELAY_MS:number, MAX_RETRY_ATTEMPTS:number, RETRY_LOG_INTERVAL:number, PERCENT_BASE:number, STATS_NUMBER_FALLBACK:number}} */
        const MINIMAX_UI_CONSTANTS =
            typeof MINIMAX_VIZ_CONSTANTS !== 'undefined' && MINIMAX_VIZ_CONSTANTS.UI
                ? MINIMAX_VIZ_CONSTANTS.UI
                : {
                      RETRY_DELAY_MS: 120,
                      MAX_RETRY_ATTEMPTS: 30,
                      RETRY_LOG_INTERVAL: 5,
                      PERCENT_BASE: 100,
                      STATS_NUMBER_FALLBACK: 0,
                  };

        /**
         * Pr√ºft, ob Viz-UI Logs f√ºr diese Stufe ausgegeben werden sollen.
         * @param {'debug'|'warn'|'error'|'critical'} level
         * @returns {boolean}
         */
        function shouldLogViz(level = 'debug') {
            if (typeof window === 'undefined' || !window.DebugConfig || !window.DEBUG_DOMAINS) {
                return level === 'error' || level === 'critical';
            }
            return window.DebugConfig.shouldLog(window.DEBUG_DOMAINS.MINIMAX_VIZ_UI, level);
        }

        /**
         * Einheitlicher Viz-Logger.
         * @param {'debug'|'warn'|'error'|'critical'} level
         * @param {string} message
         * @param {Object} [payload]
         */
        function logViz(level, message, payload) {
            if (!shouldLogViz(level)) return;

            if (level === 'warn') {
                payload !== undefined ? console.warn(message, payload) : console.warn(message);
                return;
            }

            if (level === 'error' || level === 'critical') {
                payload !== undefined ? console.error(message, payload) : console.error(message);
                return;
            }

            payload !== undefined ? console.log(message, payload) : console.log(message);
        }
        
        let adapter = null;
        let currentBoard = null;
        let gameType = 'regular';
        let retryCount = 0;
        let lastVisualizationResult = null;
        let activeNodeInfo = null;

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        /**
         * Initialisiert die Visualisierung beim Laden
         */
        function init() {
            // Create adapter
            adapter = new MinimaxTreeAdapter(iframe);
            bindAdapterCallbacks();
            
            // Initialize board
            resetBoard();
            
            // Setup event listeners
            setupEventListeners();

            // Initial UI state for AB controls
            syncAlgorithmControls();
            applyABOrderingFlags();
            
            logViz('debug', 'Minimax-Viz: Initialized');
        }

        /**
         * Bindet Callback-Hooks an den aktiven Adapter.
         */
        function bindAdapterCallbacks() {
            if (!adapter) return;
            adapter.onActiveNodeChanged = (nodeId, nodeData) => {
                activeNodeInfo = {
                    nodeId,
                    alpha: nodeData && nodeData.alpha !== undefined ? nodeData.alpha : null,
                    beta: nodeData && nodeData.beta !== undefined ? nodeData.beta : null,
                    canPrune: !!(nodeData && nodeData.alpha !== undefined && nodeData.beta !== undefined && nodeData.alpha >= nodeData.beta),
                };
                updateDidacticPanel(lastVisualizationResult);
            };

            adapter.onStatsChanged = (stats) => {
                const nodesVisited = stats && typeof stats.nodesVisited === 'number' ? stats.nodesVisited : MINIMAX_UI_CONSTANTS.STATS_NUMBER_FALLBACK;
                const nodesPruned = stats && typeof stats.nodesPruned === 'number' ? stats.nodesPruned : MINIMAX_UI_CONSTANTS.STATS_NUMBER_FALLBACK;
                const bestValue =
                    lastVisualizationResult && lastVisualizationResult.bestValue !== undefined
                        ? lastVisualizationResult.bestValue
                        : null;

                lastVisualizationResult = {
                    ...(lastVisualizationResult || {}),
                    nodesVisited,
                    nodesPruned,
                    evaluatedNodes: stats && typeof stats.evaluatedNodes === 'number' ? stats.evaluatedNodes : MINIMAX_UI_CONSTANTS.STATS_NUMBER_FALLBACK,
                    bestValue,
                };

                updateDidacticPanel(lastVisualizationResult);
            };
        }

        /**
         * Setzt aktive Knotendaten aus der aktuellen Adapter-Struktur.
         * @param {number} nodeId
         */
        function updateActiveNodeInfoFromTree(nodeId) {
            if (!adapter || !adapter.treeStructure || !adapter.treeStructure.has(nodeId)) return;

            const nodeData = adapter.treeStructure.get(nodeId);
            activeNodeInfo = {
                nodeId,
                alpha: nodeData && nodeData.alpha !== undefined ? nodeData.alpha : null,
                beta: nodeData && nodeData.beta !== undefined ? nodeData.beta : null,
                canPrune: !!(nodeData && nodeData.alpha !== undefined && nodeData.beta !== undefined && nodeData.alpha >= nodeData.beta),
            };

            updateDidacticPanel(lastVisualizationResult);
        }

        /**
         * Setzt das Board auf Startzustand zur√ºck
         */
        function resetBoard() {
            gameType = document.getElementById('gameSelect').value;
            
            if (gameType === 'regular') {
                currentBoard = new TTTRegularBoard();
                canvas.width = 400;
                canvas.height = 400;
            } else {
                // 3D TicTacToe - TODO: Implementierung sp√§ter
                currentBoard = new TTTRegularBoard(); // Fallback
                canvas.width = 400;
                canvas.height = 400;
            }
            
            drawBoard();
            updateBoardInfo();
        }

        /**
         * Zeichnet das aktuelle Board
         */
        function drawBoard() {
            if (gameType === 'regular') {
                TTTRenderer.drawRegular(canvas, currentBoard);
            } else {
                // 3D rendering sp√§ter
                TTTRenderer.drawRegular(canvas, currentBoard);
            }
        }

        /**
         * Aktualisiert die Board-Informationen
         */
        function updateBoardInfo() {
            updateDidacticPanel(lastVisualizationResult);
        }

        /**
         * Anzahl gesetzter Z√ºge.
         * @returns {number}
         */
        function getMoveCount() {
            if (!currentBoard || !Array.isArray(currentBoard.grid)) return 0;
            return currentBoard.grid.filter((value) => value !== 0).length;
        }

        /**
         * Liest den effektiven Algorithmus aus UI-Zustand.
         * @returns {string}
         */
        function getEffectiveAlgorithm() {
            const selectedAlgo = document.getElementById('algoSelect').value;
            const abEnabled = document.getElementById('abpToggle').checked;

            if (selectedAlgo === 'limited') return 'limited';
            return abEnabled ? 'alphabeta' : 'minimax';
        }

        /**
         * Synchronisiert AB-Controls mit Algorithmus-Auswahl.
         */
        function syncAlgorithmControls() {
            const selectedAlgo = document.getElementById('algoSelect').value;
            const abpToggle = document.getElementById('abpToggle');
            const abOrderMode = document.getElementById('abOrderMode');

            const isLimited = selectedAlgo === 'limited';
            if (isLimited) {
                abpToggle.checked = false;
            }

            abpToggle.disabled = isLimited;
            abOrderMode.disabled = isLimited || !abpToggle.checked;
        }

        /**
         * Schreibt Reihenfolge-Modus in zentrale Flags.
         */
        function applyABOrderingFlags() {
            const abMode = document.getElementById('abOrderMode').value;

            if (typeof MINIMAX_VIZ_CONSTANTS === 'undefined' || !MINIMAX_VIZ_CONSTANTS.FLAGS) return;

            MINIMAX_VIZ_CONSTANTS.FLAGS.USE_ALPHABETA_MOVE_ORDERING = abMode === 'optimal' || abMode === 'strict';
            MINIMAX_VIZ_CONSTANTS.FLAGS.ENFORCE_ALPHABETA_EVAL_ORDER = abMode === 'strict';
        }

        /**
         * Aktualisiert didaktische Kontextinfos unter dem Brett.
         * @param {Object|null} result
         */
        function updateDidacticPanel(result = null) {
                const visited = result && typeof result.nodesVisited === 'number' ? result.nodesVisited : MINIMAX_UI_CONSTANTS.STATS_NUMBER_FALLBACK;
                const pruned = result && typeof result.nodesPruned === 'number' ? result.nodesPruned : MINIMAX_UI_CONSTANTS.STATS_NUMBER_FALLBACK;
            const evaluated =
                result && typeof result.evaluatedNodes === 'number'
                    ? result.evaluatedNodes
                    : Math.max(visited - pruned, MINIMAX_UI_CONSTANTS.STATS_NUMBER_FALLBACK);
            const pruneDenominator = evaluated + pruned;
                const pruneRate = pruneDenominator > 0 ? ((pruned / pruneDenominator) * MINIMAX_UI_CONSTANTS.PERCENT_BASE).toFixed(1) : '0.0';

            const alphaText =
                activeNodeInfo && activeNodeInfo.alpha !== null
                    ? (activeNodeInfo.alpha === -Infinity ? '-‚àû' : Number(activeNodeInfo.alpha).toFixed(2))
                    : 'n/a';
            const betaText =
                activeNodeInfo && activeNodeInfo.beta !== null
                    ? (activeNodeInfo.beta === Infinity ? '‚àû' : Number(activeNodeInfo.beta).toFixed(2))
                    : 'n/a';

            let influenceText = 'n/a';
            let pruneStatusText = 'n/a';
            if (activeNodeInfo) {
                influenceText = activeNodeInfo.canPrune
                    ? 'Schranke eng genug: Cut-off m√∂glich'
                    : 'Schranke noch offen';
                pruneStatusText = activeNodeInfo.canPrune ? 'Bedingung erf√ºllt: Œ± ‚â• Œ≤' : 'Bedingung nicht erf√ºllt: Œ± < Œ≤';
            }

            document.getElementById('activeAlpha').textContent = alphaText;
            document.getElementById('activeBeta').textContent = betaText;
            document.getElementById('abInfluence').textContent = influenceText;
            document.getElementById('abPruneStatus').textContent = pruneStatusText;
            document.getElementById('resultPruned').textContent = String(pruned);
            document.getElementById('resultPruneRate').textContent = `${pruneRate}%`;
            document.getElementById('resultPruneBasis').textContent = `pruned / (evaluated + pruned) = ${pruned} / (${evaluated} + ${pruned})`;
        }

        // ============================================================================
        // EVENT HANDLERS
        // ============================================================================
        
        /**
         * Setzt alle Event Listeners
         */
        function setupEventListeners() {
            // Canvas click
            canvas.addEventListener('click', handleBoardClick);
            
            // Button clicks
            document.getElementById('btnReset').addEventListener('click', resetVisualization);
            document.getElementById('btnNewGame').addEventListener('click', () => {
                resetBoard();
                resetVisualization();
            });
            
            // Game type change
            document.getElementById('gameSelect').addEventListener('change', resetBoard);
            
            // Algorithm/Depth change - trigger re-visualization if game is active
            document.getElementById('algoSelect').addEventListener('change', () => {
                syncAlgorithmControls();
                applyABOrderingFlags();
                updateDidacticPanel(lastVisualizationResult);
                if (currentBoard && currentBoard.winner === 0 && getMoveCount() > 0) {
                    visualizeMinimax();
                }
            });
            document.getElementById('abpToggle').addEventListener('change', () => {
                syncAlgorithmControls();
                applyABOrderingFlags();

                resetBoard();
                updateAdapter(getEffectiveAlgorithm());
                resetVisualization();
            });
            document.getElementById('abOrderMode').addEventListener('change', () => {
                applyABOrderingFlags();
                if (getEffectiveAlgorithm() === 'alphabeta') {
                    resetBoard();
                    updateAdapter(getEffectiveAlgorithm());
                    resetVisualization();
                    return;
                }

                updateDidacticPanel(lastVisualizationResult);
                if (currentBoard && currentBoard.winner === 0 && getMoveCount() > 0) {
                    visualizeMinimax();
                }
            });
            document.getElementById('depthInput').addEventListener('change', () => {
                if (currentBoard && currentBoard.winner === 0 && getMoveCount() > 0) {
                    visualizeMinimax();
                }
            });
            
            // Iframe load
            iframe.addEventListener('load', () => {
                logViz('debug', 'Minimax-Viz: Tree iframe loaded');
            });

            // Node click events from TreeViz frame (for side panel sync)
            window.addEventListener('message', (event) => {
                if (!event.data || (event.data.type !== 'NODE_CLICKED' && event.data.type !== 'NODE_FOCUSED')) return;
                if (event.data.nodeId === undefined || event.data.nodeId === null) return;
                updateActiveNodeInfoFromTree(event.data.nodeId);
            });
        }

        /**
         * Behandelt Klicks auf das Spielbrett
         * @param {MouseEvent} e
         */
        function handleBoardClick(e) {
            if (currentBoard.winner !== 0) {
                document.getElementById('stats').textContent = 'Spiel beendet. Klicke "Neues Spiel" zum Neustart.';
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            // Scale to canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = mx * scaleX;
            const canvasY = my * scaleY;
            
            const move = coordsToMove(canvasX, canvasY);
            
            // Check if move is valid: must be in valid moves list
            const validMoves = currentBoard.getAllValidMoves();
            if (move !== null && validMoves.includes(move)) {
                // makeMove modifies board in-place and returns boolean
                const success = currentBoard.makeMove(move);
                if (success) {
                    drawBoard();
                    updateBoardInfo();
                    
                    logViz('debug', 'Move played:', { move });
                    
                    // LIVE VISUALIZATION: Trigger tree update after move
                    if (currentBoard.winner === 0) {
                        visualizeMinimax();
                    }
                }
            }
        }

        /**
         * Konvertiert Canvas-Koordinaten zu Zug-Index
         * @param {number} mx
         * @param {number} my
         * @returns {number|null}
         */
        function coordsToMove(mx, my) {
            if (gameType === 'regular') {
                const s = canvas.width / 3;
                const c = Math.floor(mx / s);
                const r = Math.floor(my / s);
                
                if (c >= 0 && c < 3 && r >= 0 && r < 3) {
                    return r * 3 + c;
                }
            }
            return null;
        }

        /**
         * Checks and updates the adapter based on selected algorithm
         */
        function updateAdapter(algo) {
            let requiredClass = MinimaxTreeAdapter;
            if (algo === 'alphabeta') {
                requiredClass = AlphaBetaTreeAdapter;
            }
            // Note: 'limited' uses MinimaxTreeAdapter with depth limit
            
            if (!adapter || !(adapter instanceof requiredClass)) {
                logViz('debug', `Switching adapter to ${requiredClass.name}`);
                if (adapter && adapter.destroy) adapter.destroy();
                adapter = new requiredClass(iframe);
                bindAdapterCallbacks();
                retryCount = 0;
            }
        }

        /**
         * Startet Minimax-Visualisierung (LIVE nach jedem Zug)
         */
        async function visualizeMinimax() {
            const algo = getEffectiveAlgorithm();
            updateAdapter(algo);
            
            if (!adapter || !adapter.ready) {
                retryCount += 1;
                if (retryCount > MINIMAX_UI_CONSTANTS.MAX_RETRY_ATTEMPTS) {
                    logViz('error', 'Adapter not ready after retry limit', { algo, retryCount });
                    document.getElementById('stats').textContent = 'Fehler: Adapter nicht bereit (Timeout).';
                    retryCount = 0;
                    return;
                }

                if (retryCount === 1 || retryCount % MINIMAX_UI_CONSTANTS.RETRY_LOG_INTERVAL === 0) {
                    logViz('warn', 'Adapter not ready yet, retrying...', { retryCount, algo });
                }
                setTimeout(visualizeMinimax, MINIMAX_UI_CONSTANTS.RETRY_DELAY_MS);
                return;
            }

            retryCount = 0;
            
            const maxDepth = parseInt(document.getElementById('depthInput').value);
            document.getElementById('stats').textContent = 'Berechne Minimax-Baum...';
            try {
                const startTime = performance.now();
                const result = await adapter.visualizeSearch(currentBoard, {
                    algorithm: algo,
                    maxDepth: maxDepth,
                    stepMode: false
                });
                const endTime = performance.now();
                const duration = (endTime - startTime).toFixed(1);
                const nodesVisited = result && typeof result.nodesVisited === 'number' ? result.nodesVisited : MINIMAX_UI_CONSTANTS.STATS_NUMBER_FALLBACK;
                const nodesPruned = result && typeof result.nodesPruned === 'number' ? result.nodesPruned : MINIMAX_UI_CONSTANTS.STATS_NUMBER_FALLBACK;
                const bestValue = result && result.bestValue !== undefined && result.bestValue !== null ? result.bestValue : 'n/a';
                document.getElementById('stats').textContent = 
                    `Knoten: ${nodesVisited} | Geprunt: ${nodesPruned} | Zeit: ${duration}ms | Beste Bewertung: ${bestValue}`;
                lastVisualizationResult = result;
                updateDidacticPanel(result);
                logViz('debug', 'Minimax visualization complete:', result);
            } catch (err) {
                logViz('error', 'Visualization error:', err);
                document.getElementById('stats').textContent = 'Fehler: ' + err.message;
            }
        }

        /**
         * Setzt die Visualisierung zur√ºck
         */
        function resetVisualization() {
            if (adapter && adapter.ready) {
                adapter.sendCommand({ action: 'CLEAR' });
            }
            lastVisualizationResult = null;
            activeNodeInfo = null;
            updateDidacticPanel(null);
            document.getElementById('stats').textContent = 'Baum gel√∂scht. Klicke auf das Board um zu spielen.';
        }

        // ==================================================aum gel√∂scht. Klicke auf das Board um zu spielen=====================
        // STARTUP
        // ============================================================================
        
        // Initialize when iframe is loaded
        iframe.addEventListener('load', init);
        
        // Fallback: Also try on window load
        window.addEventListener('load', () => {
            if (!adapter) init();
        });
    </script>
</body>
</html>
