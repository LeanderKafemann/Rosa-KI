<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>KI Arena</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        .lab-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toolbar-left,
        .toolbar-center,
        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toolbar-center {
            margin: 0 auto;
        }

        .toolbar-right {
            margin-left: auto;
        }

        /* Spielfeld deutlich verkleinert - nur Deko */
        .col-game {
            flex: 0 0 280px; 
            min-width: 280px;
            width: 280px;
        }
        
        .canvas-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 5px 0;
        }
        
        canvas {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        /* Stats Bereich */
        .stats-box {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 12px;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            font-weight: 500;
            color: #555;
        }
        
        .stat-value {
            font-weight: bold;
            color: #2c3e50;
        }
        
        .stat-value.blue {
            color: #3498db;
        }
        
        .stat-value.red {
            color: #e74c3c;
        }
        
        .stat-value.draw {
            color: #95a5a6;
        }

        .random-mascot {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px 10px;
            margin: 10px;
            border: 2px dashed #d0d0d0;
            border-radius: 10px;
            background: #fafafa;
            color: #666;
            text-align: center;
            gap: 8px;
        }

        .random-emoji {
            font-size: 40px;
        }

        .random-text {
            font-size: 0.95em;
            font-weight: 600;
        }

        .minimax-panel {
            background: #fdfdfd;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 10px;
        }
        .desc-box {
            margin-top: 10px;
            padding: 10px;
            background: #eee;
            border-radius: 4px;
            font-size: 0.85em;
            color: #555;
            font-style: italic;
        }
        .formula-box {
            margin-top: 5px;
            font-family: monospace;
            background: #fff;
            padding: 4px;
            border: 1px solid #ccc;
            font-size: 0.8em;
        }
        .warn-msg {
            color: #d35400;
            font-weight: bold;
            font-size: 0.85em;
            margin-top: 5px;
        }

        /* 3D Connect 4 Side View - enable pointer if needed */
        .c4-3d-sideview {
             /* Handled in JS, just a note */
        }
    </style>
</head>
<body class="lab-page">

    <div class="lab-toolbar">
        <div class="toolbar-left">
            <a href="../index.html" class="viz-btn btn-back">‚¨Ö Men√º</a>

            <div class="viz-control-group">
                <label class="viz-label">Blau:</label>
                <select id="aiTypeBlue" class="viz-select" onchange="Arena.updateKIConfig(1)">
                    <option value="random" selected>Random</option>
                    <option value="ruledbased">Regelbaum</option>
                    <option value="minimax">Minimax</option>
                </select>
            </div>

            <div class="viz-control-group" id="paramBlueContainer"></div>
        </div>

        <div class="toolbar-center">
            <div class="viz-control-group">
                <label class="viz-label">Szenario:</label>
                <select id="gameTypeSelector" class="viz-select" onchange="Arena.changeGameType()">
                    <option value="regular">TTT Klassik 3x3</option>
                    <option value="3d">TTT 3D 3x3x3</option>
                    <option value="ultimate">TTT Ultimate</option>
                    <option value="c4_regular">4 Gewinnt Klassik</option>
                    <option value="c4_3d">4 Gewinnt 3D</option>
                </select>
            </div>

            <div class="viz-control-group">
                <label class="viz-label">Startspieler:</label>
                <select id="startPlayerSelector" class="viz-select">
                    <option value="1">Blau</option>
                    <option value="2">Rot</option>
                    <option value="random">Zufall</option>
                </select>
            </div>

            <div class="viz-control-group">
                <label class="viz-label">Spiele:</label>
                <input type="number" id="numGames" class="viz-select" value="10" min="1" max="1000" style="width: 80px;">
            </div>

            <div class="viz-control-group">
                <button class="viz-btn viz-btn-action" onclick="Arena.stepSingleGame()">‚ñ∂ Einzelspiel</button>
                <button class="viz-btn viz-btn-action" id="btnBattle" onclick="Arena.startBattle()">‚öîÔ∏è Battle</button>
            </div>
        </div>

        <div class="toolbar-right">
            <div class="viz-control-group">
                <label class="viz-label">Rot:</label>
                <select id="aiTypeRed" class="viz-select" onchange="Arena.updateKIConfig(2)">
                    <option value="random" selected>Random</option>
                    <option value="ruledbased">Regelbaum</option>
                    <option value="minimax">Minimax</option>
                </select>
            </div>

            <div class="viz-control-group" id="paramRedContainer"></div>

            <div class="viz-control-group">
                <button class="viz-btn viz-btn-restart" onclick="Arena.reset()">‚Ü∫ Reset</button>
            </div>
        </div>
    </div>

    <div class="lab-grid">
        
        <div class="col-tree">
            <div class="panel-header" style="border-left: 5px solid #3498db;">
                <span>üß†</span> KI Blau
            </div>
            <div class="tree-container" id="treeDisplayP1"></div>
            <div class="random-mascot" id="randomMascotP1">
                <div class="random-emoji">üé≤üéâ</div>
                <div class="random-text">Zufalls-KI</div>
                <div>Heute w√ºrfelt das Schicksal!</div>
            </div>
        </div>

        <div class="col-game">
            <div class="game-card">
                <div id="controls3D" class="view-controls hidden">
                    <button class="view-btn active" onclick="Arena.setAxis('z')">Ebenen</button>
                    <button class="view-btn" onclick="Arena.setAxis('y')">Vorne</button>
                    <button class="view-btn" onclick="Arena.setAxis('x')">Seite</button>
                </div>

                <div class="canvas-container">
                    <canvas id="gameCanvas" width="250" height="250"></canvas>
                </div>
                
                <div id="statusText" class="stats-display" style="margin-top:5px; font-size: 0.85em;">Bereit</div>
            </div>

            <div class="stats-box" id="statsPanel" style="display:none; margin-top: 10px;">
                <div class="stat-row">
                    <span class="stat-label">Spiele:</span>
                    <span class="stat-value" id="statGames">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Blau Siege:</span>
                    <span class="stat-value blue" id="statBlueWins">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Rot Siege:</span>
                    <span class="stat-value red" id="statRedWins">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Remis:</span>
                    <span class="stat-value draw" id="statDraws">0</span>
                </div>
                <div class="stat-row" style="border-top: 1px solid #bbb; margin-top: 6px; padding-top: 6px;">
                    <span class="stat-label">Blau %:</span>
                    <span class="stat-value blue" id="statBluePercent">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Rot %:</span>
                    <span class="stat-value red" id="statRedPercent">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Remis %:</span>
                    <span class="stat-value draw" id="statDrawPercent">0%</span>
                </div>
                <div class="stat-row" style="border-top: 1px solid #bbb; margin-top: 6px; padding-top: 6px;">
                    <span class="stat-label">√ò Z√ºge:</span>
                    <span class="stat-value" id="statAvgMoves">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Zeit total:</span>
                    <span class="stat-value" id="statTotalTime">0s</span>
                </div>
            </div>
        </div>

        <div class="col-tree">
            <div class="panel-header" style="border-left: 5px solid #e74c3c;">
                <span>ü§ñ</span> KI Rot
            </div>
            <div class="tree-container" id="treeDisplayP2"></div>
            <div class="random-mascot" id="randomMascotP2">
                <div class="random-emoji">üéØüçÄ</div>
                <div class="random-text">Zufalls-KI</div>
                <div>Treffer oder Gl√ºck!</div>
            </div>
        </div>
    </div>

    <script src="../js/core/game-state.js"></script>
    <script src="../js/core/game-adapter.js"></script>
    <script src="../js/games/tictactoe/logic.js"></script>
    <script src="../js/games/tictactoe/renderer.js"></script>
    <script src="../js/games/connect4/logic.js"></script>
    <script src="../js/games/connect4/renderer.js"></script>
    <script src="../js/ai/heuristics/base.js"></script>
    <script src="../js/ai/heuristics/ttt.js"></script>
    <script src="../js/ai/heuristics/connect4.js"></script>
    <script src="../js/ai/minimax.js"></script>
    <script src="../js/ai/rules/rule-structure.js"></script>
    <script src="../js/ai/rules/ttt-rules.js"></script>
    <script src="../js/ai/rules/connect4-rules.js"></script>
    <script src="../js/viz/specializers/flowchart/flowchart-visualizer.js"></script>

    <script>
        /**
         * Definitionen der verf√ºgbaren Heuristiken.
         * Mapping zwischen GUI-ID und Funktionsreferenz.
         */
        const HeuristicDefinitions = {
            'regular': [
                { 
                    id: 'standard', 
                    name: 'Standard (Sieg/2-in-Reihe)', 
                    desc: 'Bewertet Sieg (1000), 2-in-einer-Reihe (+10) und drohende Niederlagen (-10).', 
                    formula: 'Sieg: ¬±1000, 2er: ¬±10, 1er: ¬±1',
                    fn: HeuristicsLibrary.regularTTT
                },
                {
                    id: 'simple',
                    name: 'Naiv (Nur Sieg)',
                    desc: 'Sieht nur den sofortigen Sieg oder Niederlage. Sonst blind (0).',
                    formula: 'Sieg: ¬±100, Sonst: 0',
                    fn: (g, p) => (g.winner===p ? 100 : (g.winner && g.winner!==3 ? -100 : 0))
                }
            ],
            '3d': [
                { 
                    id: 'std_3d', 
                    name: 'Standard 3D', 
                    desc: 'Bewertet 3D-Reihen und Zentrumskontrolle.', 
                    formula: 'Sieg: ¬±10000, Linien, Zentrum',
                    fn: HeuristicsLibrary.ttt3d
                }
            ],
            'ultimate': [
                {
                    id: 'std_ult',
                    name: 'Standard Ultimate',
                    desc: 'Ber√ºcksichtigt lokale Boards und Makro-Strategie.',
                    formula: 'Global: ¬±50, Lokal: ¬±Regular',
                    fn: HeuristicsLibrary.ultimateTTT
                }
            ],
            'c4_regular': [
                { id: 'c4_std', name: 'Standard Scoring', desc: 'Bewertet Gewinnm√∂glichkeiten und Zentrum.', formula: 'Lines + Center', fn: HeuristicsLibrary.connect4.evaluate }
            ],
            'c4_3d': [
                { id: 'c4_3d_std', name: '3D Scoring', desc: 'Bewertet 3D Gewinnreihen.', formula: 'Lines 3D', fn: HeuristicsLibrary.connect4.evaluate3D }
            ]
        };

        const Arena = {
            adapter: null,  // GameAdapter f√ºr einheitliche Schnittstelle
            canvas: null,
            vizP1: null, vizP2: null, trees: { 1: null, 2: null },
            gameType: 'regular', axis3D: 'z', isBattle: false,
            
            stats: { blueWins: 0, redWins: 0, draws: 0, totalMoves: 0, totalTime: 0 },
            
            kiConfig: {
                1: { type: 'random', depth: 3, heuristicId: 'standard', useAlphaBeta: true },
                2: { type: 'random', depth: 3, heuristicId: 'standard', useAlphaBeta: true }
            },

            init() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.addEventListener('mousedown', (e) => this.handleClick(e));
                this.changeGameType();
                // updateKIConfig wird in changeGameType am Ende aufgerufen via reset -> updateKIConfig nicht direkt n√∂tig
                // Aber wir machen es explizit:
                this.updateKIConfig(1);
                this.updateKIConfig(2);
            },

            changeGameType() {
                this.gameType = document.getElementById('gameTypeSelector').value;
                const controls = document.getElementById('controls3D');
                
                this.canvas.width = 250; 
                this.canvas.height = 250;

                if (this.gameType === '3d') {
                    controls.classList.remove('hidden');
                    this.canvas.height = 150; 
                } else if (this.gameType === 'ultimate') {
                    controls.classList.add('hidden');
                    this.canvas.width = 300; 
                    this.canvas.height = 300;
                } else if (this.gameType === 'c4_3d') {
                    controls.classList.remove('hidden'); // Optional: Reuse axis controls for view switching if desired, though C4 3D shows both views.
                    // Actually C4 3D renderer shows both views at once, so "Ansicht" controls might be redundant or confusing?
                    // But let's leave them or hide them? 
                    // TTT 3D uses them to switch handling. C4 3D shows all.
                    // Let's hide controls for c4_3d for now to avoid confusion, 
                    // OR repurpose them. But C4 3D rendered logic is static (all slices).
                    controls.classList.add('hidden'); 
                    this.canvas.width = 600;
                    this.canvas.height = 400;
                } else if (this.gameType === 'c4_regular') {
                    controls.classList.add('hidden');
                    this.canvas.width = 350; // A bit wider for 7 cols
                    this.canvas.height = 300;
                } else {
                    controls.classList.add('hidden');
                }

                this.setupTrees();
                
                this.vizP1 = new FlowchartVisualizer('treeDisplayP1', this.trees[1], (n) => this.toggleRule(1, n));
                this.vizP2 = new FlowchartVisualizer('treeDisplayP2', this.trees[2], (n) => this.toggleRule(2, n));
                
                // Heuristik Defaults resetten wenn Spieltyp √§ndert
                const defs = HeuristicDefinitions[this.gameType] || [];
                if(defs.length > 0) {
                     this.kiConfig[1].heuristicId = defs[0].id;
                     this.kiConfig[2].heuristicId = defs[0].id;
                }

                this.vizP1.render();
                this.vizP2.render();
                
                this.reset();
            },

            setupTrees() {
                if (this.gameType.startsWith('c4_')) { 
                    const variant = this.gameType === 'c4_3d' ? '3d' : 'regular';
                    this.trees[1] = Connect4RulesLibrary.createTree(variant, 'complex');
                    this.trees[2] = Connect4RulesLibrary.createTree(variant, 'complex');
                } else {
                    this.trees[1] = createStrategyTree(this.gameType);
                    this.trees[2] = createStrategyTree(this.gameType);
                }
            },
            
            reset() {
                let gameBoard;
                if(this.gameType === 'regular') gameBoard = new TTTRegularBoard();
                else if(this.gameType === '3d') gameBoard = new TTT3DBoard(3);
                else if(this.gameType === 'ultimate') gameBoard = new UltimateBoard();
                else if(this.gameType === 'c4_regular') gameBoard = new Connect4Regular(6, 7);
                else if(this.gameType === 'c4_3d') gameBoard = new Connect43D(4);
                
                // Startspieler setzen
                const startSel = document.getElementById('startPlayerSelector').value;
                let startPlayer = 1;
                if(startSel === '2') startPlayer = 2;
                else if(startSel === 'random') startPlayer = Math.random() < 0.5 ? 1 : 2;
                
                gameBoard.currentPlayer = startPlayer;
                
                this.adapter = new GameAdapter(gameBoard, this.gameType);
                
                this.isBattle = false;
                document.getElementById('btnBattle').innerText = "‚öîÔ∏è Battle";
                document.getElementById('statsPanel').style.display = 'block';
                
                this.vizP1.clearHighlights();
                this.vizP2.clearHighlights();
                
                // UI Refresh erzwingen (falls Minimax Panel resettet werden muss)
                this.updateKIConfig(1);
                this.updateKIConfig(2);
                
                this.draw();
                this.updateStatus(`${startPlayer===1?'Blau':'Rot'} ist dran (Start)`);
                this.updateStats();
            },

            toggleRule(player, name) {
                const toggle = (n) => {
                    if (n.name === name) n.active = !n.active;
                    if (n.children) n.children.forEach(toggle);
                    if (n.thenNode) toggle(n.thenNode);
                    if (n.elseNode) toggle(n.elseNode);
                };
                toggle(this.trees[player].root);
                if(player===1) this.vizP1.render(); else this.vizP2.render();
            },

            setAxis(axis) {
                this.axis3D = axis;
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                const idx = axis==='z'?0 : axis==='y'?1 : 2;
                document.querySelectorAll('.view-btn')[idx].classList.add('active');
                this.draw();
            },

            handleClick(e) {
                if (this.adapter.getState().winner !== 0 || this.isBattle) return;

                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const mx = (e.clientX - rect.left) * scaleX;
                const my = (e.clientY - rect.top) * scaleY;

                let success = false;

                if (this.gameType === '3d') {
                    const s = 3; 
                    const w = this.canvas.width, h = this.canvas.height;
                    const pad = 10;
                    const availW = w - (pad*2), availH = h - (pad*2);
                    const boxSize = Math.min(availW/s, availH);
                    const gap = boxSize * 0.1;
                    const boardS = boxSize - gap;
                    const startX = (w - s*boxSize)/2 + gap/2;
                    const startY = (h - boardS)/2 + 5;

                    for(let k=0; k<s; k++) {
                        const ox = startX + k*boxSize;
                        if(mx >= ox && mx <= ox+boardS && my >= startY && my <= startY+boardS) {
                            const c = Math.floor((mx-ox)/(boardS/s));
                            const r = Math.floor((my-startY)/(boardS/s));
                            let x,y,z;
                            if(this.axis3D==='z') { z=k; y=r; x=c; }
                            else if(this.axis3D==='y') { y=k; x=c; z=(s-1)-r; }
                            else { x=k; y=c; z=(s-1)-r; }
                            success = this.adapter.makeMove(z*9 + y*3 + x);
                            break;
                        }
                    }
                } 
                else if (this.gameType === 'ultimate') {
                    const bigS = this.canvas.width/3, smallS = bigS/3;
                    const bx = Math.floor(mx/bigS), by = Math.floor(my/bigS);
                    const sx = Math.floor((mx%bigS)/smallS), sy = Math.floor((my%bigS)/smallS);
                    if(bx>=0 && bx<3 && by>=0 && by<3) {
                        success = this.adapter.makeMove({big: by*3+bx, small: sy*3+sx});
                    }
                } 
                else if (this.gameType === 'c4_regular') {
                    const cols = 7;
                    // Connect4Renderer uses min(w/cols, h/rows) to calculate S
                    // But centering is applied.
                    const rows = 6;
                    const w = this.canvas.width, h = this.canvas.height;
                    const s = Math.min(w / cols, h / rows);
                    const offsetX = (w - s * cols) / 2;
                    const offsetY = (h - s * rows) / 2;
                    
                    if (mx >= offsetX && mx <= offsetX + s*cols && my >= offsetY && my <= offsetY + s*rows) {
                        const col = Math.floor((mx - offsetX) / s);
                        if (col >= 0 && col < cols) {
                            success = this.adapter.makeMove(col);
                        }
                    }
                }
                else if (this.gameType === 'c4_3d') {
                    // Logic based on Connect4Renderer.draw3D
                    const s = 4;
                    const pad = 10;
                    const w = this.canvas.width;
                    const boardW = (w - pad * (s + 1)) / s;
                    const boardH = boardW;
                    const topY = 40;
                    const secondY = topY + boardH + 60;

                    // 1. Top View (Z Slices, labeled "Ebene Y")
                    if (my >= topY && my <= topY + boardH) {
                        for (let z = 0; z < s; z++) {
                            const startX = pad + z * (boardW + pad);
                            if (mx >= startX && mx <= startX + boardW) {
                                // Hit specific board (Slice Z)
                                const x = Math.floor((mx - startX) / (boardW / s));
                                if (x >= 0 && x < s) {
                                    // Move = x + z*size
                                    success = this.adapter.makeMove(x + z*s);
                                }
                            }
                        }
                    }
                    // 2. Side View (X Slices, labeled "Seite X")
                    else if (my >= secondY && my <= secondY + boardH) {
                        for (let x = 0; x < s; x++) {
                             const startX = pad + x * (boardW + pad);
                             if (mx >= startX && mx <= startX + boardW) {
                                 // Hit specific board (Slice X)
                                 // Horizontal axis is Z (0..3)
                                 const z = Math.floor((mx - startX) / (boardW / s));
                                 if (z >= 0 && z < s) {
                                     // Move = x + z*size
                                     success = this.adapter.makeMove(x + z*s);
                                 }
                             }
                        }
                    }
                }
                else {
                    const s = this.canvas.width/3;
                    const c = Math.floor(mx/s), r = Math.floor(my/s);
                    if(c>=0 && c<3 && r>=0 && r<3) success = this.adapter.makeMove(r*3+c);
                }

                if(success) {
                    this.draw();
                    this.checkWin();
                }
            },

            draw() {
                const c = this.canvas;
                const gameBoard = this.adapter.getState();
                if(this.gameType === 'regular') TTTRenderer.drawRegular(c, gameBoard);
                else if(this.gameType === 'ultimate') TTTRenderer.drawUltimate(c, gameBoard);
                else if(this.gameType === '3d') TTTRenderer.draw3DSlices(c, gameBoard, this.axis3D);
                else if(this.gameType === 'c4_regular') Connect4Renderer.drawRegular(c, gameBoard);
                else if(this.gameType === 'c4_3d') Connect4Renderer.draw3D(c, gameBoard);
            },

            updateKIConfig(player) {
                const typeSelector = document.getElementById(player === 1 ? 'aiTypeBlue' : 'aiTypeRed');
                const paramContainer = document.getElementById(player === 1 ? 'paramBlueContainer' : 'paramRedContainer');
                const treeContainer = document.getElementById(player === 1 ? 'treeDisplayP1' : 'treeDisplayP2');
                const mascot = document.getElementById(player === 1 ? 'randomMascotP1' : 'randomMascotP2');
                
                this.kiConfig[player].type = typeSelector.value;
                paramContainer.innerHTML = '';
                treeContainer.innerHTML = ''; // Clear previous content (Tree or Minimax Panel)
                
                // 1. RANDOM
                if (this.kiConfig[player].type === 'random') {
                    // Tree hidden, Mascot shown
                    treeContainer.style.display = 'none';
                    mascot.style.display = 'flex';
                } 
                // 2. RULES
                else if (this.kiConfig[player].type === 'ruledbased') {
                    treeContainer.style.display = 'block';
                    mascot.style.display = 'none';
                    // Re-Render Tree Visualizer
                    if(player===1) this.vizP1.render(); else this.vizP2.render();
                }
                // 3. MINIMAX
                else if (this.kiConfig[player].type === 'minimax') {
                    treeContainer.style.display = 'block';
                    mascot.style.display = 'none';
                    
                    // Render Minimax Controls INTO the tree container (Side Panel)
                    const heuristics = HeuristicDefinitions[this.gameType] || [];
                    const showHeuristics = this.gameType !== 'regular';
                    let heuristicOptions = '';
                    let currentDesc = '';
                    let currentFormula = '';
                    
                    // Validierung der gew√§hlten ID
                    let currentId = this.kiConfig[player].heuristicId;
                    const selected = heuristics.find(h => h.id === currentId);
                    if(!selected && heuristics.length > 0) {
                        currentId = heuristics[0].id; // Fallback
                        this.kiConfig[player].heuristicId = currentId;
                    }

                    if(showHeuristics && heuristics.length > 0) {
                        const hObj = heuristics.find(h => h.id === currentId) || heuristics[0];
                        currentDesc = hObj.desc;
                        currentFormula = hObj.formula;
                        
                        heuristicOptions = `
                            <div class="viz-control-group" style="margin-top: 10px;">
                                <label class="viz-label">Heuristik:</label>
                                <select class="viz-select" style="width: 100%;" 
                                    onchange="Arena.updateHeuristic(${player}, this.value)">
                                    ${heuristics.map(h => `<option value="${h.id}" ${h.id === currentId ? 'selected' : ''}>${h.name}</option>`).join('')}
                                </select>
                            </div>
                        `;
                    }

                    // Tiefe-Warnung & Alpha Beta
                    let depth = this.kiConfig[player].depth;
                    let maxDepth = 9;
                    let warning = '';
                    let alphaBetaUI = '';
                    let isLocked = false;
                    
                    // Logic: Standard TTT Minimax -> Force Depth 9, no heuristics
                    if (this.gameType === 'regular') {
                        depth = 9;
                        this.kiConfig[player].depth = 9;
                        isLocked = true;
                    }

                    if (this.gameType === '3d' || this.gameType === 'ultimate' || this.gameType.startsWith('c4_')) {
                         const useAB = this.kiConfig[player].useAlphaBeta;
                         const limit = useAB ? (this.gameType==='ultimate'?4:3) : (this.gameType==='ultimate'?3:2);
                         
                         if (depth > limit) warning = '<div class="warn-msg">‚ö†Ô∏è Hohe Tiefe kann langsam sein!</div>';
                         
                         alphaBetaUI = `
                             <div class="viz-control-group" style="margin-top:8px;">
                                <label style="display:flex; align-items:center; gap:6px; font-size:0.9em; cursor:pointer;">
                                    <input type="checkbox" ${useAB ? 'checked' : ''} 
                                           onchange="Arena.toggleAlphaBeta(${player}, this.checked)">
                                    Alpha-Beta Pruning üöÄ
                                </label>
                             </div>
                         `;
                    }

                    treeContainer.innerHTML = `
                        <div class="minimax-panel">
                            <h3 style="margin-top:0; color: #2c3e50; font-size: 1.1em; border-bottom: 2px solid #eee; padding-bottom: 8px;">Minimax Konfiguration</h3>
                            
                            <div class="viz-control-group">
                                <label class="viz-label">Such-Tiefe: <strong id="depthVal${player}" style="color:#3498db;">${depth}</strong></label>
                                <input type="range" class="viz-select" style="width: 100%; margin: 8px 0;" 
                                       id="depthSlider${player}"
                                       min="1" max="${maxDepth}" value="${depth}" ${isLocked ? 'disabled' : ''}
                                       onchange="Arena.updateDepth(${player}, this.value)">
                                ${warning}
                            </div>
                            
                            ${alphaBetaUI}

                            ${heuristicOptions}

                            ${showHeuristics ? `
                            <div class="desc-box">
                                <strong>Beschreibung:</strong><br>
                                <span id="hDesc${player}">${currentDesc}</span>
                            </div>
                            <div class="formula-box" id="hForm${player}">
                                ${currentFormula}
                            </div>
                            ` : ''}
                        </div>
                    `;
                }
            },

            toggleAlphaBeta(player, checked) {
                this.kiConfig[player].useAlphaBeta = checked;
                this.updateKIConfig(player); // UI Refresh f√ºr Warnungs-Logik
            },

            updateDepth(player, depth) {
                this.kiConfig[player].depth = parseInt(depth);
                document.getElementById(`depthVal${player}`).textContent = depth;
                // Warnung live updaten wenn n√∂tig (hier vereinfacht: Reload der Config)
                 if (this.gameType === '3d' || this.gameType === 'ultimate' || this.gameType.startsWith('c4_')) {
                     this.updateKIConfig(player); 
                 }
            },

            updateHeuristic(player, hId) {
                this.kiConfig[player].heuristicId = hId;
                // "Naiv" Logic check (UI Refresh if Regular+Simple)
                if (this.gameType === 'regular' && hId === 'simple') {
                    this.updateKIConfig(player);
                } else {
                    // Quick update
                    const heuristics = HeuristicDefinitions[this.gameType] || [];
                    const h = heuristics.find(x => x.id === hId);
                    if(h) {
                        document.getElementById(`hDesc${player}`).textContent = h.desc;
                        document.getElementById(`hForm${player}`).textContent = h.formula;
                    }
                    // Falls vorher "Simple" war (locked) und jetzt nicht mehr -> Unlock needed
                   if(document.querySelector(`#depthSlider${player}`)?.disabled) {
                       this.updateKIConfig(player);
                   }
                }
            },

            getValidMoves() {
                // ‚úÖ Nutze die standardisierte Schnittstelle
                return this.adapter.getAllValidMoves();
            },

            randomMove(gameState) {
                const moves = gameState.getAllValidMoves();
                return moves.length > 0 ? moves[Math.floor(Math.random() * moves.length)] : null;
            },

            getValidMovesFrom(gameState) {
                // ‚úÖ Nutze die standardisierte getAllValidMoves() Schnittstelle
                return gameState.getAllValidMoves();
            },

            cloneGame(gameState) {
                // ‚úÖ Nutze die standardisierte clone() Methode
                return gameState.clone();
            },

            async getKIMove(gameBoard, player, viz) {
                const pConfig = this.kiConfig[player];
                const type = pConfig.type;
                
                if (type === 'random') {
                    return this.randomMove(gameBoard);
                } else if (type === 'minimax') {
                    // Minimax Engine nutzen
                    const defs = HeuristicDefinitions[this.gameType] || [];
                    const hDef = defs.find(h => h.id === pConfig.heuristicId) || defs[0];
                    // Fallback func falls nichts definiert
                    const hFn = hDef ? hDef.fn : ((g, p) => 0); 
                    
                    const engine = new MinimaxEngine({
                        heuristicFn: hFn,
                        maxDepth: pConfig.depth,
                        useAlphaBeta: pConfig.useAlphaBeta !== false // Default true
                    });
                    
                    const result = engine.findBestMove(gameBoard);
                    return result.move;

                } else {
                    // Rule Based
                    const tree = this.trees[player];
                    return await this.evaluateVisual(tree.root, gameBoard, viz, 300);
                }
            },

            async stepSingleGame() {
                const gameBoard = this.adapter.getState();
                if(gameBoard.winner !== 0) {
                    this.reset();
                }
                
                const btn = document.querySelector('[onclick="Arena.stepSingleGame()"]');
                btn.disabled = true;
                btn.style.opacity = '0.5';
                
                try {
                    let moveCount = 0;
                    const maxMoves = 100;
                    
                    while(!this.adapter.getState().winner && moveCount < maxMoves) {
                        const gameBoard = this.adapter.getState();
                        const p = gameBoard.currentPlayer;
                        const viz = (this.kiConfig[p].type === 'ruledbased') ? (p===1 ? this.vizP1 : this.vizP2) : null;
                        
                        if (viz) viz.clearHighlights();
                        this.updateStatus(`Spiel l√§uft... Zug ${moveCount + 1}`);

                        const move = await this.getKIMove(gameBoard, p, viz);

                        if (move !== null && move !== undefined) {
                            try {
                                // ‚úÖ makeMove akzeptiert flexibel beide Formate
                                this.adapter.makeMove(move);
                                
                                this.draw();
                                moveCount++;
                                await new Promise(r => setTimeout(r, 250));
                            } catch (e) {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    this.checkWin();
                } finally {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }
            },

            async startBattle() {
                if(this.isBattle) return;
                
                this.isBattle = true;
                const btn = document.getElementById('btnBattle');
                btn.innerText = "‚èπ Stopp";
                btn.style.background = "#c0392b";
                
                const numGames = parseInt(document.getElementById('numGames').value) || 10;
                
                this.stats = { blueWins: 0, redWins: 0, draws: 0, totalMoves: 0, totalTime: 0 };
                const startTime = performance.now();

                for(let i = 0; i < numGames && this.isBattle; i++) {
                    await this.playBattleGame();
                    this.updateStats();
                    this.updateStatus(`Battle: Spiel ${i+1}/${numGames}`);
                    await new Promise(r => setTimeout(r, 50));
                }

                this.stats.totalTime = performance.now() - startTime;
                this.updateStats();
                this.updateStatus("Battle fertig!");
                
                this.isBattle = false;
                btn.innerText = "‚öîÔ∏è Battle";
                btn.style.background = "#8e44ad";
            },

            async playBattleGame() {
                let gameBoard;
                if(this.gameType === 'regular') gameBoard = new TTTRegularBoard();
                else if(this.gameType === '3d') gameBoard = new TTT3DBoard(3);
                else if(this.gameType === 'ultimate') gameBoard = new UltimateBoard();
                else if(this.gameType === 'c4_regular') gameBoard = new Connect4Regular(6, 7);
                else if(this.gameType === 'c4_3d') gameBoard = new Connect43D(4);
                
                // Startspieler setzen (f√ºr Battle auch jedes mal neu pr√ºfen, wichtig f√ºr "Zufall")
                const startSel = document.getElementById('startPlayerSelector').value;
                let startPlayer = 1;
                if(startSel === '2') startPlayer = 2;
                else if(startSel === 'random') startPlayer = Math.random() < 0.5 ? 1 : 2;
                
                gameBoard.currentPlayer = startPlayer;
                
                const tempAdapter = new GameAdapter(gameBoard, this.gameType);
                
                let moveCount = 0;
                const maxMoves = 100;
                
                while(!tempAdapter.getState().winner && moveCount < maxMoves) {
                    const currentBoard = tempAdapter.getState();
                    const p = currentBoard.currentPlayer;
                    
                    const move = await this.getKIMove(currentBoard, p, null);
                    
                    if (move !== null && move !== undefined) {
                        // ‚úÖ makeMove akzeptiert flexibel beide Formate
                        tempAdapter.makeMove(move);
                        moveCount++;
                    } else {
                        break;
                    }
                }
                
                const finalBoard = tempAdapter.getState();
                if(finalBoard.winner === 1) this.stats.blueWins++;
                else if(finalBoard.winner === 2) this.stats.redWins++;
                else this.stats.draws++;
                
                this.stats.totalMoves += moveCount;
            },

            async evaluateVisual(node, gameState, viz, ms) {
                if (!node || !node.active) return null;
                
                if (ms > 0 && viz) {
                    viz.highlightCheck(node.name);
                    await new Promise(r => setTimeout(r, ms));
                }

                if (node.conditionFn) {
                    const res = node.conditionFn(gameState);
                    const targetNode = res ? node.thenNode : node.elseNode;
                    const result = await this.evaluateVisual(targetNode, gameState, viz, ms);
                    
                    if (!result && ms > 0 && viz) {
                        viz._removeClass(node.name, 'checking');
                    }
                    return result;
                }
                
                if (node.children && node.children.length > 0) {
                    for (const child of node.children) {
                        const result = await this.evaluateVisual(child, gameState, viz, ms);
                        if (result) {
                            return result;
                        }
                        if (ms > 0 && viz) {
                            viz._removeClass(child.name, 'checking');
                        }
                    }
                    if (ms > 0 && viz) viz._removeClass(node.name, 'checking');
                    return null;
                }

                const result = node.evaluate(gameState);
                if (result) {
                    if (ms > 0 && viz) viz.highlightSuccess(node.name);
                    return result.move;
                } else {
                    if (ms > 0 && viz) viz._removeClass(node.name, 'checking');
                    return null;
                }
            },

            checkWin() {
                const gameBoard = this.adapter.getState();
                if(gameBoard.winner) {
                    const w = gameBoard.winner;
                    const msg = w===3 ? "Remis" : `Sieg ${w===1?'Blau':'Rot'}`;
                    this.updateStatus(msg);
                } else {
                    const p = gameBoard.currentPlayer;
                    this.updateStatus(`${p===1?'Blau':'Rot'} ist dran`);
                }
            },

            updateStats() {
                const total = this.stats.blueWins + this.stats.redWins + this.stats.draws;
                
                document.getElementById('statsPanel').style.display = 'block';
                document.getElementById('statGames').textContent = total;
                document.getElementById('statBlueWins').textContent = this.stats.blueWins;
                document.getElementById('statRedWins').textContent = this.stats.redWins;
                document.getElementById('statDraws').textContent = this.stats.draws;

                if (total > 0) {
                    const bluePercent = Math.round((this.stats.blueWins / total) * 100);
                    const redPercent = Math.round((this.stats.redWins / total) * 100);
                    const drawPercent = Math.round((this.stats.draws / total) * 100);
                    document.getElementById('statBluePercent').textContent = bluePercent + '%';
                    document.getElementById('statRedPercent').textContent = redPercent + '%';
                    document.getElementById('statDrawPercent').textContent = drawPercent + '%';

                    const avgMoves = (this.stats.totalMoves / total).toFixed(1);
                    document.getElementById('statAvgMoves').textContent = avgMoves;
                } else {
                    document.getElementById('statBluePercent').textContent = '0%';
                    document.getElementById('statRedPercent').textContent = '0%';
                    document.getElementById('statDrawPercent').textContent = '0%';
                    document.getElementById('statAvgMoves').textContent = '0.0';
                }

                const totalSecs = (this.stats.totalTime / 1000).toFixed(2);
                document.getElementById('statTotalTime').textContent = totalSecs + 's';
            },

            updateStatus(msg) { 
                document.getElementById('statusText').innerText = msg || "Bereit"; 
            }
        };
        window.onload = () => Arena.init();
    </script>
</body>
</html>

