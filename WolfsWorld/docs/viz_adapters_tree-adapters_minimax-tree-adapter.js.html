<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>viz/adapters/tree-adapters/minimax-tree-adapter.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Agent.html">Agent</a><ul class='methods'><li data-type='method'><a href="Agent.html#getAction">getAction</a></li></ul></li><li><a href="AlgorithmRunner.html">AlgorithmRunner</a><ul class='methods'><li data-type='method'><a href="AlgorithmRunner.html#setSpeed">setSpeed</a></li><li data-type='method'><a href="AlgorithmRunner.html#start">start</a></li><li data-type='method'><a href="AlgorithmRunner.html#stop">stop</a></li><li data-type='method'><a href="AlgorithmRunner.html#triggerStep">triggerStep</a></li></ul></li><li></li><li><a href="AlphaBetaTreeAdapter.html">AlphaBetaTreeAdapter</a><ul class='methods'><li data-type='method'><a href="AlphaBetaTreeAdapter.html#checkNodeStatus">checkNodeStatus</a></li><li data-type='method'><a href="AlphaBetaTreeAdapter.html#checkParentPruning">checkParentPruning</a></li><li data-type='method'><a href="AlphaBetaTreeAdapter.html#evaluateNode">evaluateNode</a></li><li data-type='method'><a href="AlphaBetaTreeAdapter.html#expandNodeChildren">expandNodeChildren</a></li></ul></li><li><a href="AtomicRule.html">AtomicRule</a></li><li><a href="BFSTreeAdapter.html">BFSTreeAdapter</a><ul class='methods'><li data-type='method'><a href="BFSTreeAdapter.html#buildToDepth">buildToDepth</a></li><li data-type='method'><a href="BFSTreeAdapter.html#focusNode">focusNode</a></li><li data-type='method'><a href="BFSTreeAdapter.html#getNodeCount">getNodeCount</a></li><li data-type='method'><a href="BFSTreeAdapter.html#getStats">getStats</a></li><li data-type='method'><a href="BFSTreeAdapter.html#highlightPath">highlightPath</a></li><li data-type='method'><a href="BFSTreeAdapter.html#resetView">resetView</a></li><li data-type='method'><a href="BFSTreeAdapter.html#startHandshake">startHandshake</a></li></ul></li><li><a href="BaseGameController.html">BaseGameController</a><ul class='methods'><li data-type='method'><a href="BaseGameController.html#checkTurn">checkTurn</a></li><li data-type='method'><a href="BaseGameController.html#coordsToMove">coordsToMove</a></li><li data-type='method'><a href="BaseGameController.html#createAIAgent">createAIAgent</a></li><li data-type='method'><a href="BaseGameController.html#createGame">createGame</a></li><li data-type='method'><a href="BaseGameController.html#drawGame">drawGame</a></li><li data-type='method'><a href="BaseGameController.html#getAISpeed">getAISpeed</a></li><li data-type='method'><a href="BaseGameController.html#handleCanvasClick">handleCanvasClick</a></li><li data-type='method'><a href="BaseGameController.html#init">init</a></li><li data-type='method'><a href="BaseGameController.html#reset">reset</a></li><li data-type='method'><a href="BaseGameController.html#updateUI">updateUI</a></li></ul></li><li><a href="BaseVisualizer.html">BaseVisualizer</a><ul class='methods'><li data-type='method'><a href="BaseVisualizer.html#canvasToWorld">canvasToWorld</a></li><li data-type='method'><a href="BaseVisualizer.html#drawOverlay">drawOverlay</a></li><li data-type='method'><a href="BaseVisualizer.html#executeCommand">executeCommand</a></li><li data-type='method'><a href="BaseVisualizer.html#render">render</a></li><li data-type='method'><a href="BaseVisualizer.html#resetView">resetView</a></li><li data-type='method'><a href="BaseVisualizer.html#sendToParent">sendToParent</a></li><li data-type='method'><a href="BaseVisualizer.html#worldToCanvas">worldToCanvas</a></li></ul></li><li><a href="Benchmark.html">Benchmark</a><ul class='methods'><li data-type='method'><a href="Benchmark.html#getAverage">getAverage</a></li><li data-type='method'><a href="Benchmark.html#getDuration">getDuration</a></li><li data-type='method'><a href="Benchmark.html#record">record</a></li><li data-type='method'><a href="Benchmark.html#reset">reset</a></li><li data-type='method'><a href="Benchmark.html#start">start</a></li><li data-type='method'><a href="Benchmark.html#stop">stop</a></li></ul></li><li><a href="ConditionNode.html">ConditionNode</a></li><li><a href="Connect43D.html">Connect43D</a></li><li><a href="Connect4Regular.html">Connect4Regular</a><ul class='methods'><li data-type='method'><a href="Connect4Regular.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="Connect4Regular.html#makeMove">makeMove</a></li></ul></li><li><a href="DFSTreeAdapter.html">DFSTreeAdapter</a><ul class='methods'><li data-type='method'><a href="DFSTreeAdapter.html#buildToDepth">buildToDepth</a></li><li data-type='method'><a href="DFSTreeAdapter.html#focusNode">focusNode</a></li><li data-type='method'><a href="DFSTreeAdapter.html#getNodeCount">getNodeCount</a></li><li data-type='method'><a href="DFSTreeAdapter.html#getStats">getStats</a></li><li data-type='method'><a href="DFSTreeAdapter.html#highlightPath">highlightPath</a></li><li data-type='method'><a href="DFSTreeAdapter.html#navigateInGame">navigateInGame</a></li><li data-type='method'><a href="DFSTreeAdapter.html#resetView">resetView</a></li><li data-type='method'><a href="DFSTreeAdapter.html#startHandshake">startHandshake</a></li><li data-type='method'><a href="DFSTreeAdapter.html#visualizeSearch">visualizeSearch</a></li></ul></li><li><a href="DecisionTree.html">DecisionTree</a></li><li><a href="FlowchartVisualizer.html">FlowchartVisualizer</a></li><li><a href="GameAdapter.html">GameAdapter</a><ul class='methods'><li data-type='method'><a href="GameAdapter.html#clone">clone</a></li><li data-type='method'><a href="GameAdapter.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="GameAdapter.html#getBoard">getBoard</a></li><li data-type='method'><a href="GameAdapter.html#getCurrentPlayer">getCurrentPlayer</a></li><li data-type='method'><a href="GameAdapter.html#getRemainingMoves">getRemainingMoves</a></li><li data-type='method'><a href="GameAdapter.html#getState">getState</a></li><li data-type='method'><a href="GameAdapter.html#getValidMoves">getValidMoves</a></li><li data-type='method'><a href="GameAdapter.html#getWinner">getWinner</a></li><li data-type='method'><a href="GameAdapter.html#isGameOver">isGameOver</a></li><li data-type='method'><a href="GameAdapter.html#makeMove">makeMove</a></li></ul></li><li><a href="KnightBoard.html">KnightBoard</a><ul class='methods'><li data-type='method'><a href="KnightBoard.html#_getMovesFrom">_getMovesFrom</a></li><li data-type='method'><a href="KnightBoard.html#clone">clone</a></li><li data-type='method'><a href="KnightBoard.html#getDegree">getDegree</a></li><li data-type='method'><a href="KnightBoard.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="KnightBoard.html#getPossibleMoves">getPossibleMoves</a></li><li data-type='method'><a href="KnightBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="KnightBoard.html#initGrid">initGrid</a></li><li data-type='method'><a href="KnightBoard.html#isGoal">isGoal</a></li><li data-type='method'><a href="KnightBoard.html#isInside">isInside</a></li><li data-type='method'><a href="KnightBoard.html#isUndoMove">isUndoMove</a></li><li data-type='method'><a href="KnightBoard.html#isValidMove">isValidMove</a></li><li data-type='method'><a href="KnightBoard.html#move">move</a></li><li data-type='method'><a href="KnightBoard.html#undo">undo</a></li></ul></li><li><a href="LearningPath.html">LearningPath</a><ul class='methods'><li data-type='method'><a href="LearningPath.html#enableNextButton">enableNextButton</a></li></ul></li><li><a href="MinimaxAgent.html">MinimaxAgent</a><ul class='methods'><li data-type='method'><a href="MinimaxAgent.html#getAction">getAction</a></li></ul></li><li></li><li><a href="MinimaxEngine.html">MinimaxEngine</a><ul class='methods'><li data-type='method'><a href="MinimaxEngine.html#findBestMove">findBestMove</a></li></ul></li><li><a href="MinimaxTreeAdapter.html">MinimaxTreeAdapter</a><ul class='methods'><li data-type='method'><a href="MinimaxTreeAdapter.html#checkNodeStatus">checkNodeStatus</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#createNode">createNode</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#evaluateNode">evaluateNode</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#expandNodeChildren">expandNodeChildren</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#visualizeSearch">visualizeSearch</a></li></ul></li><li></li><li><a href="NIMGameLogic.html">NIMGameLogic</a><ul class='methods'><li data-type='method'><a href="NIMGameLogic.html#_checkGameEnd">_checkGameEnd</a></li><li data-type='method'><a href="NIMGameLogic.html#clone">clone</a></li><li data-type='method'><a href="NIMGameLogic.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="NIMGameLogic.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="NIMGameLogic.html#makeMove">makeMove</a></li><li data-type='method'><a href="NIMGameLogic.html#toString">toString</a></li></ul></li><li><a href="RandomAgent.html">RandomAgent</a><ul class='methods'><li data-type='method'><a href="RandomAgent.html#getAction">getAction</a></li></ul></li><li><a href="RotateBoard.html">RotateBoard</a><ul class='methods'><li data-type='method'><a href="RotateBoard.html#canFall">canFall</a></li><li data-type='method'><a href="RotateBoard.html#clone">clone</a></li><li data-type='method'><a href="RotateBoard.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="RotateBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="RotateBoard.html#initFromId">initFromId</a></li><li data-type='method'><a href="RotateBoard.html#isGoal">isGoal</a></li><li data-type='method'><a href="RotateBoard.html#moveDown">moveDown</a></li><li data-type='method'><a href="RotateBoard.html#relaxBoardSync">relaxBoardSync</a></li><li data-type='method'><a href="RotateBoard.html#rotate">rotate</a></li></ul></li><li><a href="RuleBasedAgent.html">RuleBasedAgent</a><ul class='methods'><li data-type='method'><a href="RuleBasedAgent.html#getAction">getAction</a></li></ul></li><li></li><li><a href="RuleGroup.html">RuleGroup</a></li><li><a href="RuleNode.html">RuleNode</a><ul class='methods'><li data-type='method'><a href="RuleNode.html#evaluate">evaluate</a></li></ul></li><li><a href="RuleVisualizer.html">RuleVisualizer</a></li><li><a href="SearchEngine.html">SearchEngine</a><ul class='methods'><li data-type='method'><a href="SearchEngine.html#solve">solve</a></li></ul></li><li></li><li><a href="TTT3DBoard.html">TTT3DBoard</a><ul class='methods'><li data-type='method'><a href="TTT3DBoard.html#checkWin">checkWin</a></li><li data-type='method'><a href="TTT3DBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTT3DBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTT3DBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TTTBase.html">TTTBase</a><ul class='methods'><li data-type='method'><a href="TTTBase.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TTTGameAdapter.html">TTTGameAdapter</a><ul class='methods'><li data-type='method'><a href="TTTGameAdapter.html#clone">clone</a></li><li data-type='method'><a href="TTTGameAdapter.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTTGameAdapter.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTTGameAdapter.html#toJSON">toJSON</a></li></ul></li><li><a href="TTTRegularBoard.html">TTTRegularBoard</a><ul class='methods'><li data-type='method'><a href="TTTRegularBoard.html#checkWin">checkWin</a></li><li data-type='method'><a href="TTTRegularBoard.html#clone">clone</a></li><li data-type='method'><a href="TTTRegularBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTTRegularBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="TTTRegularBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTTRegularBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TemplateGameLogic.html">TemplateGameLogic</a><ul class='methods'><li data-type='method'><a href="TemplateGameLogic.html#_checkGameEnd">_checkGameEnd</a></li><li data-type='method'><a href="TemplateGameLogic.html#_isMoveInList">_isMoveInList</a></li><li data-type='method'><a href="TemplateGameLogic.html#clone">clone</a></li><li data-type='method'><a href="TemplateGameLogic.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TemplateGameLogic.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="TemplateGameLogic.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="TemplateGameLogic.html#isGoal">isGoal</a></li><li data-type='method'><a href="TemplateGameLogic.html#makeMove">makeMove</a></li></ul></li><li><a href="UltimateBoard.html">UltimateBoard</a><ul class='methods'><li data-type='method'><a href="UltimateBoard.html#_checkSmallWin">_checkSmallWin</a></li><li data-type='method'><a href="UltimateBoard.html#_isBoardFull">_isBoardFull</a></li><li data-type='method'><a href="UltimateBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="UltimateBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="UltimateBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="ai_minimax.js.html">ai/minimax.js</a></li></ul><h3>Namespaces</h3><ul><li><a href="MinimaxNodeRenderer.html">MinimaxNodeRenderer</a><ul class='methods'><li data-type='method'><a href="MinimaxNodeRenderer.html#.drawMetadata">drawMetadata</a></li><li data-type='method'><a href="MinimaxNodeRenderer.html#.render">render</a></li></ul></li></ul><h3>Interfaces</h3><ul><li><a href="GameState.html">GameState</a><ul class='methods'><li data-type='method'><a href="GameState.html#clone">clone</a></li><li data-type='method'><a href="GameState.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="GameState.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="GameState.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="GameState.html#isGoal">isGoal</a></li><li data-type='method'><a href="GameState.html#makeMove">makeMove</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#DEFAULT_STATUS_CONFIG">DEFAULT_STATUS_CONFIG</a></li><li><a href="global.html#GameFactories">GameFactories</a></li><li><a href="global.html#KnightsTourNodeRenderer">KnightsTourNodeRenderer</a></li><li><a href="global.html#NodeStatusManager">NodeStatusManager</a></li><li><a href="global.html#RotateBoxNodeRenderer">RotateBoxNodeRenderer</a></li><li><a href="global.html#StatusConfig">StatusConfig</a></li><li><a href="global.html#TTTGameFactory">TTTGameFactory</a></li><li><a href="global.html#TreeInteractionEngine">TreeInteractionEngine</a></li><li><a href="global.html#TreeLayoutEngine">TreeLayoutEngine</a></li><li><a href="global.html#VisualizationUtils">VisualizationUtils</a></li><li><a href="global.html#_convertStyleToRenderFormat">_convertStyleToRenderFormat</a></li><li><a href="global.html#animateRelax">animateRelax</a></li><li><a href="global.html#checkAndMarkDeadEnd">checkAndMarkDeadEnd</a></li><li><a href="global.html#checkSmallWin">checkSmallWin</a></li><li><a href="global.html#createAgentFromProfile">createAgentFromProfile</a></li><li><a href="global.html#createGame">createGame</a></li><li><a href="global.html#createStrategyTree">createStrategyTree</a></li><li><a href="global.html#drawRotateBoard">drawRotateBoard</a></li><li><a href="global.html#evaluateDefault">evaluateDefault</a></li><li><a href="global.html#evaluateTicTacToe">evaluateTicTacToe</a></li><li><a href="global.html#findLowestCommonAncestor">findLowestCommonAncestor</a></li><li><a href="global.html#findPathToRoot">findPathToRoot</a></li><li><a href="global.html#getAvailableGames">getAvailableGames</a></li><li><a href="global.html#getAvailableProfiles">getAvailableProfiles</a></li><li><a href="global.html#getNodeStyle">getNodeStyle</a></li><li><a href="global.html#getProfilesByType">getProfilesByType</a></li><li><a href="global.html#reconstructTreePath">reconstructTreePath</a></li><li><a href="global.html#setActiveNode">setActiveNode</a></li><li><a href="global.html#solveBFS">solveBFS</a></li><li><a href="global.html#updateActiveNodePosition">updateActiveNodePosition</a></li><li><a href="global.html#updateNodeStatus">updateNodeStatus</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">viz/adapters/tree-adapters/minimax-tree-adapter.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Minimax Tree Adapter - Visualisierung des Minimax Algorithmus
 * 
 * Konvertiert Minimax-Suchbaum in TreeVizEngine-Kommandos.
 * Unterstützt verschiedene Algorithmus-Varianten:
 * - Standard Minimax (vollständige Exploration)
 * - Alpha-Beta Pruning (mit Pruning-Markierungen)
 * - Tiefenbegrenzung (mit Heuristik-Bewertung)
 * - Interactive Evaluation Mode: Manuelles Bewerten durch Klicken
 * 
 * Status-Management: Nutzt zentrale NodeStatusManager Klasse
 * (siehe: /viz/tree-viz/utils/node-status-manager.js)
 * 
 * @class MinimaxTreeAdapter
 * @author Alexander Wolf
 * @version 2.0
 */
class MinimaxTreeAdapter {
    /**
     * Erstellt einen neuen Minimax Tree Adapter.
     * @param {HTMLIFrameElement} iframeElement - Das iframe-Element mit der TreeVizEngine.
     */
    constructor(iframeElement) {
        this.iframe = iframeElement;
        this.nodeIdCounter = 0;
        this.nodeMap = new Map();
        this.ready = false;
        this.commands = [];
        this.stats = { nodesVisited: 0, nodesPruned: 0 }; // Removed maxDepth stat
        
        // State management
        this.currentGameState = null;
        this.currentConfig = null;
        this.nodeStates = new Map(); // id -> GameState
        this.rootPlayer = null; // Speichert welcher Spieler am Root startet (für relative Bewertung)
        
        // Structure for Interactive Mode
        this.treeStructure = new Map(); // id -> { parentId, childrenIds[], status, value }
        
        // Listen for messages
        window.addEventListener('message', (event) => {
            if (!event.data) return;
            
            if (event.data.type === 'TREE_READY') {
                this.ready = true;
                if (this.checkInterval) clearInterval(this.checkInterval);
            }
            else if (event.data.type === 'NODE_EXPANSION_REQUEST') {
                this.handleExpansionRequest(event.data.nodeId);
            }
            else if (event.data.type === 'NODE_CLICKED') {
                this.handleNodeClick(event.data.nodeId);
            }
        });
        
        this.startHandshake();
    }

    startHandshake() {
        if (this.checkInterval) clearInterval(this.checkInterval);
        setTimeout(() => { this.ready = true; }, 500);
    }
    
    sendCommand(command) {
        if (!this.iframe || !this.iframe.contentWindow) return;
        this.iframe.contentWindow.postMessage({ type: 'TREE_COMMAND', command }, '*');
    }

    getBoardKey(board) {
        return board.getStateKey ? board.getStateKey() : JSON.stringify(board.grid || board);
    }

    /**
     * Startet die Visualisierung (Aufbauphase).
     */
    async visualizeSearch(gameState, config) {
        this.currentGameState = gameState;
        this.currentConfig = config;
        
        // Speichere den Root-Spieler für relative Bewertung
        // currentPlayer kann 1 (Blue) oder 2 (Red) sein
        this.rootPlayer = gameState.currentPlayer;
        
        this.reset();
        
        // Initialsierung
        this.commands = [];
        
        // Root Node erstellen
        const rootId = this.createNode(gameState, null, {
            depth: 0,
            isMaximizing: true,
            value: null
        });
        
        this.nodeStates.set(rootId, gameState);
        this.treeStructure.set(rootId, { 
            parentId: null, 
            children: [], 
            status: 'WAIT',
            value: null, 
            depth: 0,
            isMaximizing: true 
        });
        
        // Erste Ebene expandieren
        this.expandNodeChildren(rootId, gameState);
        
        // Update Root Status
        this.checkNodeStatus(rootId);
        
        this.flushCommands();
        
        return { bestMove: null };
    }
    
    flushCommands() {
        if (this.commands.length > 0) {
            this.sendCommand({ action: 'BATCH', commands: this.commands });
            this.commands = [];
        }
    }



    /**
     * Erstellt und registriert einen Knoten.
     */
    createNode(board, parentId, metadata) {
        const nodeId = this.nodeIdCounter++;
        const stateKey = this.getBoardKey(board);
        this.nodeMap.set(stateKey, nodeId);
        
        // SIMPLIFIED: Keine Beschriftung bei creation ("f = ???" weg)
        let label = "";
        
        // SIMPLIFIED: Initial immer WAIT
        const status = 'WAIT';
        
        const command = {
            action: 'ADD_NODE',
            id: nodeId,
            label: label,
            boardData: {
                grid: [...board.grid], // Copy grid
                currentPlayer: board.currentPlayer,
                size: board.size || 3,
                winner: board.winner
            },
            boardType: 'minimax',
            metadata: { ...metadata },
            status: status
        };
        
        if (parentId !== null) command.parentId = parentId;
        
        this.commands.push(command);
        return nodeId;
    }

    /**
     * Expandiert Kinder eines Knotens.
     * SIMPLIFIED: Removes maxDepth logic entirely.
     */
    expandNodeChildren(nodeId, state) {
        if (state.winner !== 0) return; // Terminal
        
        const validMoves = state.getAllValidMoves();
        const currentData = this.treeStructure.get(nodeId);
        const currentDepth = currentData ? currentData.depth : 0;
        
        const isMaximizing = (currentDepth % 2 === 0); // Root (0) is MAX
        const childIsMax = !isMaximizing;
        
        for (const move of validMoves) {
            const childState = state.clone();
            childState.makeMove(move);
            
            const childId = this.createNode(childState, nodeId, {
                depth: currentDepth + 1,
                isMaximizing: childIsMax,
                move: move,
                value: null
            });
            
            this.nodeStates.set(childId, childState);
            
            // Update Structure
            const childStruct = {
                parentId: nodeId,
                children: [],
                status: 'WAIT',
                value: null,
                depth: currentDepth + 1,
                isMaximizing: childIsMax,
                isTerminal: (childState.winner !== 0 || childState.getAllValidMoves().length === 0)
            };
            this.treeStructure.set(childId, childStruct);
            
            // Add to parent
            if (currentData) currentData.children.push(childId);
            
            // Mark expandable if not terminal
            if (!childStruct.isTerminal) {
                this.commands.push({ action: 'MARK_EXPANDABLE', id: childId });
            }
            
            // Check status immediately
            this.checkNodeStatus(childId);
        }
        
        // Re-check parent status now that it has children
        this.checkNodeStatus(nodeId);
    }

    /**
     * Prüft und aktualisiert den Status eines Knotens.
     */
    checkNodeStatus(nodeId) {
        const data = this.treeStructure.get(nodeId);
        if (!data) return;
        
        if (data.status === 'EVALUATED') return;
        
        let newStatus = 'WAIT';
        const state = this.nodeStates.get(nodeId);
        const isTerminal = state &amp;&amp; (state.winner !== 0 || state.getAllValidMoves().length === 0);
        
        // 1. Leaf Node (no children expanded or terminal)
        if (data.children.length === 0) {
            // "Prüfe ob Blattknoten... zurückbekommst, ob Spiel beendet ist"
            if (isTerminal) {
                newStatus = 'READY';
                // Node is terminal - ready for evaluation
                // Note: The visual border color (Blue/Red/Yellow) is applied when status becomes EVALUATED
                // after clicking, OR we can apply it here status-based if config supports it.
                // Standard: READY is orange. Click -> WIN_BLUE/WIN_RED.
            } else {
                newStatus = 'WAIT';
                // Non-terminal node - waiting for expansion
            }
        } 
        // 2. Inner Node
        else {
            // "Wenn alle Kindknoten bewertet sind -> Status Ready"
            const allChildrenEvaluated = data.children.every(childId => {
                const child = this.treeStructure.get(childId);
                return child &amp;&amp; child.status === 'EVALUATED';
            });
            
            if (allChildrenEvaluated) {
                newStatus = 'READY';
                // All children evaluated - ready for backpropagation
            } else {
                newStatus = 'WAIT';
                // Still waiting for children to be evaluated
            }
        }
        
        if (newStatus !== data.status) {
            NodeStatusManager.setNodeStatus(nodeId, newStatus, [], this.treeStructure, this.commands);
        }
    }

    handleNodeClick(nodeId) {
        const data = this.treeStructure.get(nodeId);
        if (!data) return;
        
        // Node clicked in interactive mode
        
        // "Wenn ein Knoten mit Status Ready angeklickt wird: bewerte ihn"
        if (data.status === 'READY') {
            this.commands = []; // Reset commands
            NodeStatusManager.setNodeStatus(nodeId, 'ACTIVE', [], this.treeStructure, this.commands);
            this.flushCommands();
            this.evaluateNode(nodeId);
        }
    }

    /**
     * Führt die Bewertung eines Knotens durch.
     */
    evaluateNode(nodeId) {
        const data = this.treeStructure.get(nodeId);
        const state = this.nodeStates.get(nodeId);
        
        this.commands = [];
        
        let value = 0;
        let labelText = "";
        let statusesToAdd = ['EVALUATED'];
        
        // Evaluate node and propagate values upward
        
        // CASE 1: Leaf Node (Terminal)
        if (data.children.length === 0) {
            // Bewertung RELATIV zum Root-Spieler, nicht absolut zu Blau/Rot
            if (state.winner === this.rootPlayer) {
                // Root-Spieler gewinnt → +1
                value = 1;
                const playerName = this.rootPlayer === 1 ? 'Blue' : 'Red';
                labelText = `${playerName} Win = +1`;
                // Visuelle Status hängt davon ab, welche Farbe Root-Spieler ist
                if (this.rootPlayer === 1) {
                    statusesToAdd.push('WIN_BLUE');
                } else {
                    statusesToAdd.push('WIN_RED');
                }
            } else if (state.winner !== 3 &amp;&amp; state.winner !== null &amp;&amp; state.winner !== undefined) {
                // Gegner gewinnt → -1
                value = -1;
                const playerName = this.rootPlayer === 1 ? 'Red' : 'Blue';
                labelText = `${playerName} Wins = -1`;
                // Visuelle Status für Gegner
                if (this.rootPlayer === 1) {
                    statusesToAdd.push('WIN_RED');
                } else {
                    statusesToAdd.push('WIN_BLUE');
                }
            } else if (state.winner === 3) {
                // Draw
                value = 0;
                labelText = "Remis = 0";
                statusesToAdd.push('DRAW');
            } else {
                // Technically shouldn't happen for READY leaves in this logic unless logic gap
                value = 0;
                labelText = "Val = 0";
            }
        } 
        // CASE 2: Inner Node
        else {
            const childValues = data.children.map(cid => {
                const child = this.treeStructure.get(cid);
                return child.value !== undefined &amp;&amp; child.value !== null ? child.value : 0;
            });
            
            if (data.isMaximizing) {
                value = Math.max(...childValues);
                const sign = value > 0 ? '+' : value &lt; 0 ? '-' : '';
                labelText = `Max = ${sign}${value}`;
            } else {
                value = Math.min(...childValues);
                const sign = value > 0 ? '+' : value &lt; 0 ? '-' : '';
                labelText = `Min = ${sign}${value}`;
            }
            
            // Visualisierung des besten Pfades
            data.children.forEach(childId => {
                const childData = this.treeStructure.get(childId);
                if (childData &amp;&amp; childData.value === value) {
                    let edgeColor = value > 0 ? '#2730ae' : value &lt; 0 ? '#c0392b' : '#a4ae1c';
                    this.commands.push({
                        action: 'HIGHLIGHT_EDGE',
                        from: nodeId,
                        to: childId,
                        color: edgeColor,
                        width: 4
                    });
                }
            });

             // Apply board color for winning positions (propagation) - RELATIV zu Root-Spieler
            if (value === 1) {
                // Guter Wert für Root-Spieler (Maximierer)
                if (this.rootPlayer === 1) {
                    statusesToAdd.push('WIN_BLUE');
                } else {
                    statusesToAdd.push('WIN_RED');
                }
            } else if (value === -1) {
                // Schlechter Wert für Root-Spieler (Gegner gewinnt)
                if (this.rootPlayer === 1) {
                    statusesToAdd.push('WIN_RED');
                } else {
                    statusesToAdd.push('WIN_BLUE');
                }
            } else {
                statusesToAdd.push('DRAW');
            }
        }
        
        // Save value
        data.value = value;
        
        // Set status and add additional statuses
        NodeStatusManager.setNodeStatus(nodeId, 'EVALUATED', statusesToAdd, this.treeStructure, this.commands);
        
        // Update label and metadata
        this.commands.push({
            action: 'UPDATE_NODE',
            id: nodeId,
            data: {
                label: labelText,
                metadata: { value: value }
            }
        });
        
        // "Wenn ein neuer Knoten bewertet wurde, prüfe den Status des Elternknotens"
        if (data.parentId !== null) {
            this.checkNodeStatus(data.parentId);
        }
        
        this.flushCommands();
    }

    handleExpansionRequest(nodeId) {
        // Handle node expansion request from visualization
        this.commands = [];
        const data = this.treeStructure.get(nodeId);
        
        // Only expand if we have state
        if (this.nodeStates.has(nodeId)) {
            // Force expansion completely ignored, simpler logic
            this.expandNodeChildren(nodeId, this.nodeStates.get(nodeId));
        }
        this.flushCommands();
    }
    
    reset() {
        this.nodeIdCounter = 0;
        this.nodeMap.clear();
        this.treeStructure.clear();
        this.nodeStates.clear();
        this.commands = [];
        this.sendCommand({ action: 'CLEAR' });
        
        // Config wieder senden
        this.sendCommand({ 
            action: 'UPDATE_CONFIG', 
            config: { 
                showLevelIndicators: true,
                levelIndicatorType: 'minimax',
                rootPlayerColor: '#e74c3c',    
                opponentColor: '#3498db'       
            } 
        });
    }
}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Sat Feb 07 2026 23:25:54 GMT+0100 (Central European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
