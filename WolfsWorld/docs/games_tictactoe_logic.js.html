<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>games/tictactoe/logic.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Agent.html">Agent</a><ul class='methods'><li data-type='method'><a href="Agent.html#getAction">getAction</a></li></ul></li><li><a href="AlgorithmRunner.html">AlgorithmRunner</a><ul class='methods'><li data-type='method'><a href="AlgorithmRunner.html#setSpeed">setSpeed</a></li><li data-type='method'><a href="AlgorithmRunner.html#start">start</a></li><li data-type='method'><a href="AlgorithmRunner.html#stop">stop</a></li><li data-type='method'><a href="AlgorithmRunner.html#triggerStep">triggerStep</a></li></ul></li><li></li><li><a href="AtomicRule.html">AtomicRule</a></li><li><a href="BFSTreeAdapter.html">BFSTreeAdapter</a><ul class='methods'><li data-type='method'><a href="BFSTreeAdapter.html#buildToDepth">buildToDepth</a></li><li data-type='method'><a href="BFSTreeAdapter.html#focusNode">focusNode</a></li><li data-type='method'><a href="BFSTreeAdapter.html#getNodeCount">getNodeCount</a></li><li data-type='method'><a href="BFSTreeAdapter.html#getStats">getStats</a></li><li data-type='method'><a href="BFSTreeAdapter.html#highlightPath">highlightPath</a></li><li data-type='method'><a href="BFSTreeAdapter.html#resetView">resetView</a></li><li data-type='method'><a href="BFSTreeAdapter.html#startHandshake">startHandshake</a></li></ul></li><li><a href="BaseGameController.html">BaseGameController</a><ul class='methods'><li data-type='method'><a href="BaseGameController.html#checkTurn">checkTurn</a></li><li data-type='method'><a href="BaseGameController.html#coordsToMove">coordsToMove</a></li><li data-type='method'><a href="BaseGameController.html#createAIAgent">createAIAgent</a></li><li data-type='method'><a href="BaseGameController.html#createGame">createGame</a></li><li data-type='method'><a href="BaseGameController.html#drawGame">drawGame</a></li><li data-type='method'><a href="BaseGameController.html#getAISpeed">getAISpeed</a></li><li data-type='method'><a href="BaseGameController.html#handleCanvasClick">handleCanvasClick</a></li><li data-type='method'><a href="BaseGameController.html#init">init</a></li><li data-type='method'><a href="BaseGameController.html#reset">reset</a></li><li data-type='method'><a href="BaseGameController.html#updateUI">updateUI</a></li></ul></li><li><a href="Benchmark.html">Benchmark</a><ul class='methods'><li data-type='method'><a href="Benchmark.html#getAverage">getAverage</a></li><li data-type='method'><a href="Benchmark.html#getDuration">getDuration</a></li><li data-type='method'><a href="Benchmark.html#record">record</a></li><li data-type='method'><a href="Benchmark.html#reset">reset</a></li><li data-type='method'><a href="Benchmark.html#start">start</a></li><li data-type='method'><a href="Benchmark.html#stop">stop</a></li></ul></li><li><a href="ConditionNode.html">ConditionNode</a></li><li><a href="Connect43D.html">Connect43D</a></li><li><a href="Connect4Regular.html">Connect4Regular</a><ul class='methods'><li data-type='method'><a href="Connect4Regular.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="Connect4Regular.html#makeMove">makeMove</a></li></ul></li><li><a href="DFSTreeAdapter.html">DFSTreeAdapter</a><ul class='methods'><li data-type='method'><a href="DFSTreeAdapter.html#buildToDepth">buildToDepth</a></li><li data-type='method'><a href="DFSTreeAdapter.html#focusNode">focusNode</a></li><li data-type='method'><a href="DFSTreeAdapter.html#getNodeCount">getNodeCount</a></li><li data-type='method'><a href="DFSTreeAdapter.html#getStats">getStats</a></li><li data-type='method'><a href="DFSTreeAdapter.html#highlightPath">highlightPath</a></li><li data-type='method'><a href="DFSTreeAdapter.html#resetView">resetView</a></li><li data-type='method'><a href="DFSTreeAdapter.html#startHandshake">startHandshake</a></li><li data-type='method'><a href="DFSTreeAdapter.html#visualizeSearch">visualizeSearch</a></li></ul></li><li><a href="DecisionTree.html">DecisionTree</a></li><li><a href="FlowchartVisualizer.html">FlowchartVisualizer</a></li><li><a href="GameAdapter.html">GameAdapter</a><ul class='methods'><li data-type='method'><a href="GameAdapter.html#clone">clone</a></li><li data-type='method'><a href="GameAdapter.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="GameAdapter.html#getBoard">getBoard</a></li><li data-type='method'><a href="GameAdapter.html#getCurrentPlayer">getCurrentPlayer</a></li><li data-type='method'><a href="GameAdapter.html#getRemainingMoves">getRemainingMoves</a></li><li data-type='method'><a href="GameAdapter.html#getState">getState</a></li><li data-type='method'><a href="GameAdapter.html#getValidMoves">getValidMoves</a></li><li data-type='method'><a href="GameAdapter.html#getWinner">getWinner</a></li><li data-type='method'><a href="GameAdapter.html#isGameOver">isGameOver</a></li><li data-type='method'><a href="GameAdapter.html#makeMove">makeMove</a></li></ul></li><li><a href="KnightBoard.html">KnightBoard</a><ul class='methods'><li data-type='method'><a href="KnightBoard.html#_getMovesFrom">_getMovesFrom</a></li><li data-type='method'><a href="KnightBoard.html#clone">clone</a></li><li data-type='method'><a href="KnightBoard.html#getDegree">getDegree</a></li><li data-type='method'><a href="KnightBoard.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="KnightBoard.html#getPossibleMoves">getPossibleMoves</a></li><li data-type='method'><a href="KnightBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="KnightBoard.html#initGrid">initGrid</a></li><li data-type='method'><a href="KnightBoard.html#isGoal">isGoal</a></li><li data-type='method'><a href="KnightBoard.html#isInside">isInside</a></li><li data-type='method'><a href="KnightBoard.html#isValidMove">isValidMove</a></li><li data-type='method'><a href="KnightBoard.html#move">move</a></li><li data-type='method'><a href="KnightBoard.html#undo">undo</a></li></ul></li><li><a href="LearningPath.html">LearningPath</a><ul class='methods'><li data-type='method'><a href="LearningPath.html#enableNextButton">enableNextButton</a></li></ul></li><li><a href="MinimaxAgent.html">MinimaxAgent</a><ul class='methods'><li data-type='method'><a href="MinimaxAgent.html#getAction">getAction</a></li></ul></li><li></li><li><a href="MinimaxEngine.html">MinimaxEngine</a><ul class='methods'><li data-type='method'><a href="MinimaxEngine.html#findBestMove">findBestMove</a></li></ul></li><li><a href="NIMGameLogic.html">NIMGameLogic</a><ul class='methods'><li data-type='method'><a href="NIMGameLogic.html#_checkGameEnd">_checkGameEnd</a></li><li data-type='method'><a href="NIMGameLogic.html#clone">clone</a></li><li data-type='method'><a href="NIMGameLogic.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="NIMGameLogic.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="NIMGameLogic.html#makeMove">makeMove</a></li><li data-type='method'><a href="NIMGameLogic.html#toString">toString</a></li></ul></li><li><a href="RandomAgent.html">RandomAgent</a><ul class='methods'><li data-type='method'><a href="RandomAgent.html#getAction">getAction</a></li></ul></li><li><a href="RotateBoard.html">RotateBoard</a><ul class='methods'><li data-type='method'><a href="RotateBoard.html#canFall">canFall</a></li><li data-type='method'><a href="RotateBoard.html#clone">clone</a></li><li data-type='method'><a href="RotateBoard.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="RotateBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="RotateBoard.html#initFromId">initFromId</a></li><li data-type='method'><a href="RotateBoard.html#isGoal">isGoal</a></li><li data-type='method'><a href="RotateBoard.html#moveDown">moveDown</a></li><li data-type='method'><a href="RotateBoard.html#relaxBoardSync">relaxBoardSync</a></li><li data-type='method'><a href="RotateBoard.html#rotate">rotate</a></li></ul></li><li><a href="RuleBasedAgent.html">RuleBasedAgent</a><ul class='methods'><li data-type='method'><a href="RuleBasedAgent.html#getAction">getAction</a></li></ul></li><li></li><li><a href="RuleGroup.html">RuleGroup</a></li><li><a href="RuleNode.html">RuleNode</a><ul class='methods'><li data-type='method'><a href="RuleNode.html#evaluate">evaluate</a></li></ul></li><li><a href="RuleVisualizer.html">RuleVisualizer</a></li><li><a href="SearchEngine.html">SearchEngine</a><ul class='methods'><li data-type='method'><a href="SearchEngine.html#solve">solve</a></li></ul></li><li></li><li><a href="TTT3DBoard.html">TTT3DBoard</a><ul class='methods'><li data-type='method'><a href="TTT3DBoard.html#checkWin">checkWin</a></li><li data-type='method'><a href="TTT3DBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTT3DBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTT3DBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TTTBase.html">TTTBase</a><ul class='methods'><li data-type='method'><a href="TTTBase.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TTTGameAdapter.html">TTTGameAdapter</a><ul class='methods'><li data-type='method'><a href="TTTGameAdapter.html#clone">clone</a></li><li data-type='method'><a href="TTTGameAdapter.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTTGameAdapter.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTTGameAdapter.html#toJSON">toJSON</a></li></ul></li><li><a href="TTTRegularBoard.html">TTTRegularBoard</a><ul class='methods'><li data-type='method'><a href="TTTRegularBoard.html#checkWin">checkWin</a></li><li data-type='method'><a href="TTTRegularBoard.html#clone">clone</a></li><li data-type='method'><a href="TTTRegularBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTTRegularBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="TTTRegularBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTTRegularBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TemplateGameLogic.html">TemplateGameLogic</a><ul class='methods'><li data-type='method'><a href="TemplateGameLogic.html#_checkGameEnd">_checkGameEnd</a></li><li data-type='method'><a href="TemplateGameLogic.html#_isMoveInList">_isMoveInList</a></li><li data-type='method'><a href="TemplateGameLogic.html#clone">clone</a></li><li data-type='method'><a href="TemplateGameLogic.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TemplateGameLogic.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="TemplateGameLogic.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="TemplateGameLogic.html#isGoal">isGoal</a></li><li data-type='method'><a href="TemplateGameLogic.html#makeMove">makeMove</a></li></ul></li><li><a href="TreeNode.html">TreeNode</a></li><li><a href="TreeVisualizer.html">TreeVisualizer</a><ul class='methods'><li data-type='method'><a href="TreeVisualizer.html#drawTree">drawTree</a></li></ul></li><li><a href="TreeVizEngine.html">TreeVizEngine</a><ul class='methods'><li data-type='method'><a href="TreeVizEngine.html#addNode">addNode</a></li><li data-type='method'><a href="TreeVizEngine.html#assignCoordinates">assignCoordinates</a></li><li data-type='method'><a href="TreeVizEngine.html#calculateSubtreeWidth">calculateSubtreeWidth</a></li><li data-type='method'><a href="TreeVizEngine.html#clear">clear</a></li><li data-type='method'><a href="TreeVizEngine.html#drawBoardNode">drawBoardNode</a></li><li data-type='method'><a href="TreeVizEngine.html#drawEdges">drawEdges</a></li><li data-type='method'><a href="TreeVizEngine.html#drawGridBoard">drawGridBoard</a></li><li data-type='method'><a href="TreeVizEngine.html#drawKnightBoard">drawKnightBoard</a></li><li data-type='method'><a href="TreeVizEngine.html#drawLabels">drawLabels</a></li><li data-type='method'><a href="TreeVizEngine.html#drawNodes">drawNodes</a></li><li data-type='method'><a href="TreeVizEngine.html#executeBatch">executeBatch</a></li><li data-type='method'><a href="TreeVizEngine.html#executeCommand">executeCommand</a></li><li data-type='method'><a href="TreeVizEngine.html#fitTreeToView">fitTreeToView</a></li><li data-type='method'><a href="TreeVizEngine.html#highlightEdge">highlightEdge</a></li><li data-type='method'><a href="TreeVizEngine.html#highlightNode">highlightNode</a></li><li data-type='method'><a href="TreeVizEngine.html#init">init</a></li><li data-type='method'><a href="TreeVizEngine.html#layoutTree">layoutTree</a></li><li data-type='method'><a href="TreeVizEngine.html#removeHighlight">removeHighlight</a></li><li data-type='method'><a href="TreeVizEngine.html#render">render</a></li><li data-type='method'><a href="TreeVizEngine.html#resetView">resetView</a></li><li data-type='method'><a href="TreeVizEngine.html#setFocus">setFocus</a></li><li data-type='method'><a href="TreeVizEngine.html#setupCanvas">setupCanvas</a></li><li data-type='method'><a href="TreeVizEngine.html#setupInteraction">setupInteraction</a></li><li data-type='method'><a href="TreeVizEngine.html#setupPostMessage">setupPostMessage</a></li><li data-type='method'><a href="TreeVizEngine.html#setupTouchSupport">setupTouchSupport</a></li><li data-type='method'><a href="TreeVizEngine.html#updateNode">updateNode</a></li></ul></li><li><a href="UltimateBoard.html">UltimateBoard</a><ul class='methods'><li data-type='method'><a href="UltimateBoard.html#_checkSmallWin">_checkSmallWin</a></li><li data-type='method'><a href="UltimateBoard.html#_isBoardFull">_isBoardFull</a></li><li data-type='method'><a href="UltimateBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="UltimateBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="UltimateBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="ai_minimax.js.html">ai/minimax.js</a></li></ul><h3>Namespaces</h3><ul><li><a href="viz_legacy_minimax-adapter.js.html">viz/legacy/minimax-adapter.js</a></li></ul><h3>Interfaces</h3><ul><li><a href="GameState.html">GameState</a><ul class='methods'><li data-type='method'><a href="GameState.html#clone">clone</a></li><li data-type='method'><a href="GameState.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="GameState.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="GameState.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="GameState.html#isGoal">isGoal</a></li><li data-type='method'><a href="GameState.html#makeMove">makeMove</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#GameFactories">GameFactories</a></li><li><a href="global.html#TTTGameFactory">TTTGameFactory</a></li><li><a href="global.html#animateRelax">animateRelax</a></li><li><a href="global.html#checkSmallWin">checkSmallWin</a></li><li><a href="global.html#createAgentFromProfile">createAgentFromProfile</a></li><li><a href="global.html#createGame">createGame</a></li><li><a href="global.html#createStrategyTree">createStrategyTree</a></li><li><a href="global.html#drawRotateBoard">drawRotateBoard</a></li><li><a href="global.html#getAvailableGames">getAvailableGames</a></li><li><a href="global.html#getAvailableProfiles">getAvailableProfiles</a></li><li><a href="global.html#getProfilesByType">getProfilesByType</a></li><li><a href="global.html#solveBFS">solveBFS</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">games/tictactoe/logic.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Zentrale Spiellogik für die Tic-Tac-Toe Varianten.
 * Beinhaltet die Klassen für Regular (3x3), 3D (NxNxN) und Ultimate.
 * Implementiert das GameState Interface.
 */

/**
 * Abstrakte Basisklasse für Tic-Tac-Toe Spiele.
 * @abstract
 */
class TTTBase {
    constructor() {
        /** * Aktueller Spieler. 
         * 1 = Spieler 1 (Blau/Kreis), 2 = Spieler 2 (Rot/Kreuz).
         * @type {number} 
         */
        this.currentPlayer = 1;

        /**
         * Gewinner des Spiels.
         * 0 = Laufend, 1 = Spieler 1, 2 = Spieler 2, 3 = Remis.
         * @type {number}
         */
        this.winner = 0;
    }

    /**
     * Wechselt den aktiven Spieler (1 -> 2 -> 1).
     */
    switchPlayer() {
        this.currentPlayer = (this.currentPlayer === 1) ? 2 : 1;
    }
}

/**
 * Klassisches 3x3 Tic-Tac-Toe Board.
 * @extends TTTBase
 */
class TTTRegularBoard extends TTTBase {
    constructor() {
        super();
        /** * Das 3x3 Gitter als flaches Array (Indizes 0-8).
         * 0 = Leer, 1 = Spieler 1, 2 = Spieler 2.
         * @type {number[]} 
         */
        this.grid = Array(9).fill(0);
    }

    /**
     * Liefert alle Indizes von leeren Feldern.
     * Liste der möglichen Züge.
     * ✅ WICHTIG: Prüft NICHT auf winner, weil Simulationen kaputte Klone haben können!
     * @returns {number[]} 
     */
    getAllValidMoves() {
        // ✅ Gib alle leeren Felder zurück, unabhängig vom winner Status
        return this.grid.map((val, idx) => val === 0 ? idx : -1).filter(idx => idx !== -1);
    }

    /**
     * Führt einen Zug an der Position index aus.
     * - Index des Feldes (0-8).
     * @param {number} index 
     * True, wenn der Zug gültig war.
     * @returns {boolean} 
     */
    makeMove(index) {
        // Validierung: Index im Bereich, Feld leer, Spiel läuft
        if (index &lt; 0 || index >= 9 || this.grid[index] !== 0 || this.winner !== 0) {
            return false;
        }

        // Setzen
        this.grid[index] = this.currentPlayer;

        // Status prüfen
        this.checkWin();

        // Spielerwechsel (nur wenn Spiel nicht vorbei)
        if (this.winner === 0) {
            this.switchPlayer();
        }
        return true;
    }

    /**
     * Überprüft alle 8 Gewinnlinien auf 3 Gleiche.
     * Setzt this.winner entsprechend.
     */
    checkWin() {
        const lines = [
            [0,1,2], [3,4,5], [6,7,8], // Horizontal
            [0,3,6], [1,4,7], [2,5,8], // Vertikal
            [0,4,8], [2,4,6]           // Diagonal
        ];

        for (const line of lines) {
            const [a, b, c] = line;
            if (this.grid[a] !== 0 &amp;&amp; 
                this.grid[a] === this.grid[b] &amp;&amp; 
                this.grid[b] === this.grid[c]) {
                this.winner = this.grid[a];
                return;
            }
        }

        // Remis Check (Brett voll, kein Gewinner)
        if (!this.grid.includes(0)) {
            this.winner = 3;
        }
    }

    /**
     * Erstellt eine tiefe Kopie des Boards (für KI-Simulationen).
     * @returns {TTTRegularBoard}
     */
    clone() {
        const copy = new TTTRegularBoard();
        copy.grid = [...this.grid];
        copy.currentPlayer = this.currentPlayer;
        copy.winner = this.winner;
        return copy;
    }

    /**
     * Generiert einen eindeutigen String für diesen Zustand.
     *  Hash Key.
     * @returns {string}
     */
    getStateKey() {
        return this.grid.join('') + this.currentPlayer;
    }
}

/**
 * 3D Tic-Tac-Toe Board (Würfel).
 * Unterstützt variable Größen (z.B. 3x3x3 oder 4x4x4).
 * @extends TTTBase
 */
class TTT3DBoard extends TTTBase {
    /**
     * @param {number} [size=3] - Kantenlänge des Würfels.
     */
    constructor(size = 3) {
        super();
        this.size = size;
        this.totalCells = size * size * size;
        /** * Das 3D Gitter als flaches Array.
         * Index = z * size^2 + y * size + x
         * @type {number[]} 
         */
        this.grid = Array(this.totalCells).fill(0);
    }

    /**
     * Liefert alle leeren Felder im Würfel.
     * ✅ WICHTIG: Prüft NICHT auf winner!
     * @returns {number[]}
     */
    getAllValidMoves() {
        const moves = [];
        for (let i = 0; i &lt; this.totalCells; i++) {
            if (this.grid[i] === 0) moves.push(i);
        }
        return moves;
    }

    /**
     * Setzt einen Stein an index.
     * - Berechneter Index im flachen Array.
     * @param {number} index 
     * @returns {boolean}
     */
    makeMove(index) {
        if (index &lt; 0 || index >= this.totalCells || this.grid[index] !== 0 || this.winner !== 0) {
            return false;
        }

        this.grid[index] = this.currentPlayer;
        this.checkWin();

        if (this.winner === 0) {
            this.switchPlayer();
        }
        return true;
    }

    /**
     * Prüft alle möglichen Gewinnlinien im 3D Raum.
     * Es gibt 13 Richtungsvektoren (Achsen, Flächendiagonalen, Raumdiagonalen).
     */
    checkWin() {
        // Richtungsvektoren (dx, dy, dz)
        const directions = [
            [1,0,0], [0,1,0], [0,0,1],       // 3 Achsen
            [1,1,0], [1,-1,0], [1,0,1], [1,0,-1], [0,1,1], [0,1,-1], // 6 Flächendiagonalen
            [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1] // 4 Raumdiagonalen
        ];

        // Wir iterieren durch jede Zelle als potentiellen Startpunkt
        for (let z = 0; z &lt; this.size; z++) {
            for (let y = 0; y &lt; this.size; y++) {
                for (let x = 0; x &lt; this.size; x++) {
                    const idx = this._getIndex(x, y, z);
                    const player = this.grid[idx];

                    if (player === 0) continue;

                    // Von hier aus in alle Richtungen prüfen
                    for (const dir of directions) {
                        if (this._checkLine(x, y, z, dir[0], dir[1], dir[2], player)) {
                            this.winner = player;
                            return;
                        }
                    }
                }
            }
        }

        // Remis
        if (!this.grid.includes(0)) {
            this.winner = 3;
        }
    }

    /**
     * Prüft eine spezifische Linie vom Startpunkt (x,y,z) in Richtung (dx,dy,dz).
     * @private
     */
    _checkLine(x, y, z, dx, dy, dz, player) {
        // 1. Prüfen, ob die Linie überhaupt lang genug sein kann (Bounds Check am Endpunkt)
        const endX = x + dx * (this.size - 1);
        const endY = y + dy * (this.size - 1);
        const endZ = z + dz * (this.size - 1);

        if (endX &lt; 0 || endX >= this.size ||
            endY &lt; 0 || endY >= this.size ||
            endZ &lt; 0 || endZ >= this.size) {
            return false;
        }

        // 2. Linie ablaufen
        for (let i = 1; i &lt; this.size; i++) {
            const nx = x + dx * i;
            const ny = y + dy * i;
            const nz = z + dz * i;
            if (this.grid[this._getIndex(nx, ny, nz)] !== player) {
                return false;
            }
        }
        return true;
    }

    /** * Hilfsmethode: x,y,z zu Array-Index 
     * @private 
     */
    _getIndex(x, y, z) {
        return z * (this.size * this.size) + y * this.size + x;
    }

    clone() {
        const c = new TTT3DBoard(this.size);
        c.grid = [...this.grid];
        c.currentPlayer = this.currentPlayer;
        c.winner = this.winner;
        return c;
    }
    
    getStateKey() { return this.grid.join('') + this.currentPlayer; }
}

/**
 * Ultimate Tic-Tac-Toe.
 * 9 kleine Boards (3x3) in einem großen Board.
 * @extends TTTBase
 */
class UltimateBoard extends TTTBase {
    constructor() {
        super();
        /** 
         * 9 Arrays à 9 Felder.
         * @type {number[][]} 
         */
        this.boards = Array(9).fill(null).map(() => Array(9).fill(0));
        
        /** 
         * Status der 9 großen Felder (Makro-Board). 0=Offen, 1/2=Sieg, 3=Remis. 
         * @type {number[]} 
         * */
        this.macroBoard = Array(9).fill(0);
        
        /** 
         * Index des Boards, in das der nächste Spieler setzen MUSS. -1 = Freie Wahl. 
         * @type {number} 
         * */
        this.nextBoardIdx = -1;
    }

    /**
     * Liefert alle gültigen Züge als Objekte {big, small}.
     * ✅ WICHTIG: Prüft NICHT auf winner!
     * @returns {Array&lt;{big:number, small:number}>}
     */
    getAllValidMoves() {
        const moves = [];
        
        let targetBoards = [];
        
        // Regel: Wenn man in ein Board geschickt wird und es noch nicht VOLL ist, MUSS man dort spielen.
        // Ein gewonnenes Board mit freien Feldern ist weiterhin spielbar!
        if (this.nextBoardIdx !== -1 &amp;&amp; !this._isBoardFull(this.nextBoardIdx)) {
            targetBoards = [this.nextBoardIdx];
        } else {
            // Sonst: Freie Wahl auf allen nicht vollen Boards
            for (let i = 0; i &lt; 9; i++) {
                if (!this._isBoardFull(i)) {
                    targetBoards.push(i);
                }
            }
        }

        // Alle freien Felder in den Ziel-Boards sammeln
        for (const bIdx of targetBoards) {
            for (let sIdx = 0; sIdx &lt; 9; sIdx++) {
                if (this.boards[bIdx][sIdx] === 0) {
                    moves.push({ big: bIdx, small: sIdx });
                }
            }
        }
        return moves;
    }

    /**
     * Führt einen Zug aus.
     * Akzeptiert flexibel:
     * - makeMove({big: 0, small: 4}) - Objekt-Format
     * - makeMove(0, 4) - zwei Parameter
     * 
     * @param {number|object} big - Index des großen Boards (0-8) oder Move-Objekt
     * @param {number} [small] - Index des kleinen Feldes (0-8), optional wenn big ein Objekt ist
     * @returns {boolean} True bei Erfolg
     */
    makeMove(big, small) {
        // Flexibles Format: akzeptiere {big, small} Objekt oder zwei Parameter
        if (typeof big === 'object' &amp;&amp; big !== null) {
            small = big.small;
            big = big.big;
        }
        
        // 1. Basis-Checks
        if (this.winner !== 0) return false;
        
        // 2. Regel-Check: Darf ich in dieses 'big' Board setzen?
        // Wenn nextBoardIdx aktiv (nicht -1) ist und das Zielboard noch nicht VOLL ist,
        // muss 'big' gleich 'nextBoardIdx' sein.
        // (Ein gewonnenes Board mit freien Feldern ist noch spielbar!)
        if (this.nextBoardIdx !== -1 &amp;&amp; !this._isBoardFull(this.nextBoardIdx)) {
            if (big !== this.nextBoardIdx) return false; // Ungültiges Board gewählt!
        }
        
        // 3. Board darf nicht voll sein
        if (this._isBoardFull(big)) return false;

        // 4. Feld belegt?
        if (this.boards[big][small] !== 0) return false;

        // --- ZUG AUSFÜHREN ---
        this.boards[big][small] = this.currentPlayer;

        // 4. Prüfen, ob das kleine Board gewonnen wurde
        // (Nur wenn es noch nicht entschieden war)
        if (this.macroBoard[big] === 0) {
            const w = this._checkSmallWin(this.boards[big]);
            if (w !== 0) {
                this.macroBoard[big] = w; // Board gewonnen
            } else if (!this.boards[big].includes(0)) {
                this.macroBoard[big] = 3; // Board voll (Remis)
            }
        }

        // 5. Prüfen, ob das große Board (Spiel) gewonnen wurde
        const gameWin = this._checkSmallWin(this.macroBoard);
        if (gameWin !== 0) {
            this.winner = gameWin;
        } else if (!this.macroBoard.includes(0)) {
            // Alle großen Felder entschieden, aber keine Reihe -> Remis
            this.winner = 3; 
        }

        if (this.winner === 0) {
            this.switchPlayer();
        }

        // 6. Nächstes Board bestimmen
        // Der Spieler wird in das Board geschickt, das dem 'small' Index entspricht.
        this.nextBoardIdx = small;
        
        // Wenn das Zielboard aber schon VOLL ist, hat der nächste Spieler freie Wahl.
        // Ein gewonnenes Board mit freien Feldern ist weiterhin spielbar!
        if (this._isBoardFull(this.nextBoardIdx)) {
            this.nextBoardIdx = -1;
        }

        return true;
    }

    /** Prüft, ob ein kleines Board keine freien Felder mehr hat. */
    _isBoardFull(idx) {
        // Keine Nullen im Grid = Voll
        return !this.boards[idx].includes(0);
    }

    /** Hilfsfunktion: 3-in-einer-Reihe auf einem 9er Array. */
    _checkSmallWin(grid) {
        const wins = [[0,1,2],[3,4,5],[6,7,8], [0,3,6],[1,4,7],[2,5,8], [0,4,8],[2,4,6]];
        for (const w of wins) {
            // Ignoriere 0 (leer) und 3 (Remis-Marker) bei der Gewinnprüfung
            if (grid[w[0]] !== 0 &amp;&amp; grid[w[0]] !== 3 &amp;&amp;
                grid[w[0]] === grid[w[1]] &amp;&amp; 
                grid[w[1]] === grid[w[2]]) {
                return grid[w[0]];
            }
        }
        return 0;
    }

    clone() {
        const c = new UltimateBoard();
        // Arrays kopieren
        c.boards = this.boards.map(r => [...r]);
        c.macroBoard = [...this.macroBoard];
        c.currentPlayer = this.currentPlayer;
        c.nextBoardIdx = this.nextBoardIdx;
        c.winner = this.winner;
        return c;
    }
    
    getStateKey() { 
        return JSON.stringify(this.boards) + this.currentPlayer; 
    }
}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Mon Feb 02 2026 00:39:09 GMT+0100 (Central European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
