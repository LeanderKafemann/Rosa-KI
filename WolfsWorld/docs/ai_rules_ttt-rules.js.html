<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>ai/rules/ttt-rules.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Agent.html">Agent</a><ul class='methods'><li data-type='method'><a href="Agent.html#getAction">getAction</a></li></ul></li><li><a href="AlgorithmRunner.html">AlgorithmRunner</a><ul class='methods'><li data-type='method'><a href="AlgorithmRunner.html#setSpeed">setSpeed</a></li><li data-type='method'><a href="AlgorithmRunner.html#start">start</a></li><li data-type='method'><a href="AlgorithmRunner.html#stop">stop</a></li><li data-type='method'><a href="AlgorithmRunner.html#triggerStep">triggerStep</a></li></ul></li><li></li><li><a href="AlphaBetaTreeAdapter.html">AlphaBetaTreeAdapter</a><ul class='methods'><li data-type='method'><a href="AlphaBetaTreeAdapter.html#checkNodeStatus">checkNodeStatus</a></li><li data-type='method'><a href="AlphaBetaTreeAdapter.html#checkParentPruning">checkParentPruning</a></li><li data-type='method'><a href="AlphaBetaTreeAdapter.html#evaluateNode">evaluateNode</a></li><li data-type='method'><a href="AlphaBetaTreeAdapter.html#expandNodeChildren">expandNodeChildren</a></li></ul></li><li><a href="AtomicRule.html">AtomicRule</a></li><li><a href="BFSTreeAdapter.html">BFSTreeAdapter</a><ul class='methods'><li data-type='method'><a href="BFSTreeAdapter.html#buildToDepth">buildToDepth</a></li><li data-type='method'><a href="BFSTreeAdapter.html#focusNode">focusNode</a></li><li data-type='method'><a href="BFSTreeAdapter.html#getNodeCount">getNodeCount</a></li><li data-type='method'><a href="BFSTreeAdapter.html#getStats">getStats</a></li><li data-type='method'><a href="BFSTreeAdapter.html#highlightPath">highlightPath</a></li><li data-type='method'><a href="BFSTreeAdapter.html#resetView">resetView</a></li><li data-type='method'><a href="BFSTreeAdapter.html#startHandshake">startHandshake</a></li></ul></li><li><a href="BaseGameController.html">BaseGameController</a><ul class='methods'><li data-type='method'><a href="BaseGameController.html#checkTurn">checkTurn</a></li><li data-type='method'><a href="BaseGameController.html#coordsToMove">coordsToMove</a></li><li data-type='method'><a href="BaseGameController.html#createAIAgent">createAIAgent</a></li><li data-type='method'><a href="BaseGameController.html#createGame">createGame</a></li><li data-type='method'><a href="BaseGameController.html#drawGame">drawGame</a></li><li data-type='method'><a href="BaseGameController.html#getAISpeed">getAISpeed</a></li><li data-type='method'><a href="BaseGameController.html#handleCanvasClick">handleCanvasClick</a></li><li data-type='method'><a href="BaseGameController.html#init">init</a></li><li data-type='method'><a href="BaseGameController.html#reset">reset</a></li><li data-type='method'><a href="BaseGameController.html#updateUI">updateUI</a></li></ul></li><li><a href="BaseVisualizer.html">BaseVisualizer</a><ul class='methods'><li data-type='method'><a href="BaseVisualizer.html#canvasToWorld">canvasToWorld</a></li><li data-type='method'><a href="BaseVisualizer.html#drawOverlay">drawOverlay</a></li><li data-type='method'><a href="BaseVisualizer.html#executeCommand">executeCommand</a></li><li data-type='method'><a href="BaseVisualizer.html#render">render</a></li><li data-type='method'><a href="BaseVisualizer.html#resetView">resetView</a></li><li data-type='method'><a href="BaseVisualizer.html#sendToParent">sendToParent</a></li><li data-type='method'><a href="BaseVisualizer.html#worldToCanvas">worldToCanvas</a></li></ul></li><li><a href="Benchmark.html">Benchmark</a><ul class='methods'><li data-type='method'><a href="Benchmark.html#getAverage">getAverage</a></li><li data-type='method'><a href="Benchmark.html#getDuration">getDuration</a></li><li data-type='method'><a href="Benchmark.html#record">record</a></li><li data-type='method'><a href="Benchmark.html#reset">reset</a></li><li data-type='method'><a href="Benchmark.html#start">start</a></li><li data-type='method'><a href="Benchmark.html#stop">stop</a></li></ul></li><li><a href="ConditionNode.html">ConditionNode</a></li><li><a href="Connect43D.html">Connect43D</a></li><li><a href="Connect4Regular.html">Connect4Regular</a><ul class='methods'><li data-type='method'><a href="Connect4Regular.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="Connect4Regular.html#makeMove">makeMove</a></li></ul></li><li><a href="DFSTreeAdapter.html">DFSTreeAdapter</a><ul class='methods'><li data-type='method'><a href="DFSTreeAdapter.html#buildToDepth">buildToDepth</a></li><li data-type='method'><a href="DFSTreeAdapter.html#focusNode">focusNode</a></li><li data-type='method'><a href="DFSTreeAdapter.html#getNodeCount">getNodeCount</a></li><li data-type='method'><a href="DFSTreeAdapter.html#getStats">getStats</a></li><li data-type='method'><a href="DFSTreeAdapter.html#highlightPath">highlightPath</a></li><li data-type='method'><a href="DFSTreeAdapter.html#navigateInGame">navigateInGame</a></li><li data-type='method'><a href="DFSTreeAdapter.html#resetView">resetView</a></li><li data-type='method'><a href="DFSTreeAdapter.html#startHandshake">startHandshake</a></li><li data-type='method'><a href="DFSTreeAdapter.html#visualizeSearch">visualizeSearch</a></li></ul></li><li><a href="DecisionTree.html">DecisionTree</a></li><li><a href="FlowchartVisualizer.html">FlowchartVisualizer</a></li><li><a href="GameAdapter.html">GameAdapter</a><ul class='methods'><li data-type='method'><a href="GameAdapter.html#clone">clone</a></li><li data-type='method'><a href="GameAdapter.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="GameAdapter.html#getBoard">getBoard</a></li><li data-type='method'><a href="GameAdapter.html#getCurrentPlayer">getCurrentPlayer</a></li><li data-type='method'><a href="GameAdapter.html#getRemainingMoves">getRemainingMoves</a></li><li data-type='method'><a href="GameAdapter.html#getState">getState</a></li><li data-type='method'><a href="GameAdapter.html#getValidMoves">getValidMoves</a></li><li data-type='method'><a href="GameAdapter.html#getWinner">getWinner</a></li><li data-type='method'><a href="GameAdapter.html#isGameOver">isGameOver</a></li><li data-type='method'><a href="GameAdapter.html#makeMove">makeMove</a></li></ul></li><li><a href="KnightBoard.html">KnightBoard</a><ul class='methods'><li data-type='method'><a href="KnightBoard.html#_getMovesFrom">_getMovesFrom</a></li><li data-type='method'><a href="KnightBoard.html#clone">clone</a></li><li data-type='method'><a href="KnightBoard.html#getDegree">getDegree</a></li><li data-type='method'><a href="KnightBoard.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="KnightBoard.html#getPossibleMoves">getPossibleMoves</a></li><li data-type='method'><a href="KnightBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="KnightBoard.html#initGrid">initGrid</a></li><li data-type='method'><a href="KnightBoard.html#isGoal">isGoal</a></li><li data-type='method'><a href="KnightBoard.html#isInside">isInside</a></li><li data-type='method'><a href="KnightBoard.html#isUndoMove">isUndoMove</a></li><li data-type='method'><a href="KnightBoard.html#isValidMove">isValidMove</a></li><li data-type='method'><a href="KnightBoard.html#move">move</a></li><li data-type='method'><a href="KnightBoard.html#undo">undo</a></li></ul></li><li><a href="LearningPath.html">LearningPath</a><ul class='methods'><li data-type='method'><a href="LearningPath.html#enableNextButton">enableNextButton</a></li></ul></li><li><a href="MinimaxAgent.html">MinimaxAgent</a><ul class='methods'><li data-type='method'><a href="MinimaxAgent.html#getAction">getAction</a></li></ul></li><li></li><li><a href="MinimaxEngine.html">MinimaxEngine</a><ul class='methods'><li data-type='method'><a href="MinimaxEngine.html#findBestMove">findBestMove</a></li></ul></li><li><a href="MinimaxTreeAdapter.html">MinimaxTreeAdapter</a><ul class='methods'><li data-type='method'><a href="MinimaxTreeAdapter.html#checkNodeStatus">checkNodeStatus</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#createNode">createNode</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#evaluateNode">evaluateNode</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#expandNodeChildren">expandNodeChildren</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#visualizeSearch">visualizeSearch</a></li></ul></li><li></li><li><a href="NIMGameLogic.html">NIMGameLogic</a><ul class='methods'><li data-type='method'><a href="NIMGameLogic.html#_checkGameEnd">_checkGameEnd</a></li><li data-type='method'><a href="NIMGameLogic.html#clone">clone</a></li><li data-type='method'><a href="NIMGameLogic.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="NIMGameLogic.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="NIMGameLogic.html#makeMove">makeMove</a></li><li data-type='method'><a href="NIMGameLogic.html#toString">toString</a></li></ul></li><li><a href="RandomAgent.html">RandomAgent</a><ul class='methods'><li data-type='method'><a href="RandomAgent.html#getAction">getAction</a></li></ul></li><li><a href="RotateBoard.html">RotateBoard</a><ul class='methods'><li data-type='method'><a href="RotateBoard.html#canFall">canFall</a></li><li data-type='method'><a href="RotateBoard.html#clone">clone</a></li><li data-type='method'><a href="RotateBoard.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="RotateBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="RotateBoard.html#initFromId">initFromId</a></li><li data-type='method'><a href="RotateBoard.html#isGoal">isGoal</a></li><li data-type='method'><a href="RotateBoard.html#moveDown">moveDown</a></li><li data-type='method'><a href="RotateBoard.html#relaxBoardSync">relaxBoardSync</a></li><li data-type='method'><a href="RotateBoard.html#rotate">rotate</a></li></ul></li><li><a href="RuleBasedAgent.html">RuleBasedAgent</a><ul class='methods'><li data-type='method'><a href="RuleBasedAgent.html#getAction">getAction</a></li></ul></li><li></li><li><a href="RuleGroup.html">RuleGroup</a></li><li><a href="RuleNode.html">RuleNode</a><ul class='methods'><li data-type='method'><a href="RuleNode.html#evaluate">evaluate</a></li></ul></li><li><a href="RuleVisualizer.html">RuleVisualizer</a></li><li><a href="SearchEngine.html">SearchEngine</a><ul class='methods'><li data-type='method'><a href="SearchEngine.html#solve">solve</a></li></ul></li><li></li><li><a href="TTT3DBoard.html">TTT3DBoard</a><ul class='methods'><li data-type='method'><a href="TTT3DBoard.html#checkWin">checkWin</a></li><li data-type='method'><a href="TTT3DBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTT3DBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTT3DBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TTTBase.html">TTTBase</a><ul class='methods'><li data-type='method'><a href="TTTBase.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TTTGameAdapter.html">TTTGameAdapter</a><ul class='methods'><li data-type='method'><a href="TTTGameAdapter.html#clone">clone</a></li><li data-type='method'><a href="TTTGameAdapter.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTTGameAdapter.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTTGameAdapter.html#toJSON">toJSON</a></li></ul></li><li><a href="TTTRegularBoard.html">TTTRegularBoard</a><ul class='methods'><li data-type='method'><a href="TTTRegularBoard.html#checkWin">checkWin</a></li><li data-type='method'><a href="TTTRegularBoard.html#clone">clone</a></li><li data-type='method'><a href="TTTRegularBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTTRegularBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="TTTRegularBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTTRegularBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TemplateGameLogic.html">TemplateGameLogic</a><ul class='methods'><li data-type='method'><a href="TemplateGameLogic.html#_checkGameEnd">_checkGameEnd</a></li><li data-type='method'><a href="TemplateGameLogic.html#_isMoveInList">_isMoveInList</a></li><li data-type='method'><a href="TemplateGameLogic.html#clone">clone</a></li><li data-type='method'><a href="TemplateGameLogic.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TemplateGameLogic.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="TemplateGameLogic.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="TemplateGameLogic.html#isGoal">isGoal</a></li><li data-type='method'><a href="TemplateGameLogic.html#makeMove">makeMove</a></li></ul></li><li><a href="UltimateBoard.html">UltimateBoard</a><ul class='methods'><li data-type='method'><a href="UltimateBoard.html#_checkSmallWin">_checkSmallWin</a></li><li data-type='method'><a href="UltimateBoard.html#_isBoardFull">_isBoardFull</a></li><li data-type='method'><a href="UltimateBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="UltimateBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="UltimateBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="ai_minimax.js.html">ai/minimax.js</a></li></ul><h3>Namespaces</h3><ul><li><a href="MinimaxNodeRenderer.html">MinimaxNodeRenderer</a><ul class='methods'><li data-type='method'><a href="MinimaxNodeRenderer.html#.drawMetadata">drawMetadata</a></li><li data-type='method'><a href="MinimaxNodeRenderer.html#.render">render</a></li></ul></li></ul><h3>Interfaces</h3><ul><li><a href="GameState.html">GameState</a><ul class='methods'><li data-type='method'><a href="GameState.html#clone">clone</a></li><li data-type='method'><a href="GameState.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="GameState.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="GameState.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="GameState.html#isGoal">isGoal</a></li><li data-type='method'><a href="GameState.html#makeMove">makeMove</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#DEFAULT_STATUS_CONFIG">DEFAULT_STATUS_CONFIG</a></li><li><a href="global.html#GameFactories">GameFactories</a></li><li><a href="global.html#KnightsTourNodeRenderer">KnightsTourNodeRenderer</a></li><li><a href="global.html#NodeStatusManager">NodeStatusManager</a></li><li><a href="global.html#RotateBoxNodeRenderer">RotateBoxNodeRenderer</a></li><li><a href="global.html#StatusConfig">StatusConfig</a></li><li><a href="global.html#TTTGameFactory">TTTGameFactory</a></li><li><a href="global.html#TreeInteractionEngine">TreeInteractionEngine</a></li><li><a href="global.html#TreeLayoutEngine">TreeLayoutEngine</a></li><li><a href="global.html#VisualizationUtils">VisualizationUtils</a></li><li><a href="global.html#_convertStyleToRenderFormat">_convertStyleToRenderFormat</a></li><li><a href="global.html#animateRelax">animateRelax</a></li><li><a href="global.html#checkAndMarkDeadEnd">checkAndMarkDeadEnd</a></li><li><a href="global.html#checkSmallWin">checkSmallWin</a></li><li><a href="global.html#createAgentFromProfile">createAgentFromProfile</a></li><li><a href="global.html#createGame">createGame</a></li><li><a href="global.html#createStrategyTree">createStrategyTree</a></li><li><a href="global.html#drawRotateBoard">drawRotateBoard</a></li><li><a href="global.html#evaluateDefault">evaluateDefault</a></li><li><a href="global.html#evaluateTicTacToe">evaluateTicTacToe</a></li><li><a href="global.html#findLowestCommonAncestor">findLowestCommonAncestor</a></li><li><a href="global.html#findPathToRoot">findPathToRoot</a></li><li><a href="global.html#getAvailableGames">getAvailableGames</a></li><li><a href="global.html#getAvailableProfiles">getAvailableProfiles</a></li><li><a href="global.html#getNodeStyle">getNodeStyle</a></li><li><a href="global.html#getProfilesByType">getProfilesByType</a></li><li><a href="global.html#reconstructTreePath">reconstructTreePath</a></li><li><a href="global.html#setActiveNode">setActiveNode</a></li><li><a href="global.html#solveBFS">solveBFS</a></li><li><a href="global.html#updateActiveNodePosition">updateActiveNodePosition</a></li><li><a href="global.html#updateNodeStatus">updateNodeStatus</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">ai/rules/ttt-rules.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Bibliothek von KI-Regeln fÃ¼r Tic-Tac-Toe.
 * EnthÃ¤lt komplexe Logik fÃ¼r 3D und Ultimate sowie Strategie-Templates.
 */

const TTTRulesLibrary = {
    // --- UTILS (Hilfsfunktionen fÃ¼r die Regeln) ---
    utils: {
        /** Simuliert einen Zug und prÃ¼ft auf Sieg */
        canWin: (game, move, player) => {
            // Simuliere den Zug fÃ¼r den aktuellen Spieler im sim-Board
            const sim = game.clone();
            // Setze nur, wenn der Spieler auch dran ist, sonst Ã¼berspringe
            if (sim.currentPlayer !== player) {
                // Wir mÃ¼ssen den Spieler auf den gewÃ¼nschten setzen
                sim.currentPlayer = player;
            }
            sim.makeMove(move);
            // ACHTUNG: Nach makeMove ist currentPlayer gewechselt, winner ist aber korrekt
            return sim.winner === player;
        },
        
        /** ZÃ¤hlt Steine in einer 3D-Linie (Heuristik) */
        countLine: (game, lineIndices, player) => {
            let count = 0;
            let empty = 0;
            for(let idx of lineIndices) {
                if (game.grid[idx] === player) count++;
                else if (game.grid[idx] === 0) empty++;
                else return -1; // Blockiert durch Gegner
            }
            return { count, empty };
        },

        /** Generiert alle Linien-Indizes fÃ¼r 3D (Teuer, sollte gecacht werden) */
        getLines3D: (size) => {
            // (Vereinfacht: Wir berechnen das on-the-fly in den Regeln oder hardcoden fÃ¼r 3x3)
            // FÃ¼r echte Performance mÃ¼sste das im Board gecacht sein.
            return []; // Placeholder, Logik wird in AtomicRule implementiert
        }
    },

    // --- BASIS REGELN ---
    basics: {
        win: new AtomicRule("Siegzug", "Gewinne sofort", (game) => {
            for(let m of game.getAllValidMoves()) {
                if(TTTRulesLibrary.utils.canWin(game, m, game.currentPlayer)) return m;
            }
            return null;
        }),
        block: new AtomicRule("Blocken", "Verhindere Niederlage", (game) => {
            const opponent = (game.currentPlayer === 1) ? 2 : 1;
            for(let m of game.getAllValidMoves()) {
                if(TTTRulesLibrary.utils.canWin(game, m, opponent)) return m;
            }
            return null;
        }),
        random: new AtomicRule("Zufall", "Fallback", (game) => {
            const moves = game.getAllValidMoves();
            return moves.length > 0 ? moves[Math.floor(Math.random()*moves.length)] : null;
        })
    },

    regular: {
        // 1. ZwickmÃ¼hle (Fork) suchen
        fork: new AtomicRule("Gabelung", "Erzeuge zwei Gewinnwege.", (game) => {
            // Suche Zug, der zwei Gewinnlinien Ã¶ffnet
            const moves = game.getAllValidMoves();
            for (let m of moves) {
                const sim = game.clone();
                sim.makeMove(m); // Wir haben gesetzt
                // ZÃ¤hle GewinnmÃ¶glichkeiten im NÃ„CHSTEN Zug
                let wins = 0;
                const nextMoves = sim.getAllValidMoves(); // Jetzt ist Gegner dran, aber wir prÃ¼fen UNSERE Wins
                // Achtung: Nach makeMove ist currentPlayer gewechselt!
                // Wir wollen wissen: Wenn ICH (der ursprÃ¼ngliche Spieler) wieder dran wÃ¤re...
                // Trick: Wir prÃ¼fen, ob wir im Ã¼bernÃ¤chsten Zug gewinnen kÃ¶nnen an >= 2 Stellen
                // Das ist komplex. Einfachere Heuristik:
                // "Fork" bedeutet, ich habe 2 Linien mit je 2 Steinen und leerem 3. Feld.
                // ... (Hier implementieren wir eine vereinfachte ZÃ¤hlung)
                // Um Code kurz zu halten: Wir nutzen TTTRulesLibrary.utils.findFork (Dummy oben)
                // Hier eine echte Implementierung fÃ¼r 3x3:
                
                // Simuliere Board NACH meinem Zug
                const myPlayer = game.currentPlayer;
                // Wir mÃ¼ssen manuell zÃ¤hlen, da makeMove Player switcht
                const grid = [...game.grid];
                grid[m] = myPlayer;
                
                // ZÃ¤hle Linien mit 2 eigenen und 1 leerem
                const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
                let threats = 0;
                for(let l of lines) {
                    const cells = [grid[l[0]], grid[l[1]], grid[l[2]]];
                    const myCount = cells.filter(c => c === myPlayer).length;
                    const emptyCount = cells.filter(c => c === 0).length;
                    if(myCount === 2 &amp;&amp; emptyCount === 1) threats++;
                }
                
                if(threats >= 2) return m;
            }
            return null;
        }),

        blockFork: new AtomicRule("Gabelung Blocken", "Verhindere Fork des Gegners.", (game) => {
            // Strategie: Setze dort, wo der Gegner eine Gabelung machen wÃ¼rde.
            // ODER: Zwinge ihn zu einer Antwort, die keine Gabelung erlaubt.
            // Einfach: PrÃ¼fe, ob Gegner Gabelung hat
            const opp = game.currentPlayer === 1 ? 2 : 1;
            // Nutze Logik von oben fÃ¼r Gegner
            // ... (Analog fork, nur mit opp)
            return null; // (Placeholder, da Implementierung lang wird)
        }),

        center: new AtomicRule("Zentrum", "Mitte", g => {
            // âœ… PrÃ¼fe ob Zentrum frei UND in validMoves ist!
            if (g.grid[4] === 0) {
                const validMoves = g.getAllValidMoves();
                return validMoves.includes(4) ? 4 : null;
            }
            return null;
        }),
        corner: new AtomicRule("Ecke", "Ecke", g => {
            // âœ… WICHTIG: Nur aus gÃ¼ltigen ZÃ¼gen wÃ¤hlen!
            const corners = [0,2,6,8];
            const validCorners = corners.filter(x => g.grid[x]===0 &amp;&amp; g.getAllValidMoves().includes(x));
            return validCorners.length > 0 ? validCorners[Math.floor(Math.random()*validCorners.length)] : null;
        })
    },

    // --- 3D SPEZIFISCH ---
    dimension3: {
        // Funktioniert fÃ¼r 3x3x3 und 4x4x4
        centerCore: new AtomicRule("Zentrum", "Besetze den Kern", (game) => {
            const size = game.size;
            const total = size * size * size;
            const validMoves = game.getAllValidMoves();
            
            // Generische Mitte-Berechnung
            if (size % 2 !== 0) { // Ungerade (3, 5...) -> 1 Mitte
                const center = Math.floor(total / 2);
                // âœ… PrÃ¼fe ob Zentrum frei UND in validMoves!
                return (game.grid[center] === 0 &amp;&amp; validMoves.includes(center)) ? center : null;
            } 
            else { // Gerade (4) -> 8 Mitten (WÃ¼rfel im WÃ¼rfel)
                // Einfache Heuristik: Suche freien Platz im inneren Kern
                // Wir scannen von 1 bis size-2 in allen Dimensionen
                for(let z=1; z&lt;size-1; z++) {
                    for(let y=1; y&lt;size-1; y++) {
                        for(let x=1; x&lt;size-1; x++) {
                            const idx = z*size*size + y*size + x;
                            // âœ… PrÃ¼fe BEIDE Bedingungen!
                            if (game.grid[idx] === 0 &amp;&amp; validMoves.includes(idx)) return idx;
                        }
                    }
                }
                return null;
            }
        }),

        // Versuch, Linien aufzubauen (Heuristik)
        createSetup: new AtomicRule("Linie Bauen", "Setze neben eigenen Stein", (game) => {
            // Suche einen Zug, der neben einem eigenen Stein liegt (Nachbarschaft)
            // Das ist eine einfache Approximation fÃ¼r "Linie bauen"
            const myStones = [];
            game.grid.forEach((v, i) => { if(v === game.currentPlayer) myStones.push(i); });
            
            if(myStones.length === 0) return null; // Noch keine Steine

            const validMoves = game.getAllValidMoves();
            // Suche Move, der Nachbar eines eigenen Steins ist
            // (Nachbar: Index-Differenz ist 1, size, size*size etc...)
            // âœ… ZufÃ¤llig aus gÃ¼ltigen ZÃ¼gen wÃ¤hlen!
            return validMoves.length > 0 ? validMoves[Math.floor(Math.random()*validMoves.length)] : null;
        }),

        // NEU: Punkt n) - Bedingte 3D-Strategien
        blockDiagonal: new AtomicRule(
            "Raum-Diagonal Blocken",
            "Gegner hat 2 in 3D-Diagonal",
            (game) => {
                const opp = game.currentPlayer === 1 ? 2 : 1;
                const validMoves = game.getAllValidMoves();
                
                // 3D Raumdiagonalen (durch Kern = Index 13)
                const diagonals = [
                    [0, 13, 26],   // Ecke zu Ecke
                    [2, 13, 24],
                    [6, 13, 20],
                    [8, 13, 18],
                    [18, 13, 8],   // Gespiegelt
                    [20, 13, 6],
                    [24, 13, 2],
                    [26, 13, 0]
                ];
                
                for (let line of diagonals) {
                    let oppCount = 0, emptyIdx = -1;
                    for (let idx of line) {
                        if (game.grid[idx] === opp) oppCount++;
                        if (game.grid[idx] === 0) emptyIdx = idx;
                    }
                    // âœ… PrÃ¼fe AUCH ob der Zug gÃ¼ltig ist!
                    if (oppCount === 2 &amp;&amp; emptyIdx >= 0 &amp;&amp; validMoves.includes(emptyIdx)) {
                        return emptyIdx;
                    }
                }
                return null;
            }
        ),

        coreExpand: new AtomicRule(
            "Kern Expansion",
            "Baue vom Kern aus",
            (game) => {
                const size = game.size;
                const center = Math.floor(size * size * size / 2);
                const me = game.currentPlayer;
                
                // Wenn Kern besetzt ist (von mir), setze Nachbarn
                if (game.grid[center] === me) {
                    // Alle direkten Nachbarn des Kerns (26 bei 3x3x3)
                    const neighbors = [];
                    for (let i = 0; i &lt; game.grid.length; i++) {
                        if (game.grid[i] === 0) {
                            // Manuell: nÃ¤he zum Kern checken
                            const dist = Math.abs(i - center);
                            if (dist &lt;= size + 1) neighbors.push(i);
                        }
                    }
                    const validMoves = game.getAllValidMoves();
                    const expansion = neighbors.filter(n => validMoves.includes(n));
                    // âœ… ZufÃ¤llig aus allen gÃ¼ltigen Expansionen wÃ¤hlen!
                    return expansion.length > 0 ? expansion[Math.floor(Math.random()*expansion.length)] : null;
                }
                return null;
            }
        )
    },

    // --- ULTIMATE SPEZIFISCH ---
    ultimate: {
        // Gewinne das kleine Board
        winLocal: new AtomicRule("Lokal Sieg", "Gewinne Teil-Board", (game) => {
            for (let m of game.getAllValidMoves()) {
                const sim = [...game.boards[m.big]];
                sim[m.small] = game.currentPlayer;
                if (checkSmallWin(sim)) return m;
            }
            return null;
        }),
        // Verhindere, dass Gegner kleines Board gewinnt
        blockLocal: new AtomicRule("Lokal Block", "Rette Teil-Board", (game) => {
            const opp = (game.currentPlayer===1)?2:1;
            for (let m of game.getAllValidMoves()) {
                const sim = [...game.boards[m.big]];
                sim[m.small] = opp;
                if (checkSmallWin(sim)) return m;
            }
            return null;
        }),
        // Schicke Gegner in ein bereits entschiedenes Board
        sendToTrash: new AtomicRule("MÃ¼llabfuhr", "Schicke Gegner ins Aus", (game) => {
            const moves = game.getAllValidMoves();
            // Wir suchen ZÃ¼ge, wo das Zielboard (m.small) bereits entschieden ist (Status != 0)
            // Das gibt dem Gegner zwar freie Wahl, aber er kann auf DIESEM Board nicht mehr punkten.
            // Bessere Strategie wÃ¤re: Schicke ihn in ein Board, das ICH schon habe.
            const candidates = moves.filter(m => game.macroBoard[m.small] !== 0);
            // âœ… ZufÃ¤llig aus allen Kandidaten wÃ¤hlen!
            return candidates.length > 0 ? candidates[Math.floor(Math.random()*candidates.length)] : null;
        }),

        // Punkt o) NEU - Ultimate Strategiephase Bedingungen
        winGlobal: new AtomicRule(
            "Global Sieg",
            "Gewinne ein Board fÃ¼r Sieg-Pfad",
            (game) => {
                // Wenn ich in den letzten 3 Boards fÃ¼hre, versuche den Sieg abzusichern
                const me = game.currentPlayer;
                let myBoardWins = 0;
                for (let b = 0; b &lt; 9; b++) {
                    if (game.macroBoard[b] === me) myBoardWins++;
                }
                // Wenn ich 2+ Boards habe, versuche 3. zu gewinnen
                if (myBoardWins >= 2) {
                    for (let m of game.getAllValidMoves()) {
                        const sim = [...game.boards[m.big]];
                        sim[m.small] = me;
                        if (checkSmallWin(sim)) return m;
                    }
                }
                return null;
            }
        ),

        blockGlobal: new AtomicRule(
            "Global Block",
            "Blockiere Gegner vor Sieg",
            (game) => {
                const opp = game.currentPlayer === 1 ? 2 : 1;
                let oppBoardWins = 0;
                for (let b = 0; b &lt; 9; b++) {
                    if (game.macroBoard[b] === opp) oppBoardWins++;
                }
                // Wenn Gegner 2+ Boards hat, blockiere seinen 3.
                if (oppBoardWins >= 2) {
                    for (let m of game.getAllValidMoves()) {
                        const sim = [...game.boards[m.big]];
                        sim[m.small] = opp;
                        if (checkSmallWin(sim)) return m;
                    }
                }
                return null;
            }
        )
    }
};

/** Hilfsfunktion fÃ¼r lokalen Sieg */
function checkSmallWin(grid) {
    const wins = [[0,1,2],[3,4,5],[6,7,8], [0,3,6],[1,4,7],[2,5,8], [0,4,8],[2,4,6]];
    return wins.some(w => grid[w[0]]!==0 &amp;&amp; grid[w[0]]===grid[w[1]] &amp;&amp; grid[w[1]]===grid[w[2]]);
}

/**
 * Factory Methode: Erstellt den Baum basierend auf Spieltyp.
 * Hier nutzen wir jetzt ConditionNodes fÃ¼r echte Verzweigungen!
 */
function createStrategyTree(type = 'regular') {
    const root = new RuleGroup("Master KI");

    // 1. EXISTENZ: Immer zuerst prÃ¼fen
    const survival = new RuleGroup("Existenz", "Gewinnen oder Blocken");
    survival.add(TTTRulesLibrary.basics.win.clone());
    survival.add(TTTRulesLibrary.basics.block.clone());
    root.add(survival);

    // 2. TAKTIK (AbhÃ¤ngig vom Spiel)
    if (type === 'regular') {
        const tactic = new RuleGroup("Taktik");
        tactic.add(TTTRulesLibrary.regular.fork.clone());      // NEU
        tactic.add(TTTRulesLibrary.regular.blockFork.clone()); // NEU
        tactic.add(TTTRulesLibrary.regular.center.clone());
        tactic.add(TTTRulesLibrary.regular.corner.clone());
        root.add(tactic);
    }else if (type === 'ultimate') {
        // Punkt o) NEU - Ultimate mit echten Bedingungen
        const localTactics = new RuleGroup("Lokale Taktik");
        localTactics.add(TTTRulesLibrary.ultimate.winLocal.clone());
        localTactics.add(TTTRulesLibrary.ultimate.blockLocal.clone());
        
        // Bedingung: Hat der Gegner Chance auf Sieg?
        const strategyPhase = new ConditionNode(
            "Gegner Vorsprung?", 
            "Hat Gegner 2+ Boards gewonnen?",
            (game) => {
                const opp = game.currentPlayer === 1 ? 2 : 1;
                let oppWins = 0;
                for (let b = 0; b &lt; 9; b++) {
                    if (game.macroBoard[b] === opp) oppWins++;
                }
                return oppWins >= 2;
            },
            // THEN: Gegner nah am Sieg â†’ DEFENSIVE
            new RuleGroup("ðŸ›¡ï¸ Defensive Strategie", "", [
                TTTRulesLibrary.ultimate.blockGlobal.clone(),
                TTTRulesLibrary.ultimate.sendToTrash.clone(),
                TTTRulesLibrary.basics.random.clone()
            ]),
            // ELSE: Wir im Vorteil oder gleich â†’ OFFENSIVE
            new RuleGroup("âš”ï¸ Offensive Strategie", "", [
                TTTRulesLibrary.ultimate.winGlobal.clone(),
                TTTRulesLibrary.ultimate.sendToTrash.clone(),
                TTTRulesLibrary.basics.random.clone()
            ])
        );
        
        root.add(localTactics);
        root.add(strategyPhase);

    } else if (type === '3d') {
        // Punkt n) - Bedingte Strategien fÃ¼r 3D
        const coreControl = new ConditionNode(
            "Kern frei?",
            "Ist die Raummitte noch nicht besetzt?",
            (game) => game.grid[Math.floor(game.size * game.size * game.size / 2)] === 0,
            // THEN: Kern frei â†’ nimm ihn
            TTTRulesLibrary.dimension3.centerCore.clone(),
            // ELSE: Kern besetzt â†’ baue Linie aus
            new RuleGroup("Nach-Kern Strategie", "", [
                TTTRulesLibrary.dimension3.coreExpand.clone(),
                TTTRulesLibrary.dimension3.blockDiagonal.clone(),
                TTTRulesLibrary.dimension3.createSetup.clone()
            ])
        );

        const spaceTactics = new RuleGroup("Raum Taktik");
        spaceTactics.add(coreControl);
        root.add(spaceTactics);
    } else {
        // Regular
        root.add(new AtomicRule("Zentrum", "Mitte", g => g.grid[4]===0?4:null));
    }

    // 3. Fallback
    root.add(TTTRulesLibrary.basics.random.clone());

    return new DecisionTree("KI " + type, root);
}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Sat Feb 07 2026 23:25:54 GMT+0100 (Central European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
