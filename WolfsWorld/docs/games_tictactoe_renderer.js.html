<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>games/tictactoe/renderer.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Agent.html">Agent</a><ul class='methods'><li data-type='method'><a href="Agent.html#getAction">getAction</a></li></ul></li><li><a href="AlgorithmRunner.html">AlgorithmRunner</a><ul class='methods'><li data-type='method'><a href="AlgorithmRunner.html#setSpeed">setSpeed</a></li><li data-type='method'><a href="AlgorithmRunner.html#start">start</a></li><li data-type='method'><a href="AlgorithmRunner.html#stop">stop</a></li><li data-type='method'><a href="AlgorithmRunner.html#triggerStep">triggerStep</a></li></ul></li><li></li><li><a href="AlphaBetaTreeAdapter.html">AlphaBetaTreeAdapter</a><ul class='methods'><li data-type='method'><a href="AlphaBetaTreeAdapter.html#checkNodeStatus">checkNodeStatus</a></li><li data-type='method'><a href="AlphaBetaTreeAdapter.html#checkParentPruning">checkParentPruning</a></li><li data-type='method'><a href="AlphaBetaTreeAdapter.html#evaluateNode">evaluateNode</a></li><li data-type='method'><a href="AlphaBetaTreeAdapter.html#expandNodeChildren">expandNodeChildren</a></li></ul></li><li><a href="AtomicRule.html">AtomicRule</a></li><li><a href="BFSTreeAdapter.html">BFSTreeAdapter</a><ul class='methods'><li data-type='method'><a href="BFSTreeAdapter.html#buildToDepth">buildToDepth</a></li><li data-type='method'><a href="BFSTreeAdapter.html#focusNode">focusNode</a></li><li data-type='method'><a href="BFSTreeAdapter.html#getNodeCount">getNodeCount</a></li><li data-type='method'><a href="BFSTreeAdapter.html#getStats">getStats</a></li><li data-type='method'><a href="BFSTreeAdapter.html#highlightPath">highlightPath</a></li><li data-type='method'><a href="BFSTreeAdapter.html#resetView">resetView</a></li><li data-type='method'><a href="BFSTreeAdapter.html#startHandshake">startHandshake</a></li></ul></li><li><a href="BaseGameController.html">BaseGameController</a><ul class='methods'><li data-type='method'><a href="BaseGameController.html#checkTurn">checkTurn</a></li><li data-type='method'><a href="BaseGameController.html#coordsToMove">coordsToMove</a></li><li data-type='method'><a href="BaseGameController.html#createAIAgent">createAIAgent</a></li><li data-type='method'><a href="BaseGameController.html#createGame">createGame</a></li><li data-type='method'><a href="BaseGameController.html#drawGame">drawGame</a></li><li data-type='method'><a href="BaseGameController.html#getAISpeed">getAISpeed</a></li><li data-type='method'><a href="BaseGameController.html#handleCanvasClick">handleCanvasClick</a></li><li data-type='method'><a href="BaseGameController.html#init">init</a></li><li data-type='method'><a href="BaseGameController.html#reset">reset</a></li><li data-type='method'><a href="BaseGameController.html#updateUI">updateUI</a></li></ul></li><li><a href="BaseVisualizer.html">BaseVisualizer</a><ul class='methods'><li data-type='method'><a href="BaseVisualizer.html#canvasToWorld">canvasToWorld</a></li><li data-type='method'><a href="BaseVisualizer.html#drawOverlay">drawOverlay</a></li><li data-type='method'><a href="BaseVisualizer.html#executeCommand">executeCommand</a></li><li data-type='method'><a href="BaseVisualizer.html#render">render</a></li><li data-type='method'><a href="BaseVisualizer.html#resetView">resetView</a></li><li data-type='method'><a href="BaseVisualizer.html#sendToParent">sendToParent</a></li><li data-type='method'><a href="BaseVisualizer.html#worldToCanvas">worldToCanvas</a></li></ul></li><li><a href="Benchmark.html">Benchmark</a><ul class='methods'><li data-type='method'><a href="Benchmark.html#getAverage">getAverage</a></li><li data-type='method'><a href="Benchmark.html#getDuration">getDuration</a></li><li data-type='method'><a href="Benchmark.html#record">record</a></li><li data-type='method'><a href="Benchmark.html#reset">reset</a></li><li data-type='method'><a href="Benchmark.html#start">start</a></li><li data-type='method'><a href="Benchmark.html#stop">stop</a></li></ul></li><li><a href="ConditionNode.html">ConditionNode</a></li><li><a href="Connect43D.html">Connect43D</a></li><li><a href="Connect4Regular.html">Connect4Regular</a><ul class='methods'><li data-type='method'><a href="Connect4Regular.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="Connect4Regular.html#makeMove">makeMove</a></li></ul></li><li><a href="DFSTreeAdapter.html">DFSTreeAdapter</a><ul class='methods'><li data-type='method'><a href="DFSTreeAdapter.html#buildToDepth">buildToDepth</a></li><li data-type='method'><a href="DFSTreeAdapter.html#focusNode">focusNode</a></li><li data-type='method'><a href="DFSTreeAdapter.html#getNodeCount">getNodeCount</a></li><li data-type='method'><a href="DFSTreeAdapter.html#getStats">getStats</a></li><li data-type='method'><a href="DFSTreeAdapter.html#highlightPath">highlightPath</a></li><li data-type='method'><a href="DFSTreeAdapter.html#navigateInGame">navigateInGame</a></li><li data-type='method'><a href="DFSTreeAdapter.html#resetView">resetView</a></li><li data-type='method'><a href="DFSTreeAdapter.html#startHandshake">startHandshake</a></li><li data-type='method'><a href="DFSTreeAdapter.html#visualizeSearch">visualizeSearch</a></li></ul></li><li><a href="DecisionTree.html">DecisionTree</a></li><li><a href="FlowchartVisualizer.html">FlowchartVisualizer</a></li><li><a href="GameAdapter.html">GameAdapter</a><ul class='methods'><li data-type='method'><a href="GameAdapter.html#clone">clone</a></li><li data-type='method'><a href="GameAdapter.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="GameAdapter.html#getBoard">getBoard</a></li><li data-type='method'><a href="GameAdapter.html#getCurrentPlayer">getCurrentPlayer</a></li><li data-type='method'><a href="GameAdapter.html#getRemainingMoves">getRemainingMoves</a></li><li data-type='method'><a href="GameAdapter.html#getState">getState</a></li><li data-type='method'><a href="GameAdapter.html#getValidMoves">getValidMoves</a></li><li data-type='method'><a href="GameAdapter.html#getWinner">getWinner</a></li><li data-type='method'><a href="GameAdapter.html#isGameOver">isGameOver</a></li><li data-type='method'><a href="GameAdapter.html#makeMove">makeMove</a></li></ul></li><li><a href="KnightBoard.html">KnightBoard</a><ul class='methods'><li data-type='method'><a href="KnightBoard.html#_getMovesFrom">_getMovesFrom</a></li><li data-type='method'><a href="KnightBoard.html#clone">clone</a></li><li data-type='method'><a href="KnightBoard.html#getDegree">getDegree</a></li><li data-type='method'><a href="KnightBoard.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="KnightBoard.html#getPossibleMoves">getPossibleMoves</a></li><li data-type='method'><a href="KnightBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="KnightBoard.html#initGrid">initGrid</a></li><li data-type='method'><a href="KnightBoard.html#isGoal">isGoal</a></li><li data-type='method'><a href="KnightBoard.html#isInside">isInside</a></li><li data-type='method'><a href="KnightBoard.html#isUndoMove">isUndoMove</a></li><li data-type='method'><a href="KnightBoard.html#isValidMove">isValidMove</a></li><li data-type='method'><a href="KnightBoard.html#move">move</a></li><li data-type='method'><a href="KnightBoard.html#undo">undo</a></li></ul></li><li><a href="LearningPath.html">LearningPath</a><ul class='methods'><li data-type='method'><a href="LearningPath.html#enableNextButton">enableNextButton</a></li></ul></li><li><a href="MinimaxAgent.html">MinimaxAgent</a><ul class='methods'><li data-type='method'><a href="MinimaxAgent.html#getAction">getAction</a></li></ul></li><li></li><li><a href="MinimaxEngine.html">MinimaxEngine</a><ul class='methods'><li data-type='method'><a href="MinimaxEngine.html#findBestMove">findBestMove</a></li></ul></li><li><a href="MinimaxTreeAdapter.html">MinimaxTreeAdapter</a><ul class='methods'><li data-type='method'><a href="MinimaxTreeAdapter.html#checkNodeStatus">checkNodeStatus</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#createNode">createNode</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#evaluateNode">evaluateNode</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#expandNodeChildren">expandNodeChildren</a></li><li data-type='method'><a href="MinimaxTreeAdapter.html#visualizeSearch">visualizeSearch</a></li></ul></li><li></li><li><a href="NIMGameLogic.html">NIMGameLogic</a><ul class='methods'><li data-type='method'><a href="NIMGameLogic.html#_checkGameEnd">_checkGameEnd</a></li><li data-type='method'><a href="NIMGameLogic.html#clone">clone</a></li><li data-type='method'><a href="NIMGameLogic.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="NIMGameLogic.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="NIMGameLogic.html#makeMove">makeMove</a></li><li data-type='method'><a href="NIMGameLogic.html#toString">toString</a></li></ul></li><li><a href="RandomAgent.html">RandomAgent</a><ul class='methods'><li data-type='method'><a href="RandomAgent.html#getAction">getAction</a></li></ul></li><li><a href="RotateBoard.html">RotateBoard</a><ul class='methods'><li data-type='method'><a href="RotateBoard.html#canFall">canFall</a></li><li data-type='method'><a href="RotateBoard.html#clone">clone</a></li><li data-type='method'><a href="RotateBoard.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="RotateBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="RotateBoard.html#initFromId">initFromId</a></li><li data-type='method'><a href="RotateBoard.html#isGoal">isGoal</a></li><li data-type='method'><a href="RotateBoard.html#moveDown">moveDown</a></li><li data-type='method'><a href="RotateBoard.html#relaxBoardSync">relaxBoardSync</a></li><li data-type='method'><a href="RotateBoard.html#rotate">rotate</a></li></ul></li><li><a href="RuleBasedAgent.html">RuleBasedAgent</a><ul class='methods'><li data-type='method'><a href="RuleBasedAgent.html#getAction">getAction</a></li></ul></li><li></li><li><a href="RuleGroup.html">RuleGroup</a></li><li><a href="RuleNode.html">RuleNode</a><ul class='methods'><li data-type='method'><a href="RuleNode.html#evaluate">evaluate</a></li></ul></li><li><a href="RuleVisualizer.html">RuleVisualizer</a></li><li><a href="SearchEngine.html">SearchEngine</a><ul class='methods'><li data-type='method'><a href="SearchEngine.html#solve">solve</a></li></ul></li><li></li><li><a href="TTT3DBoard.html">TTT3DBoard</a><ul class='methods'><li data-type='method'><a href="TTT3DBoard.html#checkWin">checkWin</a></li><li data-type='method'><a href="TTT3DBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTT3DBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTT3DBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TTTBase.html">TTTBase</a><ul class='methods'><li data-type='method'><a href="TTTBase.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TTTGameAdapter.html">TTTGameAdapter</a><ul class='methods'><li data-type='method'><a href="TTTGameAdapter.html#clone">clone</a></li><li data-type='method'><a href="TTTGameAdapter.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTTGameAdapter.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTTGameAdapter.html#toJSON">toJSON</a></li></ul></li><li><a href="TTTRegularBoard.html">TTTRegularBoard</a><ul class='methods'><li data-type='method'><a href="TTTRegularBoard.html#checkWin">checkWin</a></li><li data-type='method'><a href="TTTRegularBoard.html#clone">clone</a></li><li data-type='method'><a href="TTTRegularBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TTTRegularBoard.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="TTTRegularBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="TTTRegularBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="TemplateGameLogic.html">TemplateGameLogic</a><ul class='methods'><li data-type='method'><a href="TemplateGameLogic.html#_checkGameEnd">_checkGameEnd</a></li><li data-type='method'><a href="TemplateGameLogic.html#_isMoveInList">_isMoveInList</a></li><li data-type='method'><a href="TemplateGameLogic.html#clone">clone</a></li><li data-type='method'><a href="TemplateGameLogic.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="TemplateGameLogic.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="TemplateGameLogic.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="TemplateGameLogic.html#isGoal">isGoal</a></li><li data-type='method'><a href="TemplateGameLogic.html#makeMove">makeMove</a></li></ul></li><li><a href="UltimateBoard.html">UltimateBoard</a><ul class='methods'><li data-type='method'><a href="UltimateBoard.html#_checkSmallWin">_checkSmallWin</a></li><li data-type='method'><a href="UltimateBoard.html#_isBoardFull">_isBoardFull</a></li><li data-type='method'><a href="UltimateBoard.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="UltimateBoard.html#makeMove">makeMove</a></li><li data-type='method'><a href="UltimateBoard.html#switchPlayer">switchPlayer</a></li></ul></li><li><a href="ai_minimax.js.html">ai/minimax.js</a></li></ul><h3>Namespaces</h3><ul><li><a href="MinimaxNodeRenderer.html">MinimaxNodeRenderer</a><ul class='methods'><li data-type='method'><a href="MinimaxNodeRenderer.html#.drawMetadata">drawMetadata</a></li><li data-type='method'><a href="MinimaxNodeRenderer.html#.render">render</a></li></ul></li></ul><h3>Interfaces</h3><ul><li><a href="GameState.html">GameState</a><ul class='methods'><li data-type='method'><a href="GameState.html#clone">clone</a></li><li data-type='method'><a href="GameState.html#getAllValidMoves">getAllValidMoves</a></li><li data-type='method'><a href="GameState.html#getNextStates">getNextStates</a></li><li data-type='method'><a href="GameState.html#getStateKey">getStateKey</a></li><li data-type='method'><a href="GameState.html#isGoal">isGoal</a></li><li data-type='method'><a href="GameState.html#makeMove">makeMove</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#DEFAULT_STATUS_CONFIG">DEFAULT_STATUS_CONFIG</a></li><li><a href="global.html#GameFactories">GameFactories</a></li><li><a href="global.html#KnightsTourNodeRenderer">KnightsTourNodeRenderer</a></li><li><a href="global.html#NodeStatusManager">NodeStatusManager</a></li><li><a href="global.html#RotateBoxNodeRenderer">RotateBoxNodeRenderer</a></li><li><a href="global.html#StatusConfig">StatusConfig</a></li><li><a href="global.html#TTTGameFactory">TTTGameFactory</a></li><li><a href="global.html#TreeInteractionEngine">TreeInteractionEngine</a></li><li><a href="global.html#TreeLayoutEngine">TreeLayoutEngine</a></li><li><a href="global.html#VisualizationUtils">VisualizationUtils</a></li><li><a href="global.html#_convertStyleToRenderFormat">_convertStyleToRenderFormat</a></li><li><a href="global.html#animateRelax">animateRelax</a></li><li><a href="global.html#checkAndMarkDeadEnd">checkAndMarkDeadEnd</a></li><li><a href="global.html#checkSmallWin">checkSmallWin</a></li><li><a href="global.html#createAgentFromProfile">createAgentFromProfile</a></li><li><a href="global.html#createGame">createGame</a></li><li><a href="global.html#createStrategyTree">createStrategyTree</a></li><li><a href="global.html#drawRotateBoard">drawRotateBoard</a></li><li><a href="global.html#evaluateDefault">evaluateDefault</a></li><li><a href="global.html#evaluateTicTacToe">evaluateTicTacToe</a></li><li><a href="global.html#findLowestCommonAncestor">findLowestCommonAncestor</a></li><li><a href="global.html#findPathToRoot">findPathToRoot</a></li><li><a href="global.html#getAvailableGames">getAvailableGames</a></li><li><a href="global.html#getAvailableProfiles">getAvailableProfiles</a></li><li><a href="global.html#getNodeStyle">getNodeStyle</a></li><li><a href="global.html#getProfilesByType">getProfilesByType</a></li><li><a href="global.html#reconstructTreePath">reconstructTreePath</a></li><li><a href="global.html#setActiveNode">setActiveNode</a></li><li><a href="global.html#solveBFS">solveBFS</a></li><li><a href="global.html#updateActiveNodePosition">updateActiveNodePosition</a></li><li><a href="global.html#updateNodeStatus">updateNodeStatus</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">games/tictactoe/renderer.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Renderer-Sammlung für alle Tic-Tac-Toe Varianten.
 * Enthält 2D, Ultimate und 3D Visualisierungen.
 */

const TTTRenderer = {
    
    /**
     * Zeichnet das klassische 3x3 Board.
     * @param {HTMLCanvasElement} canvas 
     * @param {TTTRegularBoard} game 
     */
    drawRegular(canvas, game) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const s = w / 3;

        ctx.clearRect(0, 0, w, h);
        
        // Gitterlinien
        ctx.strokeStyle = "#2c3e50"; 
        ctx.lineWidth = 6; 
        ctx.lineCap = "round";
        
        ctx.beginPath();
        ctx.moveTo(s, 10); ctx.lineTo(s, h-10); 
        ctx.moveTo(s*2, 10); ctx.lineTo(s*2, h-10);
        ctx.moveTo(10, s); ctx.lineTo(w-10, s); 
        ctx.moveTo(10, s*2); ctx.lineTo(w-10, s*2);
        ctx.stroke();

        // Symbole
        for(let i=0; i&lt;9; i++) {
            if(game.grid[i] === 0) continue;
            const cx = (i % 3) * s + s/2;
            const cy = Math.floor(i / 3) * s + s/2;
            this._drawSymbol(ctx, cx, cy, s/3.5, game.grid[i]);
        }
    },

    /**
     * Zeichnet das Ultimate TTT Board.
     * @param {HTMLCanvasElement} canvas 
     * @param {UltimateBoard} game 
     */
    drawUltimate(canvas, game) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const bigS = w / 3;
        const smallS = bigS / 3;

        ctx.clearRect(0, 0, w, h);

        // 1. Highlights: Wo darf gespielt werden?
        if (game.winner === 0) {
            if (game.nextBoardIdx !== -1) {
                // Bestimmtes Board highlighten
                const bx = (game.nextBoardIdx % 3) * bigS;
                const by = Math.floor(game.nextBoardIdx / 3) * bigS;
                ctx.fillStyle = "#eafaed"; // Hellgrün
                ctx.fillRect(bx, by, bigS, bigS);
            } else {
                // Freie Wahl -> Alles leicht grün
                ctx.fillStyle = "#eafaed"; 
                ctx.fillRect(0,0,w,h);
            }
        }

        // 2. Makro-Board Status (Farbige Hintergründe für gewonnene Boards)
        for (let i=0; i&lt;9; i++) {
            const bx = (i%3)*bigS;
            const by = Math.floor(i/3)*bigS;
            
            if (game.macroBoard[i] !== 0) {
                const winner = game.macroBoard[i];
                
                // Hintergrundfarbe transparent
                if (winner === 1) ctx.fillStyle = "rgba(52, 152, 219, 0.15)"; // Blau
                else if (winner === 2) ctx.fillStyle = "rgba(231, 76, 60, 0.15)"; // Rot
                else ctx.fillStyle = "rgba(127, 140, 141, 0.2)"; // Grau/Remis
                
                ctx.fillRect(bx, by, bigS, bigS);
                
                // Großes Symbol darüber zeichnen (sehr transparent)
                ctx.save();
                ctx.globalAlpha = 0.3; 
                this._drawSymbol(ctx, bx+bigS/2, by+bigS/2, bigS/3, winner, 15);
                ctx.restore();
            }
        }

        // 3. Kleines Gitter (Dünn)
        ctx.lineWidth = 1; 
        ctx.strokeStyle = "#bdc3c7";
        ctx.beginPath();
        for (let i=1; i&lt;9; i++) {
            if (i%3===0) continue; 
            ctx.moveTo(i*smallS, 0); ctx.lineTo(i*smallS, h);
            ctx.moveTo(0, i*smallS); ctx.lineTo(w, i*smallS);
        }
        ctx.stroke();

        // 4. Großes Gitter (Dick)
        ctx.lineWidth = 4; 
        ctx.strokeStyle = "#2c3e50";
        ctx.beginPath();
        for (let i=1; i&lt;=2; i++) {
            ctx.moveTo(i*bigS, 0); ctx.lineTo(i*bigS, h);
            ctx.moveTo(0, i*bigS); ctx.lineTo(w, i*bigS);
        }
        ctx.stroke();

        // 5. Kleine Spielsteine
        for (let b=0; b&lt;9; b++) {
            for (let s=0; s&lt;9; s++) {
                if (game.boards[b][s] === 0) continue;
                const bx = (b%3)*bigS; 
                const by = Math.floor(b/3)*bigS;
                const sx = (s%3)*smallS; 
                const sy = Math.floor(s/3)*smallS;
                
                this._drawSymbol(ctx, bx+sx+smallS/2, by+sy+smallS/2, smallS/3, game.boards[b][s], 3);
            }
        }
    },

    /**
     * Zeichnet die 2D-Schnittebenen (Slices) für das 3D-Spiel.
     * @param {HTMLCanvasElement} canvas 
     * @param {TTT3DBoard} game 
     * @param {string} axis - 'x', 'y' oder 'z'.
     */
    draw3DSlices(canvas, game, axis) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const s = game.size; 

        ctx.clearRect(0,0,w,h);
        
        // Layout-Konstanten (Müssen mit Controller-Hit-Detection übereinstimmen!)
        const padding = 20;
        const availW = w - (padding*2);
        const availH = h - (padding*2);
        // Boxgröße so berechnen, dass s Boxen nebeneinander passen
        const boxSize = Math.min(availW / s, availH);
        const gap = boxSize * 0.1;
        const boardSize = boxSize - gap;
        
        const totalW = s * boxSize;
        const startX = (w - totalW) / 2 + gap/2;
        const startY = (h - boardSize) / 2 + 10;

        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";

        const sliceName = (axis === 'z') ? 'Z' : (axis === 'y') ? 'Y' : 'X';
        
        for (let k = 0; k &lt; s; k++) {
            const ox = startX + k * boxSize;
            const oy = startY;

            // Label
            ctx.fillStyle = "#2c3e50"; 
            ctx.font = "bold 14px sans-serif";
            ctx.fillText(`${sliceName}${k+1}`, ox + boardSize/2, oy - 15);

            // Hintergrund
            ctx.fillStyle = "#ecf0f1"; 
            ctx.fillRect(ox, oy, boardSize, boardSize);
            ctx.strokeStyle = "#bdc3c7"; 
            ctx.lineWidth = 2; 
            ctx.strokeRect(ox, oy, boardSize, boardSize);

            // Gitterlinien
            const cellS = boardSize / s;
            ctx.beginPath();
            for(let i=1; i&lt;s; i++) {
                ctx.moveTo(ox + i*cellS, oy); ctx.lineTo(ox + i*cellS, oy + boardSize);
                ctx.moveTo(ox, oy + i*cellS); ctx.lineTo(ox + boardSize, oy + i*cellS);
            }
            ctx.stroke();

            // Inhalte
            for(let r=0; r&lt;s; r++) { 
                for(let c=0; c&lt;s; c++) { 
                    // Koordinaten Mapping
                    let x, y, z;
                    if (axis === 'z') { z = k; y = r; x = c; } 
                    else if (axis === 'y') { y = k; x = c; z = (s - 1) - r; } 
                    else { x = k; y = c; z = (s - 1) - r; }

                    const idx = z*(s*s) + y*s + x;
                    const val = game.grid[idx];

                    if (val !== 0) {
                        const cx = ox + c*cellS + cellS/2;
                        const cy = oy + r*cellS + cellS/2;
                        this._drawSymbol(ctx, cx, cy, cellS/3.5, val, 3);
                    }
                }
            }
        }
    },

    /**
     * Zeichnet die isometrische 3D Ansicht.
     * @param {HTMLCanvasElement} canvas 
     * @param {TTT3DBoard} game 
     */
    drawIsoView(canvas, game) {
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const s = game.size;

        ctx.clearRect(0,0,w,h);

        let boardSize = w * 0.55; 
        if (s === 4) boardSize = w * 0.45;

        const offX = boardSize * 0.2;
        const offY = -boardSize * 0.4;
        
        const startX = (w - (boardSize + (s-1)*offX))/2 + 20;
        const startY = h - 50;

        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "right"; 
        ctx.textBaseline = "middle";

        // Zeichnen von hinten (z=0) nach vorne (z=s-1)
        for (let z=0; z&lt;s; z++) {
            const ox = startX + z * offX;
            const oy = startY + z * offY;

            // Transparenz für Tiefeneffekt
            ctx.save();
            // Hintere Ebenen transparenter
            ctx.globalAlpha = 0.4 + (0.6 * (z+1)/s);

            // Label
            ctx.fillStyle = "#7f8c8d";
            ctx.fillText(`z${z+1}`, ox - 10, oy + 20);

            // Ebene Boden
            ctx.fillStyle = "rgba(52, 152, 219, 0.05)"; 
            ctx.fillRect(ox, oy - boardSize, boardSize, boardSize);
            ctx.strokeStyle = "rgba(44, 62, 80, 0.2)"; 
            ctx.lineWidth = 1; 
            ctx.strokeRect(ox, oy - boardSize, boardSize, boardSize);

            // Gitterlinien
            const cellS = boardSize / s;
            ctx.beginPath();
            for(let i=1; i&lt;s; i++) {
                ctx.moveTo(ox + i*cellS, oy); ctx.lineTo(ox + i*cellS, oy - boardSize);
                ctx.moveTo(ox, oy - i*cellS); ctx.lineTo(ox + boardSize, oy - i*cellS);
            }
            ctx.stroke();

            // Steine
            for(let y=0; y&lt;s; y++) {
                for(let x=0; x&lt;s; x++) {
                    const idx = z*(s*s) + y*s + x;
                    const val = game.grid[idx];
                    
                    if (val !== 0) {
                        const cx = ox + x*cellS + cellS/2;
                        const cy = (oy - boardSize) + y*cellS + cellS/2;
                        const r = cellS/3.5;

                        // Kleiner Schatten
                        ctx.fillStyle = "rgba(0,0,0,0.1)";
                        ctx.beginPath(); ctx.arc(cx+2, cy+2, r, 0, Math.PI*2); ctx.fill();

                        this._drawSymbol(ctx, cx, cy, r, val, 2);
                    }
                }
            }
            ctx.restore();
        }
    },

    /**
     * Interner Helfer: Zeichnet Kreis (1) oder Kreuz (2).
     */
    _drawSymbol(ctx, x, y, r, player, lw=5) {
        ctx.lineWidth = lw;
        if (player === 1) { // Blau
            ctx.strokeStyle = "#3498db"; 
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke();
        } else if (player === 2) { // Rot
            ctx.strokeStyle = "#e74c3c"; 
            ctx.beginPath(); 
            ctx.moveTo(x-r, y-r); ctx.lineTo(x+r, y+r);
            ctx.moveTo(x+r, y-r); ctx.lineTo(x-r, y+r); 
            ctx.stroke();
        }
    }
};</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Sat Feb 07 2026 23:25:54 GMT+0100 (Central European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
