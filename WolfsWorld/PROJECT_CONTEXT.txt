

/* --- FILE: css/rotatebox.css --- */
/* css/rotatebox.css */

/* L√∂sungsweg Box */
#solutionContainer {
    margin-top: 15px;
    background: rgba(0, 0, 0, 0.05); /* Leicht grau/transparent */
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 6px;
    padding: 10px;
    max-height: 200px;
    overflow-y: auto;
}

#solutionPath {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
}

/* Die Badges (Schritt-Marker) */
.step-badge {
    background: #34495e;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-weight: bold;
    font-size: 0.9rem;
    border: 1px solid transparent;
    transition: all 0.2s ease;
    opacity: 0.7;
}

/* AKTIVER SCHRITT - Highlighting */
.step-badge.active {
    background-color: #f39c12; /* Das Orange aus dem Original */
    color: white;
    transform: scale(1.15);
    border-color: #e67e22;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    opacity: 1;
    z-index: 2; /* In den Vordergrund */
}

.warning-tag {
    color: #c0392b;
    background: #fadbd8;
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    font-size: 0.8rem;
    margin-left: 10px;
}

/* Stats */
.stat-row {
    display: flex;
    justify-content: space-between;
    padding: 5px 0;
    border-bottom: 1px solid #eee;
    font-size: 0.9rem;
}

/* --- FILE: css/tictactoe.css --- */
/* css/tictactoe.css */

/* Men√º Grid */
.ttt-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    max-width: 900px;
    margin: 40px auto;
    padding: 20px;
}

.game-card {
    background: white; padding: 30px; border-radius: 8px; text-align: center;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    text-decoration: none; color: inherit; display: flex; flex-direction: column; align-items: center;
    transition: transform 0.2s;
}
.game-card:hover { transform: translateY(-5px); box-shadow: 0 10px 15px rgba(0,0,0,0.15); }

.icon { font-size: 3rem; margin-bottom: 15px; }
.tag { background: #e1f5fe; color: #0277bd; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; margin-bottom: 10px; }

/* 3D View Buttons */
.view-controls {
    display: flex; background: #ecf0f1; border-radius: 4px; padding: 4px; gap: 4px; margin-bottom: 10px;
}
.view-btn {
    flex: 1; padding: 6px; font-size: 0.8rem; border: none; background: transparent; 
    cursor: pointer; border-radius: 3px; color: #7f8c8d; font-weight: 600;
}
.view-btn.active { background: #fff; color: #3498db; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

/* Size Selector */
.size-selector { display: flex; gap: 5px; margin-bottom: 10px; }
.size-btn { flex: 1; padding: 8px; border: 1px solid #bdc3c7; background: white; cursor: pointer; border-radius: 4px; }
.size-btn.active { background: #3498db; color: white; border-color: #2980b9; }

/* --- FILE: css/style.css --- */
/* css/style.css */

:root {
    --bg-color: #f0f2f5;
    --sidebar-bg: #ffffff;
    --text-main: #2c3e50;
    --text-muted: #7f8c8d;
    --accent-blue: #3498db;
    --accent-blue-hover: #2980b9;
    --accent-red: #e74c3c;
    --accent-green: #2ecc71;
    --accent-yellow: #f1c40f;
    --border-color: #ddd;
}

body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-main);
    height: 100vh;
    overflow: hidden;
    display: flex; /* Globales Flex-Layout */
}

/* --- Globales Layout: Sidebar & Game Area --- */

.sidebar {
    width: 320px;
    background: var(--sidebar-bg);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    z-index: 10;
    box-shadow: 2px 0 10px rgba(0,0,0,0.05);
}

.sidebar-header {
    padding: 20px;
    background: #34495e;
    color: white;
}

.sidebar-header h2 { margin: 10px 0 0 0; font-size: 1.5rem; }

.sidebar-content {
    padding: 20px;
    overflow-y: auto;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.game-area {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #dfe6e9;
    position: relative;
}

/* --- UI Komponenten --- */

.control-section {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 6px;
    border: 1px solid #eee;
}

.viz-label {
    display: block;
    font-size: 0.85rem;
    font-weight: bold;
    color: var(--text-muted);
    text-transform: uppercase;
    margin-bottom: 5px;
}

.viz-select, .viz-input {
    width: 100%;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    font-size: 1rem;
    box-sizing: border-box;
}

/* Buttons */
.viz-btn {
    border: none;
    padding: 10px 15px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    font-size: 0.95rem;
    text-decoration: none;
    display: inline-block;
    transition: filter 0.2s;
    text-align: center;
}
.viz-btn:hover { filter: brightness(90%); }
.viz-btn:disabled { opacity: 0.6; cursor: not-allowed; filter: grayscale(1); }

.btn-back { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff; padding: 5px 10px; font-size: 0.8rem; }
.btn-action { background: var(--accent-blue); color: white; width: 100%; }
.btn-restart { background: var(--accent-yellow); color: #333; width: 100%; }
.btn-danger { background: var(--accent-red); color: white; width: 100%; }

/* Stats Display */
.stats-display {
    text-align: center;
    font-weight: bold;
    font-size: 1.1rem;
    color: var(--text-main);
}

/* Canvas Styling */
canvas {
    background: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    border-radius: 4px;
    /* Damit es nicht riesig wird: */
    max-width: 95%;
    max-height: 95%;
}

/* --- FILE: css/knights-tour.css --- */
/* css/knights-tour.css */

/* Modal Styling */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex; justify-content: center; align-items: center;
    z-index: 100;
}
.modal-box {
    background: white; padding: 25px; border-radius: 8px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.3);
    max-width: 400px; text-align: center;
}
.hidden { display: none !important; }

/* Canvas Cursor */
canvas { cursor: pointer; }

/* --- FILE: css/flowchart.css --- */
/* css/rules-flowchart.css */

/* Basis Container */
.fc-root {
    font-family: 'Segoe UI', sans-serif;
    padding: 10px;
}

/* Wrapper um eine Box (f√ºr Layout) */
.fc-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    margin-bottom: 5px;
}

/* Die eigentliche Regel-Box */
.fc-box {
    background: white;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    width: 95%; /* Fast volle Breite */
    margin-bottom: 5px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    transition: all 0.2s;
    position: relative;
    box-sizing: border-box;
}

/* Status-Farben (werden per JS gesetzt) */
.fc-box.checking {
    border-color: #f39c12;
    background-color: #fef9e7;
    box-shadow: 0 0 5px rgba(243, 156, 18, 0.5);
}
.fc-box.success {
    border-color: #27ae60;
    background-color: #eafaf1;
    border-left: 5px solid #27ae60; /* Dickerer linker Rand */
}

/* Header innerhalb der Box */
.fc-header {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
    color: #2c3e50;
}

/* Beschreibung/Tooltip Text */
.fc-desc {
    font-size: 0.75rem;
    color: #7f8c8d;
    margin-left: 24px; /* Einr√ºcken unter Checkbox */
    margin-top: 2px;
}

/* Farbkodierung nach Typ */
.fc-condition { border-top: 3px solid #e67e22; } /* Orange f√ºr Bedingungen */
.fc-group { border-top: 3px solid #3498db; background-color: #f8fbff; } /* Blau f√ºr Gruppen */
.fc-rule { border-left: 3px solid #bdc3c7; } /* Grau f√ºr einfache Regeln */

/* Kind-Container (einger√ºckt mit Linie) */
.fc-list {
    width: 100%;
    padding-left: 15px;
    margin-top: 5px;
    border-left: 2px solid #eee; /* Vertikale Linie */
    box-sizing: border-box;
}

/* Verzweigungen (Ja/Nein √Ñste) */
.fc-branches {
    display: flex;
    width: 100%;
    margin-top: 8px;
    gap: 10px;
}
.fc-branch {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    border-top: 2px solid #ccc; /* Horizontale Linie */
    padding-top: 10px;
    position: relative;
}
.fc-label {
    position: absolute;
    top: -12px;
    background: #f0f2f5; /* Hintergrundfarbe wie Body */
    padding: 0 5px;
    font-size: 0.75rem;
    color: #555;
    font-weight: bold;
}

/* --- FILE: css/tree-viz.css --- */
/* css/tree-viz.css */

/* --- LAYOUT --- */
/* Container f√ºr das Canvas, erlaubt Scrolling und Dragging */
.viz-container {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #ecf0f1;
    position: relative;
    overflow: auto; /* Scrollbars wenn n√∂tig */
    cursor: grab;
}

.viz-container:active {
    cursor: grabbing;
}

.viz-canvas {
    display: block;
    /* Schatten f√ºr bessere Sichtbarkeit auf dem Hintergrund */
    box-shadow: 0 0 20px rgba(0,0,0,0.1);
    background: white;
}

/* --- TOOLBAR --- */
.viz-toolbar {
    background: #34495e;
    color: white;
    padding: 10px 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    flex-wrap: wrap;
    border-bottom: 1px solid #2c3e50;
    min-height: 50px;
    font-family: 'Segoe UI', sans-serif;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    z-index: 100;
}

.viz-control-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

/* Label Styling */
.viz-label {
    font-size: 0.85rem;
    color: #bdc3c7;
    font-weight: 600;
    white-space: nowrap;
}

/* Inputs */
.viz-select, .viz-input {
    background: rgba(255,255,255,0.9);
    border: none;
    border-radius: 4px;
    padding: 6px 10px;
    font-size: 0.9rem;
    color: #2c3e50;
    font-family: inherit;
}

/* Checkbox Gruppen */
.viz-checkboxes {
    display: flex;
    gap: 15px;
    margin-left: 10px;
}

.viz-checkbox-label {
    font-size: 0.9rem;
    color: #ecf0f1;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 5px;
}

/* Stats Anzeige */
.viz-stats {
    font-size: 0.9rem;
    color: #f1c40f;
    font-weight: bold;
    margin-left: auto; /* Schiebt Stats nach rechts */
    margin-right: 20px;
}

/* --- FILE: css/lab-style.css --- */
/* css/lab-style.css */

/* --- 1. GLOBALES LAYOUT (Angelehnt an tree-viz.css) --- */
body { 
    margin: 0; 
    font-family: 'Segoe UI', sans-serif; 
    display: flex; 
    flex-direction: column; 
    height: 100vh; 
    overflow: hidden; 
    background: #f0f2f5; 
}

/* --- 2. UNIFIED TOOLBAR --- */
.lab-toolbar {
    background: #34495e; /* Dunkelblau wie Tree Viz */
    color: white;
    padding: 10px 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    z-index: 100;
    height: 50px;
}

.viz-control-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.viz-label {
    font-size: 0.85rem;
    color: #bdc3c7;
    font-weight: 600;
    white-space: nowrap;
}

.viz-select {
    background: rgba(255,255,255,0.95);
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    font-size: 0.9rem;
    color: #2c3e50;
    font-weight: bold;
}

/* Buttons im Header */
.viz-btn {
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
    color: white !important;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.2s;
}
.viz-btn:hover { opacity: 0.9; }
.viz-btn-back { background: #7f8c8d; }     /* Grau */
.viz-btn-action { background: #3498db; }   /* Blau */
.viz-btn-stop { background: #c0392b; }     /* Rot */
.viz-btn-restart { background: #f1c40f; color: #333 !important; } /* Gelb */

/* --- 3. HAUPTGRID --- */
.lab-grid {
    display: flex;
    flex: 1;
    overflow: hidden;
    padding: 15px;
    gap: 15px;
}

/* Spalten */
.col-tree {
    flex: 1;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid #dfe6e9;
}

.col-game {
    width: 480px; /* Fixe Breite f√ºr Spiel */
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: center;
}

/* Header in den Spalten */
.panel-header {
    padding: 12px;
    font-weight: bold;
    color: #2c3e50;
    border-bottom: 2px solid #f0f2f5;
    background: #fafafa;
    display: flex;
    align-items: center;
    gap: 10px;
}

/* Scrollbarer Bereich f√ºr B√§ume */
.tree-container {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    background: #fcfcfc;
}

/* --- 4. FLOWCHART NODES (Karten-Design) --- */
.fc-node {
    background: white;
    border: 1px solid #dcdcdc;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
    position: relative;
    transition: all 0.3s ease;
    /* Linker Farbbalken (Default Grau) */
    border-left: 5px solid #bdc3c7;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}

/* Einr√ºckung f√ºr Hierarchie */
.fc-children {
    padding-left: 20px; /* Einr√ºckung */
    border-left: 1px solid #eee; /* D√ºnne Linie */
    margin-left: 10px;
}

/* Status: Wird gepr√ºft (Gelb/Orange) */
.fc-node.checking {
    background-color: #fff9db;
    border-color: #f1c40f;
    border-left-color: #f1c40f;
    transform: scale(1.02);
    box-shadow: 0 2px 8px rgba(241, 196, 15, 0.3);
    z-index: 10;
}

/* Status: Hat gefeuert / Erfolgreich (Gr√ºn) */
.fc-node.success {
    background-color: #e8f8f5;
    border-color: #2ecc71;
    border-left-color: #2ecc71;
}

/* Deaktiviert (Ausgegraut) */
.fc-node.inactive {
    opacity: 0.6;
    background: #f9f9f9;
}

/* Typen-Indikatoren (Farbbalken Links √ºberschreiben) */
.fc-type-group { border-left-color: #3498db; } /* Blau */
.fc-type-cond { border-left-color: #9b59b6; }  /* Lila */

/* Inhalt Layout */
.fc-content {
    display: flex;
    align-items: center;
    gap: 10px;
}

.fc-label {
    font-size: 0.9rem;
    font-weight: 600;
    color: #2c3e50;
    flex-grow: 1;
}

.fc-desc {
    font-size: 0.75rem;
    color: #7f8c8d;
    margin-top: 4px;
    margin-left: 25px;
}

/* Verzweigungen (Condition Branches) */
.fc-branches {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.fc-branch {
    flex: 1;
    border-top: 2px solid #ccc;
    padding-top: 10px;
    position: relative;
}
.fc-branch-label {
    position: absolute;
    top: -12px;
    left: 50%;
    transform: translateX(-50%);
    background: #fcfcfc;
    padding: 0 5px;
    font-size: 0.7rem;
    font-weight: bold;
    color: #7f8c8d;
}

/* --- 5. GAME UI --- */
.game-card {
    background: white;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
}

.view-controls {
    display: flex;
    gap: 5px;
    margin-bottom: 10px;
    background: #ecf0f1;
    padding: 4px;
    border-radius: 4px;
}
.view-btn {
    padding: 4px 10px;
    border: none;
    background: transparent;
    cursor: pointer;
    font-weight: bold;
    font-size: 0.8rem;
    color: #7f8c8d;
    border-radius: 3px;
}
.view-btn.active {
    background: white;
    color: #3498db;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.log-box {
    background: #2c3e50;
    color: #ecf0f1;
    width: 100%;
    flex: 1;
    border-radius: 8px;
    padding: 10px;
    font-family: monospace;
    font-size: 0.85rem;
    overflow-y: auto;
    border: 1px solid #34495e;
}
.log-line { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.1); }

.hidden { display: none !important; }

/* --- FILE: games/rotatebox.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>RotateBox Sandbox</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/rotatebox.css">
    <style>
        /* Layout Fixes basierend auf deinem Original */
        body { margin: 0; background: #f0f2f5; font-family: 'Segoe UI', sans-serif; height: 100vh; overflow: hidden; display: flex; }
        
        /* Container Setup wie in deiner Sandbox */
        #container { display: flex; width: 100%; height: 100%; }
        
        #menu { 
            width: 300px; 
            background: white; 
            border-right: 1px solid #ddd; 
            padding: 20px; 
            box-shadow: 2px 0 10px rgba(0,0,0,0.05); 
            z-index: 10; 
            display: flex; 
            flex-direction: column;
            overflow-y: auto;
        }

        #game-area { 
            flex-grow: 1; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background: #dfe6e9; 
            position: relative;
        }

        /* Canvas Begrenzung damit es nicht riesig wird */
        canvas { 
            background: white; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
            border-radius: 8px;
            max-width: 90vh; 
            max-height: 90vh;
        }

        .control-group { margin-bottom: 20px; }
        
        .primary-btn { 
            background: #3498db; color: white; border: none; padding: 10px; 
            width: 100%; border-radius: 5px; cursor: pointer; font-weight: bold; 
        }
        .primary-btn:hover { background: #2980b9; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="container">
        <aside id="menu">
            <header>
                <a href="../index.html" style="text-decoration: none; display:block; margin-bottom:15px;">
                    <button style="cursor:pointer; padding: 5px 10px;">‚Üê Hauptmen√º</button>
                </a>
                <h2 style="margin-top:0;">RotateBox</h2>
            </header>

            <div class="control-group">
                <label for="boardSelect" style="font-weight:bold;">Level w√§hlen:</label>
                <select id="boardSelect" class="input-field" style="width: 100%; padding: 8px; margin-top:5px;">
                    <option value="0">Tutorial</option>
                    <option value="1">Level 1</option>
                    <option value="2">Level 2</option>
                    <option value="3">Level 3</option>
                </select>
            </div>
            
            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                    <input type="checkbox" id="animateToggle" checked> Animationen
                </label>
            </div>
            
            <div class="stats-panel">
                <p>Schritte: <strong id="moveCount">0</strong></p>
                <button id="resetBtn" style="width: 100%; padding: 8px; cursor: pointer; background: #ecf0f1; border: 1px solid #bdc3c7; border-radius: 4px;">Reset Board</button>
                
                <hr style="opacity: 0.2; margin: 20px 0;">
                
                <button id="solveBtn" class="primary-btn">KI L√∂sung suchen üß†</button>
            </div>

            <div id="aiOutput" class="hidden">
                <div class="ai-header" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 5px;">KI Analyse</h3>
                    <span id="pathWarning" class="warning-tag hidden" style="color:red; font-weight:bold;">‚ö†Ô∏è Pfad verlassen!</span>
                </div>
                
                <div class="stat-row">
                    <span>L√§nge: <b id="stat-depth">-</b></span>
                    <span>Knoten: <b id="stat-nodes">-</b></span>
                </div>

                <button id="animateBtn" class="primary-btn" style="background: #27ae60; margin-top: 15px; margin-bottom: 15px;">
                    ‚ñ∂ L√∂sung abspielen
                </button>

                <div id="solutionContainer" style="margin-top: 10px; border:1px solid #ddd; padding:5px; max-height:150px; overflow-y:auto;">
                    <small>Weg:</small>
                    <div id="solutionPath" style="display: flex; gap: 5px; flex-wrap: wrap; margin-top: 5px;"></div>
                </div>
            </div>

            <div id="winMessage" class="hidden" style="margin-top: 20px; color: #27ae60; font-weight: bold; text-align: center; font-size: 1.5em;">
                üéâ GEWONNEN!
            </div>
            
            <div style="margin-top:auto; font-size:0.8rem; color:#888; text-align:center;">
                Steuerung: Pfeiltasten Links/Rechts
            </div>
        </aside>

        <main id="game-area">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
        </main>
    </div>

    <script src="../js/core/game-state.js"></script>
    <script src="../js/ai/search-algorithms.js"></script>
    
    <script src="../js/games/rotatebox/logic.js"></script>
    <script src="../js/games/rotatebox/renderer.js"></script>
    <script src="../js/games/rotatebox/solver.js"></script>
    
    <script src="../js/games/rotatebox/controller.js"></script>
</body>
</html>

/* --- FILE: games/ttt-ultimate.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Ultimate Tic-Tac-Toe</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>

    <aside class="sidebar">
        <div class="sidebar-header">
            <a href="tictactoe-menu.html" class="viz-btn btn-back">‚¨Ö TTT Men√º</a>
            <h2>Ultimate</h2>
        </div>

        <div class="sidebar-content">
            <div class="control-section">
                <label class="viz-label">Spieler 1 (Blau)</label>
                <select id="p1Type" class="viz-select">
                    <option value="human">Mensch</option>
                    <option value="random">KI: Zufall</option>
                    <option value="rulebased">KI: Regeln</option>
                </select>
                
                <label class="viz-label" style="margin-top:10px;">Spieler 2 (Rot)</label>
                <select id="p2Type" class="viz-select">
                    <option value="human">Mensch</option>
                    <option value="random" selected>KI: Zufall</option>
                    <option value="rulebased">KI: Regeln</option>
                </select>
            </div>

            <div class="control-section">
                <label class="viz-label">KI Geschwindigkeit</label>
                <input type="range" id="aiSpeed" min="0" max="2000" step="100" value="500">
            </div>

            <div class="control-section" style="text-align:center;">
                <div id="statusText" class="stats-display">Bereit</div>
            </div>

            <button class="viz-btn btn-restart" onclick="UltimateController.reset()">Neues Spiel</button>
            
            <div style="margin-top:20px; font-size:0.85rem; color:#7f8c8d; text-align:center;">
                <strong>Info:</strong> Dein Zug bestimmt, in welchem gro√üen Feld der Gegner als n√§chstes spielen muss.
            </div>
        </div>
    </aside>

    <main class="game-area">
        <canvas id="gameCanvas" width="600" height="600"></canvas>
    </main>

    <script src="../js/core/game-state.js"></script>
    <script src="../js/core/agent.js"></script>
    <script src="../js/ai/agents/random-agent.js"></script>
    <script src="../js/ai/agents/rule-based-agent.js"></script>
    <script src="../js/ai/rules/rule-structure.js"></script>
    <script src="../js/ai/rules/ttt-rules.js"></script>
    
    <script src="../js/games/tictactoe/logic.js"></script>
    <script src="../js/games/tictactoe/renderer.js"></script>
    <script src="../js/games/tictactoe/ultimate-controller.js"></script>
</body>
</html>

/* --- FILE: games/ttt-3d.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>3D Tic-Tac-Toe</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/tictactoe.css">
    <style>
        /* Spezielles Layout f√ºr 3D: Split View im Game Area */
        .game-split {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }
        .main-view { flex: 2; display: flex; flex-direction: column; align-items: center; }
        .side-view { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        #isoCanvas { background: transparent; box-shadow: none; border: 1px solid #ddd; border-radius: 8px; }
    </style>
</head>
<body>

    <aside class="sidebar">
        <div class="sidebar-header">
            <a href="tictactoe-menu.html" class="viz-btn btn-back">‚¨Ö TTT Men√º</a>
            <h2>3D TTT</h2>
        </div>

        <div class="sidebar-content">
            <div class="control-section">
                <label class="viz-label">Gr√∂√üe</label>
                <div class="size-selector">
                    <button class="size-btn active" onclick="ThreeDController.setSize(3)">3x3x3</button>
                    <button class="size-btn" onclick="ThreeDController.setSize(4)">4x4x4</button>
                </div>
            </div>

            <div class="control-section">
                <label class="viz-label">Spieler 1 (Blau)</label>
                <select id="p1Type" class="viz-select">
                    <option value="human">Mensch</option>
                    <option value="random">KI: Zufall</option>
                    <option value="rulebased">KI: Regeln</option>
                </select>
                
                <label class="viz-label" style="margin-top:10px;">Spieler 2 (Rot)</label>
                <select id="p2Type" class="viz-select">
                    <option value="human">Mensch</option>
                    <option value="random" selected>KI: Zufall</option>
                    <option value="rulebased">KI: Regeln</option>
                </select>
            </div>

            <div class="control-section">
                <label class="viz-label">Tempo</label>
                <input type="range" id="aiSpeed" min="0" max="2000" step="100" value="500">
            </div>

            <div class="control-section" style="text-align:center;">
                <div id="statusText" class="stats-display">Bereit</div>
            </div>

            <button class="viz-btn btn-restart" onclick="ThreeDController.reset()">Neustart</button>
        </div>
    </aside>

    <main class="game-area">
        <div class="game-split">
            <div class="main-view">
                <div class="view-controls">
                    <button class="view-btn active" onclick="ThreeDController.setAxis('z')">Ebenen (Oben)</button>
                    <button class="view-btn" onclick="ThreeDController.setAxis('y')">Tiefe (Vorne)</button>
                    <button class="view-btn" onclick="ThreeDController.setAxis('x')">Schnitt (Seite)</button>
                </div>
                
                <canvas id="gameCanvas" width="700" height="300"></canvas>
                
                <p style="color:#7f8c8d; font-size:0.9rem; margin-top:15px; text-align:center;">
                    Klicke in die Schnittebenen, um zu setzen.
                </p>
            </div>

            <div class="side-view">
                <label class="viz-label">3D Vorschau</label>
                <canvas id="isoCanvas" width="250" height="300"></canvas>
            </div>
        </div>
    </main>

    <script src="../js/core/game-state.js"></script>
    <script src="../js/core/agent.js"></script>
    <script src="../js/ai/agents/random-agent.js"></script>
    <script src="../js/ai/agents/rule-based-agent.js"></script>
    <script src="../js/ai/rules/rule-structure.js"></script>
    <script src="../js/ai/rules/ttt-rules.js"></script>
    
    <script src="../js/games/tictactoe/logic.js"></script>
    <script src="../js/games/tictactoe/renderer.js"></script>
    <script src="../js/games/tictactoe/3d-controller.js"></script>

</body>
</html>

/* --- FILE: games/tictactoe-menu.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Tic-Tac-Toe Universum</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/tictactoe.css">
    <style>
        /* Zentrierung f√ºr das Men√º */
        body { 
            display: block; 
            overflow-y: auto; /* Scrollbar erlauben */
            height: auto;
        }
        .menu-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
            text-align: center;
        }
        h1 { color: #2c3e50; margin-bottom: 40px; }
    </style>
</head>
<body>

    <div class="menu-container">
        <header style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <a href="../index.html" class="viz-btn btn-back" style="background:#34495e; color:white;">‚¨Ö Hauptmen√º</a>
        </header>

        <h1>Tic-Tac-Toe Universum</h1>

        <div class="ttt-grid">
            <a href="ttt-regular.html" class="game-card">
                <span class="tag">Der Einstieg</span>
                <div class="icon">#Ô∏è‚É£</div>
                <h2>Klassik (3x3)</h2>
                <p>Das Grundspiel. Perfekt um den Minimax-Algorithmus zu verstehen.</p>
            </a>

            <a href="ttt-3d.html" class="game-card">
                <span class="tag">R√§umliches Denken</span>
                <div class="icon">üßä</div>
                <h2>3D Tic-Tac-Toe</h2>
                <p>Denke in drei Dimensionen (3x3x3 oder 4x4x4).</p>
            </a>

            <a href="ttt-ultimate.html" class="game-card">
                <span class="tag">Strategie</span>
                <div class="icon">ü§Ø</div>
                <h2>Ultimate</h2>
                <p>Das Spiel im Spiel. Strategische Tiefe durch verschachtelte Boards.</p>
            </a>
        </div>
    </div>

</body>
</html>

/* --- FILE: games/ttt-regular.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Tic-Tac-Toe Regular</title>
    <link rel="stylesheet" href="../css/style.css">
    </head>
<body>

    <aside class="sidebar">
        <div class="sidebar-header">
            <a href="tictactoe-menu.html" class="viz-btn btn-back">‚¨Ö TTT Men√º</a>
            <h2>Regular (3x3)</h2>
        </div>

        <div class="sidebar-content">
            <div class="control-section">
                <label class="viz-label">Spieler 1 (Blau)</label>
                <select id="p1Type" class="viz-select">
                    <option value="human" selected>Mensch</option>
                    <option value="random">KI: Zufall</option>
                    <option value="rulebased">KI: Regeln</option>
                </select>
                
                <label class="viz-label" style="margin-top:10px;">Spieler 2 (Rot)</label>
                <select id="p2Type" class="viz-select">
                    <option value="human">Mensch</option>
                    <option value="random" selected>KI: Zufall</option>
                    <option value="rulebased">KI: Regeln</option>
                </select>
            </div>

            <div class="control-section">
                <label class="viz-label">KI Geschwindigkeit</label>
                <input type="range" id="aiSpeed" min="0" max="2000" step="100" value="500">
            </div>

            <div class="control-section" style="text-align:center;">
                <div id="statusText" class="stats-display">Bereit</div>
            </div>

            <button class="viz-btn btn-restart" onclick="RegularController.reset()">Neues Spiel</button>
        </div>
    </aside>

    <main class="game-area">
        <canvas id="gameCanvas" width="500" height="500"></canvas>
    </main>

    <script src="../js/core/game-state.js"></script>
    <script src="../js/core/agent.js"></script>
    <script src="../js/ai/agents/random-agent.js"></script>
    <script src="../js/ai/agents/rule-based-agent.js"></script>
    <script src="../js/ai/rules/rule-structure.js"></script>
    <script src="../js/ai/rules/ttt-rules.js"></script>
    
    <script src="../js/games/tictactoe/logic.js"></script>
    <script src="../js/games/tictactoe/renderer.js"></script>
    <script src="../js/games/tictactoe/regular-controller.js"></script>
</body>
</html>

/* --- FILE: games/knights-tour.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Springerproblem</title>
    <link rel="stylesheet" href="../css/style.css">
    </head>
<body>

    <aside class="sidebar">
        <div class="sidebar-header">
            <a href="../index.html" class="viz-btn btn-back">‚¨Ö Hauptmen√º</a>
            <h2>Springer</h2>
        </div>

        <div class="sidebar-content">
            <div class="control-section">
                <label class="viz-label">Brettgr√∂√üe</label>
                <select id="sizeSelect" class="viz-select">
                    <option value="5">5 x 5</option>
                    <option value="6">6 x 6</option>
                    <option value="8" selected>8 x 8</option>
                    <option value="10">10 x 10</option>
                </select>
            </div>

            <div class="control-section">
                <label class="viz-label">Geschwindigkeit</label>
                <input type="range" id="solveSpeed" min="0" max="200" step="10" value="50" style="width:100%">
                
                <div style="margin-top:10px;">
                    <label style="display:flex; align-items:center; cursor:pointer;">
                        <input type="checkbox" id="chkShowMoves" checked> 
                        <span style="margin-left:8px;">M√∂gliche Z√ºge zeigen</span>
                    </label>
                </div>
            </div>

            <div class="control-section" style="text-align:center;">
                <div id="stats" class="stats-display">Z√ºge: 0 / 64</div>
            </div>

            <div style="margin-top:auto; display:flex; flex-direction:column; gap:10px;">
                <button id="solveBtn" class="viz-btn btn-action" onclick="Game.toggleSolver()">
                    ‚ö° Automatisch L√∂sen
                </button>
                
                <div style="display:flex; gap:10px;">
                    <button class="viz-btn" style="flex:1; background:#95a5a6; color:white;" onclick="Game.undo()">
                        ‚Ü∫ Zur√ºck
                    </button>
                    <button class="viz-btn btn-restart" style="flex:1;" onclick="Game.reset()">
                        Neustart
                    </button>
                </div>
            </div>
        </div>
    </aside>

    <main class="game-area">
        <canvas id="boardCanvas" width="600" height="600"></canvas>
    </main>

    <script src="../js/core/game-state.js"></script>
    <script src="../js/ai/search-algorithms.js"></script>
    
    <script src="../js/games/knights-tour/logic.js"></script>
    <script src="../js/games/knights-tour/renderer.js"></script>
    <script src="../js/games/knights-tour/controller.js"></script>
</body>
</html>

/* --- FILE: js/core/game-state.js --- */
/**
 * Interface f√ºr einen Spielzustand.
 * Jedes Spiel (TicTacToe, RotateBox, KnightsTour) muss dieses Interface implementieren,
 * damit die KI-Agenten und Suchalgorithmen damit arbeiten k√∂nnen.
 * * @interface GameState
 */
class GameState {
    constructor() {
        /**
         * Gibt an, ob das Spiel beendet ist (Sieg oder Remis).
         * @type {boolean}
         */
        this.isGameOver = false;

        /**
         * Der Gewinner des Spiels.
         * 0 = L√§uft noch / Remis (je nach Kontext), 1 = Spieler 1, 2 = Spieler 2.
         * @type {number}
         */
        this.winner = 0;

        /**
         * Der Spieler, der aktuell am Zug ist.
         * @type {number}
         */
        this.currentPlayer = 1;
    }

    /**
     * Liefert eine Liste aller g√ºltigen Z√ºge im aktuellen Zustand.
     * @returns {Array<number|Object>} Ein Array von Z√ºgen (Format h√§ngt vom Spiel ab).
     */
    getAllValidMoves() {
        throw new Error("Method 'getAllValidMoves()' must be implemented.");
    }

    /**
     * F√ºhrt einen Zug aus und aktualisiert den internen Zustand.
     * @param {number|Object} move - Der Zug, der ausgef√ºhrt werden soll.
     * @returns {boolean} True, wenn der Zug g√ºltig war und ausgef√ºhrt wurde.
     */
    makeMove(move) {
        throw new Error("Method 'makeMove()' must be implemented.");
    }

    /**
     * Erstellt eine tiefe Kopie des aktuellen Spielzustands.
     * Wichtig f√ºr KI-Simulationen, damit das echte Brett nicht ver√§ndert wird.
     * @returns {GameState} Eine exakte Kopie dieses Zustands.
     */
    clone() {
        throw new Error("Method 'clone()' must be implemented.");
    }

    /**
     * Generiert einen eindeutigen String f√ºr diesen Zustand.
     * Wird f√ºr Caching und Duplikaterkennung in Suchb√§umen ben√∂tigt.
     * @returns {string} Der Hash/Key des Zustands.
     */
    getStateKey() {
        throw new Error("Method 'getStateKey()' must be implemented.");
    }
}

/* --- FILE: js/core/agent.js --- */
/**
 * Abstrakte Basisklasse f√ºr alle KI-Agenten.
 * Ein Agent erh√§lt einen Spielzustand und muss einen Zug zur√ºckgeben.
 * * @abstract
 */
class Agent {
    /**
     * Erstellt einen neuen Agenten.
     * @param {string} [name="Agent"] - Der Anzeigename des Agenten.
     */
    constructor(name = "Agent") {
        this.name = name;
    }

    /**
     * Berechnet den n√§chsten Zug basierend auf dem Spielzustand.
     * @param {GameState} gameState - Der aktuelle Zustand des Spiels.
     * @returns {(Object|null)} Ein Objekt `{ move: mixed, reason: string }` oder null, wenn kein Zug m√∂glich ist.
     */
    getAction(gameState) {
        throw new Error("getAction() muss von der Unterklasse implementiert werden!");
    }
}

/* --- FILE: js/utils/benchmark.js --- */
/**
 * Utility-Klasse zur Messung von Laufzeiten.
 * @class Benchmark
 */
class Benchmark {
    constructor() {
        /** @private */
        this.startTime = 0;
        /** @private */
        this.endTime = 0;
        /** * Gespeicherte Messdaten.
         * @type {Array<{x: (number|string), y: number}>} 
         */
        this.history = []; 
    }

    /** Startet die Zeitmessung. */
    start() {
        this.startTime = performance.now();
    }

    /** * Stoppt die Zeitmessung.
     * @returns {number} Dauer in ms.
     */
    stop() {
        this.endTime = performance.now();
        return this.getDuration();
    }

    /** @returns {number} Aktuelle Dauer in ms. */
    getDuration() {
        return this.endTime - this.startTime;
    }

    /**
     * Speichert einen Datenpunkt.
     * @param {number|string} label - Label f√ºr X-Achse.
     * @param {number} [time=null] - Dauer (optional).
     */
    record(label, time = null) {
        const val = time !== null ? time : this.getDuration();
        this.history.push({ x: label, y: val });
    }

    /** @returns {number} Durchschnitt aller Messungen. */
    getAverage() {
        if (this.history.length === 0) return 0;
        const sum = this.history.reduce((a, b) => a + b.y, 0);
        return sum / this.history.length;
    }

    /** Setzt alles zur√ºck. */
    reset() {
        this.history = [];
        this.startTime = 0;
        this.endTime = 0;
    }
}

/* --- FILE: js/viz/flowchart-visualizer.js --- */
/**
 * @fileoverview Visualisiert Regelb√§ume als interaktives Flowchart.
 * Nutzt DOM-Elemente f√ºr Styling (Karten, Farbbalken).
 */

class FlowchartVisualizer {
    /**
     * @param {string} containerId - DOM ID des Containers.
     * @param {DecisionTree} tree - Der Regelbaum.
     * @param {function} toggleCallback - Callback(ruleName).
     */
    constructor(containerId, tree, toggleCallback) {
        this.container = document.getElementById(containerId);
        this.tree = tree;
        this.onToggle = toggleCallback;
        this.prefix = containerId;
    }

    render() {
        if (!this.container || !this.tree) return;
        this.container.innerHTML = '';
        this._renderNode(this.tree.root, this.container);
    }

    _renderNode(node, parentEl) {
        if (!node) return;

        // Haupt-Karte erstellen
        const card = document.createElement('div');
        card.className = 'fc-node';
        // ID f√ºr Highlighting: containerId-Regelname
        card.id = `${this.prefix}-${node.name.replace(/\s+/g, '-')}`;

        // Typen-Klassen
        if (!node.active) card.classList.add('inactive');
        if (node.children) card.classList.add('fc-type-group');
        if (node.conditionFn) card.classList.add('fc-type-cond');

        // Inhalt (Checkbox + Titel)
        const content = document.createElement('div');
        content.className = 'fc-content';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = node.active;
        checkbox.onclick = (e) => {
            e.stopPropagation(); 
            if (this.onToggle) this.onToggle(node.name);
        };

        const label = document.createElement('span');
        label.className = 'fc-label';
        // Icons
        let icon = '‚ö°'; // Atomic
        if (node.children) icon = 'üìÇ';
        if (node.conditionFn) icon = '‚óá';
        
        label.innerHTML = `${icon} ${node.name}`;

        content.appendChild(checkbox);
        content.appendChild(label);
        card.appendChild(content);

        // Beschreibung
        if (node.description) {
            const desc = document.createElement('div');
            desc.className = 'fc-desc';
            desc.innerText = node.description;
            card.appendChild(desc);
        }

        parentEl.appendChild(card);

        // --- REKURSION F√úR KINDER ---

        // Fall 1: Verzweigung (Condition) -> Nebeneinander
        if (node.conditionFn) {
            const branchContainer = document.createElement('div');
            branchContainer.className = 'fc-branches';

            // Ja-Zweig
            if (node.thenNode) {
                const branchYes = document.createElement('div');
                branchYes.className = 'fc-branch';
                branchYes.innerHTML = '<div class="fc-branch-label">JA</div>';
                this._renderNode(node.thenNode, branchYes);
                branchContainer.appendChild(branchYes);
            }

            // Nein-Zweig
            if (node.elseNode) {
                const branchNo = document.createElement('div');
                branchNo.className = 'fc-branch';
                branchNo.innerHTML = '<div class="fc-branch-label">NEIN</div>';
                this._renderNode(node.elseNode, branchNo);
                branchContainer.appendChild(branchNo);
            }
            parentEl.appendChild(branchContainer);
        }
        // Fall 2: Gruppe -> Untereinander (einger√ºckt)
        else if (node.children && node.children.length > 0) {
            const childContainer = document.createElement('div');
            childContainer.className = 'fc-children';
            node.children.forEach(child => {
                this._renderNode(child, childContainer);
            });
            parentEl.appendChild(childContainer);
        }
    }

    // --- HIGHLIGHTING API ---

    highlightCheck(name) {
        this._setClass(name, 'checking');
    }

    highlightSuccess(name) {
        this._setClass(name, 'success');
    }

    clearHighlights() {
        this.container.querySelectorAll('.checking, .success').forEach(el => {
            el.classList.remove('checking', 'success');
        });
    }

    _setClass(name, cls) {
        const id = `${this.prefix}-${name.replace(/\s+/g, '-')}`;
        const el = document.getElementById(id);
        if (el) {
            // Alte Klassen entfernen, um Konflikte zu vermeiden
            el.classList.remove('checking', 'success');
            el.classList.add(cls);
            // Auto-Scroll, damit man sieht, wo die KI ist
            if (cls === 'checking') {
                el.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
        }
    }
}

/* --- FILE: js/viz/tree-engine.js --- */
/**
 * @fileoverview Generische Engine zur Visualisierung von Suchb√§umen auf einem Canvas.
 * Unterst√ºtzt dynamische Skalierung, Drag-Scrolling und Custom-Renderer f√ºr Knoten.
 */

const TREE_CONFIG = {
    nodeSize: 60,
    maxNodeSize: 120,       
    minNodeSize: 40,
    nodePadding: 0,
    levelHeight: 120,
    siblingGap: 30,
    colors: {
        edge: '#bdc3c7',
        text: '#34495e',
        solution: '#27ae60',
        duplicate: '#e67e22',
        forbidden: '#c0392b',
        nodeBorder: '#34495e',
        nodeBg: '#ffffff'
    },
    lineWidth: { normal: 1, highlight: 4, edge: 2 },
    font: { annotation: "bold 12px monospace", edgeLabel: "11px monospace" }
};

/**
 * Repr√§sentiert einen einzelnen Knoten im Visualisierungsbaum.
 */
class TreeNode {
    /**
     * @param {number} id - Eindeutige ID.
     * @param {*} data - Das Datenobjekt (z.B. RotateBoard).
     * @param {number} depth - Tiefe im Baum.
     * @param {string} [parentMove=""] - Die Aktion, die zu diesem Knoten f√ºhrte.
     */
    constructor(id, data, depth, parentMove = "") {
        this.id = id;
        this.data = data;
        this.depth = depth;
        this.parentMove = parentMove;
        this.children = [];
        this.x = 0;
        this.y = 0;
        
        // Status-Flags
        this.isDuplicate = false;
        this.isSolution = false;
        this.isForbidden = false;
        this.annotation = ""; 
    }
}

/**
 * Hauptklasse zur Visualisierung.
 */
class TreeVisualizer {
    /**
     * @param {string} canvasId - ID des HTML Canvas Elements.
     */
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        if (this.canvas) {
            this.ctx = this.canvas.getContext('2d');
        }
        this.config = { ...TREE_CONFIG };
    }

    /**
     * Zeichnet den kompletten Baum.
     * @param {TreeNode} root - Der Wurzelknoten.
     * @param {Object} options - Konfigurationen (z.B. drawNodeFn).
     */
    drawTree(root, options = {}) {
        if (!this.canvas || !root) return;
        
        // Config mergen
        if (options.config) this.config = { ...this.config, ...options.config };

        // 1. Metriken berechnen (Tiefe, Breite)
        const metrics = this._calculateMetrics(root);
        
        // 2. Canvas Gr√∂√üe und Node-Gr√∂√üe anpassen
        this._adjustCanvasAndScale(metrics);
        
        // 3. Koordinaten zuweisen (Reingold-Tilford √§hnlich)
        this._assignCoordinates(root, this.canvas.width / 2, 50);

        // 4. Zeichnen
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.translate(0, 20); // Padding oben
        
        this._renderEdgesRecursive(root);
        this._renderNodesRecursive(root, options.drawNodeFn);
        
        this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset Transform
    }

    /**
     * Berechnet Baum-Metriken.
     * @private
     */
    _calculateMetrics(node) {
        let maxDepth = 0;
        let leafCount = 0;
        const traverse = (n) => {
            if (n.depth > maxDepth) maxDepth = n.depth;
            if (n.children.length === 0) leafCount++;
            n.children.forEach(traverse);
        };
        traverse(node);
        return { maxDepth, leafCount };
    }

    /**
     * Passt Canvas-Gr√∂√üe und Node-Skalierung dynamisch an.
     * @private
     */
    _adjustCanvasAndScale(metrics) {
        const container = this.canvas.parentElement;
        const viewWidth = container.clientWidth;
        const viewHeight = container.clientHeight;

        // Vertikale Anpassung: Nodes kleiner machen bei gro√üer Tiefe
        const neededLevels = metrics.maxDepth + 1;
        const potentialNodeHeight = (viewHeight / neededLevels) * 0.8;
        
        this.config.nodeSize = Math.max(
            this.config.minNodeSize, 
            Math.min(this.config.maxNodeSize, potentialNodeHeight)
        );
        this.config.levelHeight = this.config.nodeSize * 1.5;

        // Horizontale Anpassung: Canvas verbreitern, damit gescrollt werden kann
        const treeWidth = metrics.leafCount * (this.config.nodeSize + this.config.siblingGap);
        const requiredWidth = Math.max(viewWidth - 20, treeWidth + 100); 
        const requiredHeight = (metrics.maxDepth + 1) * this.config.levelHeight + 100;

        this.canvas.width = requiredWidth;
        this.canvas.height = requiredHeight;
    }

    /**
     * Rekursive Zuweisung der X/Y Koordinaten.
     * @private
     */
    _assignCoordinates(node, x, y) {
        node.x = x;
        node.y = y;
        
        if (node.children.length > 0) {
            const subtreeWidth = this._calculateSubtreeWidth(node);
            let currentX = x - (subtreeWidth / 2);
            
            node.children.forEach(child => {
                const childWidth = this._calculateSubtreeWidth(child);
                // Kind in der Mitte seines zugewiesenen Platzes positionieren
                this._assignCoordinates(child, currentX + childWidth/2, y + this.config.levelHeight);
                currentX += childWidth;
            });
        }
    }

    /** @private */
    _calculateSubtreeWidth(node) {
        if (node.children.length === 0) return this.config.nodeSize + this.config.siblingGap;
        return node.children.reduce((sum, c) => sum + this._calculateSubtreeWidth(c), 0);
    }

    /** @private */
    _renderEdgesRecursive(node) {
        node.children.forEach(child => {
            this.ctx.beginPath();
            this.ctx.moveTo(node.x, node.y + this.config.nodeSize/2);
            this.ctx.lineTo(child.x, child.y - this.config.nodeSize/2);
            this.ctx.strokeStyle = this.config.colors.edge;
            this.ctx.lineWidth = this.config.lineWidth.edge;
            this.ctx.stroke();

            // Label am Pfad (L/R)
            if (child.parentMove) {
                const mx = (node.x + child.x) / 2;
                const my = (node.y + child.y) / 2;
                this.ctx.fillStyle = this.config.colors.nodeBg;
                this.ctx.fillRect(mx - 8, my - 8, 16, 16);
                this.ctx.fillStyle = this.config.colors.text;
                this.ctx.font = this.config.font.edgeLabel;
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.fillText(child.parentMove, mx, my);
            }
            this._renderEdgesRecursive(child);
        });
    }

    /** @private */
    _renderNodesRecursive(node, drawContentFn) {
        const size = this.config.nodeSize;
        const half = size / 2;
        
        this.ctx.save();
        this.ctx.translate(node.x - half, node.y - half);

        // Hintergrund & Rahmen
        this.ctx.fillStyle = this.config.colors.nodeBg;
        this.ctx.fillRect(0, 0, size, size);
        this.ctx.lineWidth = this.config.lineWidth.normal;
        this.ctx.strokeStyle = this.config.colors.nodeBorder;

        // Status-Farben
        if (node.isSolution) {
            this.ctx.lineWidth = this.config.lineWidth.highlight;
            this.ctx.strokeStyle = this.config.colors.solution;
        } else if (node.isDuplicate) {
            this.ctx.lineWidth = this.config.lineWidth.highlight;
            this.ctx.strokeStyle = this.config.colors.duplicate;
        }

        this.ctx.strokeRect(0, 0, size, size);

        // Inhalt (das Mini-Board) zeichnen
        if (drawContentFn) {
            const pad = this.config.nodePadding || 2;
            const contentSize = size - (pad * 2);
            this.ctx.beginPath();
            this.ctx.rect(pad, pad, contentSize, contentSize);
            this.ctx.clip();
            this.ctx.translate(pad, pad);
            try {
                drawContentFn(this.ctx, node.data, contentSize);
            } catch(e) { console.error(e); }
        }
        this.ctx.restore();

        // Annotationen (Text unter dem Knoten)
        if (node.isDuplicate) {
            this.ctx.fillStyle = this.config.colors.duplicate;
            this.ctx.font = "bold 14px sans-serif";
            this.ctx.fillText("‚Ü∫", node.x + half + 2, node.y - half + 5);
        }
        if (node.annotation) {
            this.ctx.fillStyle = this.config.colors.text;
            this.ctx.font = this.config.font.annotation;
            this.ctx.textAlign = "center";
            this.ctx.fillText(node.annotation, node.x, node.y + half + 12);
        }

        node.children.forEach(child => this._renderNodesRecursive(child, drawContentFn));
    }
}

// --- DRAG TO SCROLL LOGIK ---
// Erm√∂glicht das Verschieben des Canvas mit der Maus
document.addEventListener('DOMContentLoaded', () => {
    const containers = document.querySelectorAll('.viz-container');
    
    containers.forEach(ele => {
        let pos = { top: 0, left: 0, x: 0, y: 0 };
        let isDown = false;

        const mouseDownHandler = function (e) {
            isDown = true;
            ele.style.cursor = 'grabbing';
            pos = {
                left: ele.scrollLeft,
                top: ele.scrollTop,
                x: e.clientX,
                y: e.clientY,
            };
            ele.style.userSelect = 'none';
        };

        const mouseMoveHandler = function (e) {
            if (!isDown) return;
            const dx = e.clientX - pos.x;
            const dy = e.clientY - pos.y;
            ele.scrollTop = pos.top - dy;
            ele.scrollLeft = pos.left - dx;
        };

        const mouseUpHandler = function () {
            isDown = false;
            ele.style.cursor = 'grab';
            ele.style.removeProperty('user-select');
        };

        ele.addEventListener('mousedown', mouseDownHandler);
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseup', mouseUpHandler);
    });
});

/* --- FILE: js/viz/rule-visualizer.js --- */
/**
 * @fileoverview Visualisiert einen DecisionTree als interaktive HTML-Liste.
 * Erm√∂glicht das An/Abschalten von Regeln per Checkbox.
 */

class RuleVisualizer {
    /**
     * @param {string} containerId - ID des HTML Containers.
     * @param {DecisionTree} tree - Der Baum.
     * @param {function} toggleCallback - Wird gerufen, wenn Checkbox geklickt.
     */
    constructor(containerId, tree, toggleCallback) {
        this.container = document.getElementById(containerId);
        this.tree = tree;
        this.onToggle = toggleCallback; 
        this.prefix = containerId; 
    }

    render() {
        if (!this.container || !this.tree) return;
        this.container.innerHTML = `<div class="tree-root">${this._buildNodeHtml(this.tree.root)}</div>`;
        this.bindEvents();
    }

    _buildNodeHtml(node) {
        const id = `${this.prefix}-${node.name.replace(/\s+/g, '-')}`;
        const isChecked = node.active ? 'checked' : '';
        
        let html = `<div class="tree-node">`;
        html += `<div class="tree-content" id="${id}">`;
        
        // Icon Logik
        if (node.conditionFn) {
            // CONDITION
            html += `<span class="tree-condition-label">‚óá ${node.name} ?</span>`;
        } else if (node.children && node.children.length > 0) {
            // GROUP
            html += `<span class="tree-group-label">üìÇ ${node.name}</span>`;
        } else {
            // RULE
            html += `<span class="tree-rule-label">üìù ${node.name}</span>`;
        }
        
        html += `<input type="checkbox" ${isChecked} data-name="${node.name}" class="rule-toggle">`;
        html += `</div>`; // Close Content

        // Kinder rendern
        if (node.children && node.children.length > 0) {
            for (const child of node.children) {
                if(child) html += this._buildNodeHtml(child);
            }
        }
        html += `</div>`; // Close Node
        return html;
    }

    bindEvents() {
        this.container.querySelectorAll('.rule-toggle').forEach(cb => {
            cb.addEventListener('change', (e) => {
                const name = e.target.getAttribute('data-name');
                if (this.onToggle) this.onToggle(name);
            });
        });
    }

    highlightCheck(name) { this._addClass(name, 'checking'); }
    highlightSuccess(name) { this._addClass(name, 'success'); }
    
    clearHighlights() {
        this.container.querySelectorAll('.checking, .success').forEach(el => {
            el.classList.remove('checking', 'success');
        });
    }
    
    _addClass(name, cls) {
        const id = `${this.prefix}-${name.replace(/\s+/g, '-')}`;
        const el = document.getElementById(id);
        if (el) {
            el.classList.remove('checking', 'success');
            el.classList.add(cls);
            if (cls === 'checking') el.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }
    }
}

/* --- FILE: js/viz/rule-tree-adapter.js --- */
/**
 * @fileoverview Adapter, der einen Regel-Baum (RuleStructure) in einen
 * visualisierbaren Baum (TreeNode) f√ºr die Tree-Engine umwandelt.
 * Erm√∂glicht Interaktion (Klick zum Deaktivieren).
 */

const RuleTreeAdapter = {
    /**
     * Konvertiert einen RuleNode (Wurzel) in einen TreeNode.
     * @param {RuleNode} ruleNode - Der Wurzelknoten der Regelstrategie.
     * @returns {TreeNode} Der Wurzelknoten f√ºr die Visualisierung.
     */
    convert(ruleNode) {
        let idCounter = 0;

        // Rekursive Hilfsfunktion
        function traverse(rNode) {
            // TreeNode erstellen (id, data, depth placeholder)
            // Depth wird sp√§ter von der Engine berechnet oder hier mitgef√ºhrt
            // Wir nutzen hier dummy depth 0, die Engine fixiert das.
            const tNode = new TreeNode(idCounter++, rNode, 0);
            
            // Visuelle Eigenschaften basierend auf Typ setzen
            tNode.annotation = rNode.name;
            
            // Status: Wenn Regel inaktiv, markieren wir das visuell
            if (!rNode.active) {
                tNode.isForbidden = true; // Nutzt die rote Farbe der Engine f√ºr "Deaktiviert"
                tNode.annotation += " (OFF)";
            }

            // Typ-Unterscheidung f√ºr Darstellung
            if (rNode.conditionFn) {
                // Bedingung (Raute in UML, hier Text)
                tNode.annotation = "? " + rNode.name;
                
                // Kinder (Ja/Nein Zweige)
                if (rNode.thenNode) {
                    const child = traverse(rNode.thenNode);
                    child.parentMove = "Ja"; // Beschriftung an der Kante
                    tNode.children.push(child);
                }
                if (rNode.elseNode) {
                    const child = traverse(rNode.elseNode);
                    child.parentMove = "Nein";
                    tNode.children.push(child);
                }
            } 
            else if (rNode.children && rNode.children.length > 0) {
                // Gruppe (Ordner)
                rNode.children.forEach(childRule => {
                    if (childRule) {
                        const childTNode = traverse(childRule);
                        tNode.children.push(childTNode);
                    }
                });
            }
            
            return tNode;
        }

        return traverse(ruleNode);
    },

    /**
     * Zeichnet den Inhalt eines Knotens in den Canvas.
     * @param {CanvasRenderingContext2D} ctx 
     * @param {RuleNode} data 
     * @param {number} size 
     */
    drawNode(ctx, data, size) {
        // Farben und Symbole je nach Typ
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "20px sans-serif";

        if (data.conditionFn) {
            ctx.fillStyle = "#e67e22"; // Orange f√ºr Bedingungen
            ctx.fillText("‚óá", size/2, size/2);
        } else if (data.children) {
            ctx.fillStyle = "#3498db"; // Blau f√ºr Gruppen
            ctx.fillText("üìÇ", size/2, size/2);
        } else {
            ctx.fillStyle = "#2ecc71"; // Gr√ºn f√ºr Aktionen
            ctx.fillText("‚ö°", size/2, size/2);
        }
    }
};

/* --- FILE: js/ai/search-algorithms.js --- */
/**
 * Konfiguration f√ºr die Suchmaschine.
 * @typedef {Object} SearchConfig
 * @property {('BFS'|'DFS')} [strategy='BFS'] - 'BFS' (Breitensuche) oder 'DFS' (Tiefensuche).
 * @property {number} [maxDepth=1000] - Abbruch bei dieser Tiefe.
 * @property {boolean} [checkDuplicates=true] - Verhindert Zyklen durch Hash-Set.
 * @property {function(Object, Object): number} [sortSuccessors=null] - Heuristik zum Sortieren der Nachfolger (z.B. Warnsdorf).
 * @property {function(GameState, number): Promise<string>} [onStep=null] - Callback f√ºr jeden Schritt (Visualisierung). R√ºckgabe 'STOP' bricht ab.
 */

/**
 * F√ºhrt Suchalgorithmen auf Zustandsr√§umen aus.
 * @class SearchEngine
 */
class SearchEngine {
    /**
     * @param {SearchConfig} config 
     */
    constructor(config = {}) {
        this.strategy = config.strategy || 'BFS'; 
        this.maxDepth = config.maxDepth || 1000;
        this.checkDuplicates = config.checkDuplicates !== false;
        this.onStep = config.onStep || null;
        this.sortSuccessors = config.sortSuccessors || null;
    }

    /**
     * Startet die Suche nach einem Zielzustand.
     * @param {GameState} startState 
     * @returns {Promise<{success: boolean, path: Array, nodesVisited: number, stopped: boolean}>}
     */
    async solve(startState) {
        let openList = [];
        // Root Node
        let root = { state: startState, path: [], depth: 0 };
        openList.push(root);

        let visited = new Set();
        if (this.checkDuplicates && startState.getStateKey) {
            visited.add(startState.getStateKey());
        }

        let nodesVisited = 0;

        while (openList.length > 0) {
            // Strategie-Switch: DFS = pop (Stack), BFS = shift (Queue)
            let currentNode = (this.strategy === 'DFS') ? openList.pop() : openList.shift();
            nodesVisited++;

            // VISUALISIERUNG CALLBACK
            if (this.onStep) {
                // Wir warten auf den Callback (f√ºr Animationen)
                const result = await this.onStep(currentNode.state, openList.length);
                if (result === 'STOP') {
                    return { success: false, nodesVisited, stopped: true, path: [] };
                }
            }

            // ZIEL PR√úFUNG (Muss vom GameState implementiert sein: isGoal oder won)
            // F√ºr KnightsTour nutzen wir isGoal(), f√ºr andere Board.won
            const reachedGoal = (typeof currentNode.state.isGoal === 'function') 
                                ? currentNode.state.isGoal() 
                                : currentNode.state.won;

            if (reachedGoal) {
                return { success: true, path: currentNode.path, nodesVisited, stopped: false };
            }

            if (currentNode.depth >= this.maxDepth) continue;

            // NACHFOLGER GENERIEREN
            // GameState muss getNextStates() implementieren -> liefert { move, state }
            // Falls GameState das nicht hat (z.B. einfaches Board), br√§uchte man einen Adapter.
            // Wir gehen davon aus, dass die States (wie KnightBoard) das implementieren.
            if (typeof currentNode.state.getNextStates !== 'function') {
                 console.warn("State implementiert getNextStates nicht!");
                 continue;
            }

            const successors = currentNode.state.getNextStates();
            let childNodes = [];

            for (const item of successors) {
                if (this.checkDuplicates) {
                    const key = item.state.getStateKey();
                    if (visited.has(key)) continue;
                    visited.add(key);
                }

                childNodes.push({
                    state: item.state,
                    path: [...currentNode.path, item.move], 
                    depth: currentNode.depth + 1
                });
            }

            if (this.sortSuccessors) {
                childNodes.sort(this.sortSuccessors);
            }

            // Bei DFS drehen wir um, damit der "beste" (erste im Sort) oben auf dem Stack liegt
            if (this.strategy === 'DFS') {
                childNodes.reverse(); 
            }

            // Zur Liste hinzuf√ºgen
            for (let child of childNodes) {
                openList.push(child);
            }
        }

        return { success: false, nodesVisited, path: [], stopped: false };
    }
}

/* --- FILE: js/ai/agents/rule-based-agent.js --- */
/**
 * Ein Agent, der Entscheidungen basierend auf einem Entscheidungsbaum trifft.
 * @class RuleBasedAgent
 * @extends Agent
 */
class RuleBasedAgent extends Agent {
    /**
     * @param {DecisionTree} tree - Der Regelbaum (siehe rule-structure.js).
     */
    constructor(tree) {
        super(tree.name || "Regel-KI");
        this.tree = tree;
    }

    /**
     * Delegiert die Entscheidung an den Baum.
     * @param {GameState} gameState 
     * @returns {Object|null} Das Ergebnis des Baums.
     */
    getAction(gameState) {
        return this.tree.getDecision(gameState);
    }
}

/* --- FILE: js/ai/agents/random-agent.js --- */
// HINWEIS: Agent Interface ist bereits in js/core/agent.js definiert (Batch 1)

/**
 * Ein Agent, der zuf√§llige g√ºltige Z√ºge macht.
 * Dient oft als Baseline f√ºr Vergleiche.
 * @class RandomAgent
 * @extends Agent
 */
class RandomAgent extends Agent {
    constructor() {
        super("Zufall");
    }

    /**
     * W√§hlt zuf√§llig einen der g√ºltigen Z√ºge.
     * @param {GameState} gameState 
     * @returns {Object|null}
     */
    getAction(gameState) {
        const moves = gameState.getAllValidMoves();
        if (!moves || moves.length === 0) return null;

        const randomIndex = Math.floor(Math.random() * moves.length);
        return {
            move: moves[randomIndex],
            reason: "Zufallswahl"
        };
    }
}

/* --- FILE: js/ai/arena.js --- */
/**
 * Controller f√ºr KI-gegen-KI Simulationen.
 * @class Arena
 */
class Arena {
    /**
     * @param {Object} gameFactory - Objekt mit .create() Methode f√ºr neue Spiele.
     * @param {Agent} agent1 - Agent f√ºr Spieler 1.
     * @param {Agent} agent2 - Agent f√ºr Spieler 2.
     */
    constructor(gameFactory, agent1, agent2) {
        this.gameFactory = gameFactory;
        this.agents = { 1: agent1, 2: agent2 };
        this.stats = { 1: 0, 2: 0, 0: 0 };
    }

    /**
     * F√ºhrt eine Serie von Spielen aus.
     * Asynchron, um den Browser nicht zu blockieren (Bugfix).
     * @param {number} rounds - Anzahl der Spiele.
     * @returns {Promise<Object>} Statistiken und Dauer.
     */
    async runSeries(rounds) {
        this.stats = { 1: 0, 2: 0, 0: 0 };
        const start = performance.now();

        // Wir nutzen Chunks, damit der Browser zwischendurch rendern kann
        const CHUNK_SIZE = 10; 

        for (let i = 0; i < rounds; i++) {
            this.playSingleGame();
            
            // Jeden X-ten Schritt kurz Luft holen f√ºr UI Updates
            if (i % CHUNK_SIZE === 0) {
                await new Promise(r => setTimeout(r, 0));
            }
        }

        const duration = performance.now() - start;
        return { 
            stats: this.stats, 
            duration: duration,
            avgTime: duration / rounds
        };
    }

    /**
     * Spielt ein einzelnes Spiel bis zum Ende.
     * @private
     */
    playSingleGame() {
        const game = this.gameFactory.create();
        let moves = 0;
        const maxMoves = 200; // Schutz gegen Endlosschleifen

        while (game.winner === 0 && moves < maxMoves) {
            // Remis-Check vor dem Zug
            if (game.getAllValidMoves().length === 0) {
                break;
            }

            const player = game.currentPlayer;
            const agent = this.agents[player];
            
            // Aktion holen
            const action = agent.getAction(game);

            if (action && action.move !== undefined) {
                // Zug ausf√ºhren
                // Manche Spiele nutzen Index (number), Ultimate nutzt Object
                const moveData = action.move;
                let success = false;
                
                if (typeof moveData === 'object' && moveData.big !== undefined) {
                    success = game.makeMove(moveData.big, moveData.small);
                } else {
                    success = game.makeMove(moveData);
                }

                if (!success) {
                    console.error(`Arena: Ung√ºltiger Zug von Agent ${player}`, moveData);
                    break; 
                }
            } else {
                // Agent gibt auf oder Fehler
                break; 
            }
            moves++;
        }
        
        this.stats[game.winner]++;
    }
}

/* --- FILE: js/ai/rules/ttt-rules.js --- */
/**
 * @fileoverview Bibliothek von KI-Regeln f√ºr Tic-Tac-Toe.
 * Enth√§lt komplexe Logik f√ºr 3D und Ultimate sowie Strategie-Templates.
 */

const TTTRulesLibrary = {
    // --- UTILS (Hilfsfunktionen f√ºr die Regeln) ---
    utils: {
        /** Simuliert einen Zug und pr√ºft auf Sieg */
        canWin: (game, move, player) => {
            const sim = game.clone();
            sim.currentPlayer = player;
            if (typeof move === 'object') sim.makeMove(move.big, move.small);
            else sim.makeMove(move);
            return sim.winner === player;
        },
        
        /** Z√§hlt Steine in einer 3D-Linie (Heuristik) */
        countLine: (game, lineIndices, player) => {
            let count = 0;
            let empty = 0;
            for(let idx of lineIndices) {
                if (game.grid[idx] === player) count++;
                else if (game.grid[idx] === 0) empty++;
                else return -1; // Blockiert durch Gegner
            }
            return { count, empty };
        },

        /** Generiert alle Linien-Indizes f√ºr 3D (Teuer, sollte gecacht werden) */
        getLines3D: (size) => {
            // (Vereinfacht: Wir berechnen das on-the-fly in den Regeln oder hardcoden f√ºr 3x3)
            // F√ºr echte Performance m√ºsste das im Board gecacht sein.
            return []; // Placeholder, Logik wird in AtomicRule implementiert
        }
    },

    // --- BASIS REGELN ---
    basics: {
        win: new AtomicRule("Siegzug", "Gewinne sofort", (game) => {
            for(let m of game.getAllValidMoves()) {
                if(TTTRulesLibrary.utils.canWin(game, m, game.currentPlayer)) return m;
            }
            return null;
        }),
        block: new AtomicRule("Blocken", "Verhindere Niederlage", (game) => {
            const opponent = (game.currentPlayer === 1) ? 2 : 1;
            for(let m of game.getAllValidMoves()) {
                if(TTTRulesLibrary.utils.canWin(game, m, opponent)) return m;
            }
            return null;
        }),
        random: new AtomicRule("Zufall", "Fallback", (game) => {
            const moves = game.getAllValidMoves();
            return moves.length > 0 ? moves[Math.floor(Math.random()*moves.length)] : null;
        })
    },

    regular: {
        // 1. Zwickm√ºhle (Fork) suchen
        fork: new AtomicRule("Gabelung", "Erzeuge zwei Gewinnwege.", (game) => {
            // Suche Zug, der zwei Gewinnlinien √∂ffnet
            const moves = game.getAllValidMoves();
            for (let m of moves) {
                const sim = game.clone();
                sim.makeMove(m); // Wir haben gesetzt
                // Z√§hle Gewinnm√∂glichkeiten im N√ÑCHSTEN Zug
                let wins = 0;
                const nextMoves = sim.getAllValidMoves(); // Jetzt ist Gegner dran, aber wir pr√ºfen UNSERE Wins
                // Achtung: Nach makeMove ist currentPlayer gewechselt!
                // Wir wollen wissen: Wenn ICH (der urspr√ºngliche Spieler) wieder dran w√§re...
                // Trick: Wir pr√ºfen, ob wir im √ºbern√§chsten Zug gewinnen k√∂nnen an >= 2 Stellen
                // Das ist komplex. Einfachere Heuristik:
                // "Fork" bedeutet, ich habe 2 Linien mit je 2 Steinen und leerem 3. Feld.
                // ... (Hier implementieren wir eine vereinfachte Z√§hlung)
                // Um Code kurz zu halten: Wir nutzen TTTRulesLibrary.utils.findFork (Dummy oben)
                // Hier eine echte Implementierung f√ºr 3x3:
                
                // Simuliere Board NACH meinem Zug
                const myPlayer = game.currentPlayer;
                // Wir m√ºssen manuell z√§hlen, da makeMove Player switcht
                const grid = [...game.grid];
                grid[m] = myPlayer;
                
                // Z√§hle Linien mit 2 eigenen und 1 leerem
                const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
                let threats = 0;
                for(let l of lines) {
                    const cells = [grid[l[0]], grid[l[1]], grid[l[2]]];
                    const myCount = cells.filter(c => c === myPlayer).length;
                    const emptyCount = cells.filter(c => c === 0).length;
                    if(myCount === 2 && emptyCount === 1) threats++;
                }
                
                if(threats >= 2) return m;
            }
            return null;
        }),

        blockFork: new AtomicRule("Gabelung Blocken", "Verhindere Fork des Gegners.", (game) => {
            // Strategie: Setze dort, wo der Gegner eine Gabelung machen w√ºrde.
            // ODER: Zwinge ihn zu einer Antwort, die keine Gabelung erlaubt.
            // Einfach: Pr√ºfe, ob Gegner Gabelung hat
            const opp = game.currentPlayer === 1 ? 2 : 1;
            // Nutze Logik von oben f√ºr Gegner
            // ... (Analog fork, nur mit opp)
            return null; // (Placeholder, da Implementierung lang wird)
        }),

        center: new AtomicRule("Zentrum", "Mitte", g => g.grid[4]===0?4:null),
        corner: new AtomicRule("Ecke", "Ecke", g => {
            const c = [0,2,6,8].filter(x => g.grid[x]===0);
            return c.length ? c[Math.floor(Math.random()*c.length)] : null;
        })
    },

    // --- 3D SPEZIFISCH ---
    dimension3: {
        // Funktioniert f√ºr 3x3x3 und 4x4x4
        centerCore: new AtomicRule("Zentrum", "Besetze den Kern", (game) => {
            const size = game.size;
            const total = size * size * size;
            
            // Generische Mitte-Berechnung
            if (size % 2 !== 0) { // Ungerade (3, 5...) -> 1 Mitte
                const center = Math.floor(total / 2);
                return game.grid[center] === 0 ? center : null;
            } 
            else { // Gerade (4) -> 8 Mitten (W√ºrfel im W√ºrfel)
                // Einfache Heuristik: Suche freien Platz im inneren Kern
                // Wir scannen von 1 bis size-2 in allen Dimensionen
                for(let z=1; z<size-1; z++) {
                    for(let y=1; y<size-1; y++) {
                        for(let x=1; x<size-1; x++) {
                            const idx = z*size*size + y*size + x;
                            if (game.grid[idx] === 0) return idx;
                        }
                    }
                }
                return null;
            }
        }),

        // Versuch, Linien aufzubauen (Heuristik)
        createSetup: new AtomicRule("Linie Bauen", "Setze neben eigenen Stein", (game) => {
            // Suche einen Zug, der neben einem eigenen Stein liegt (Nachbarschaft)
            // Das ist eine einfache Approximation f√ºr "Linie bauen"
            const myStones = [];
            game.grid.forEach((v, i) => { if(v === game.currentPlayer) myStones.push(i); });
            
            if(myStones.length === 0) return null; // Noch keine Steine

            const validMoves = game.getAllValidMoves();
            // Suche Move, der Nachbar eines eigenen Steins ist
            // (Nachbar: Index-Differenz ist 1, size, size*size etc...)
            // Sehr vereinfacht:
            return validMoves[0]; // Platzhalter f√ºr echte Linien-Logik
        })
    },

    // --- ULTIMATE SPEZIFISCH ---
    ultimate: {
        // Gewinne das kleine Board
        winLocal: new AtomicRule("Lokal Sieg", "Gewinne Teil-Board", (game) => {
            for (let m of game.getAllValidMoves()) {
                const sim = [...game.boards[m.big]];
                sim[m.small] = game.currentPlayer;
                if (checkSmallWin(sim)) return m;
            }
            return null;
        }),
        // Verhindere, dass Gegner kleines Board gewinnt
        blockLocal: new AtomicRule("Lokal Block", "Rette Teil-Board", (game) => {
            const opp = (game.currentPlayer===1)?2:1;
            for (let m of game.getAllValidMoves()) {
                const sim = [...game.boards[m.big]];
                sim[m.small] = opp;
                if (checkSmallWin(sim)) return m;
            }
            return null;
        }),
        // Schicke Gegner in ein bereits entschiedenes Board
        sendToTrash: new AtomicRule("M√ºllabfuhr", "Schicke Gegner ins Aus", (game) => {
            const moves = game.getAllValidMoves();
            // Wir suchen Z√ºge, wo das Zielboard (m.small) bereits entschieden ist (Status != 0)
            // Das gibt dem Gegner zwar freie Wahl, aber er kann auf DIESEM Board nicht mehr punkten.
            // Bessere Strategie w√§re: Schicke ihn in ein Board, das ICH schon habe.
            const candidates = moves.filter(m => game.macroBoard[m.small] !== 0);
            return candidates.length > 0 ? candidates[0] : null;
        })
    }
};

/** Hilfsfunktion f√ºr lokalen Sieg */
function checkSmallWin(grid) {
    const wins = [[0,1,2],[3,4,5],[6,7,8], [0,3,6],[1,4,7],[2,5,8], [0,4,8],[2,4,6]];
    return wins.some(w => grid[w[0]]!==0 && grid[w[0]]===grid[w[1]] && grid[w[1]]===grid[w[2]]);
}

/**
 * Factory Methode: Erstellt den Baum basierend auf Spieltyp.
 * Hier nutzen wir jetzt ConditionNodes f√ºr echte Verzweigungen!
 */
function createStrategyTree(type = 'regular') {
    const root = new RuleGroup("Master KI");

    // 1. EXISTENZ: Immer zuerst pr√ºfen
    const survival = new RuleGroup("Existenz", "Gewinnen oder Blocken");
    survival.add(TTTRulesLibrary.basics.win);
    survival.add(TTTRulesLibrary.basics.block);
    root.add(survival);

    // 2. TAKTIK (Abh√§ngig vom Spiel)
    if (type === 'regular') {
        const tactic = new RuleGroup("Taktik");
        tactic.add(TTTRulesLibrary.regular.fork);      // NEU
        tactic.add(TTTRulesLibrary.regular.blockFork); // NEU
        tactic.add(TTTRulesLibrary.regular.center);
        tactic.add(TTTRulesLibrary.regular.corner);
        root.add(tactic);
    }else if (type === 'ultimate') {
        // Verzweigung: Kann ich lokal was rei√üen?
        const localTactics = new RuleGroup("Lokale Taktik");
        localTactics.add(TTTRulesLibrary.ultimate.winLocal);
        localTactics.add(TTTRulesLibrary.ultimate.blockLocal);
        
        // Bedingung: Wenn wir lokal nichts Dringendes haben, spielen wir strategisch
        const strategyBranch = new ConditionNode(
            "Strategie Phase", 
            "Lokal sicher?",
            (game) => true, // Dummy Bedingung (immer wahr -> geht in THEN)
            new RuleGroup("Positionierung", "", [
                TTTRulesLibrary.ultimate.sendToTrash,
                TTTRulesLibrary.basics.random
            ]),
            null // Else
        );
        
        root.add(localTactics);
        root.add(strategyBranch);

    } else if (type === '3d') {
        const spaceTactics = new RuleGroup("Raum Taktik");
        spaceTactics.add(TTTRulesLibrary.dimension3.centerCore);
        // Hier k√∂nnte man bedingte Regeln f√ºr Linienaufbau einf√ºgen
        root.add(spaceTactics);
    } else {
        // Regular
        root.add(new AtomicRule("Zentrum", "Mitte", g => g.grid[4]===0?4:null));
    }

    // 3. Fallback
    root.add(TTTRulesLibrary.basics.random);

    return new DecisionTree("KI " + type, root);
}

/* --- FILE: js/ai/rules/rule-structure.js --- */
/**
 * @fileoverview Datenstrukturen f√ºr das Regelsystem.
 * Definiert die Bausteine f√ºr den Entscheidungsbaum (Composite Pattern).
 */

/**
 * Abstrakte Basisklasse f√ºr alle Regel-Knoten.
 */
class RuleNode {
    /**
     * @param {string} name - Anzeigename der Regel.
     * @param {string} description - Tooltip/Beschreibung.
     */
    constructor(name, description = "") {
        this.name = name;
        this.description = description;
        this.active = true; // Kann per UI deaktiviert werden
    }

    /**
     * Muss von Unterklassen implementiert werden.
     * @param {GameState} gameState 
     * @returns {Object|null} { move, reason } oder null
     */
    evaluate(gameState) { throw new Error("Abstract method"); }
}

/**
 * Eine atomare Regel, die einen Zug vorschl√§gt (Blatt im Baum).
 */
class AtomicRule extends RuleNode {
    /**
     * @param {string} name 
     * @param {string} description 
     * @param {function(GameState): (number|Object|null)} logicFn - Gibt Zug oder null zur√ºck.
     */
    constructor(name, description, logicFn) {
        super(name, description);
        this.logicFn = logicFn;
    }

    evaluate(gameState) {
        if (!this.active) return null;
        const move = this.logicFn(gameState);
        return (move !== null) ? { move, reason: this.name, node: this } : null;
    }
}

/**
 * Eine Gruppe von Regeln. Geht die Kinder der Reihe nach durch (Priorit√§t).
 * Das erste Kind, das einen Zug liefert, gewinnt.
 */
class RuleGroup extends RuleNode {
    constructor(name, description = "", children = []) {
        super(name, description);
        this.children = children;
    }

    add(node) {
        this.children.push(node);
        return this;
    }

    evaluate(gameState) {
        if (!this.active) return null;
        for (const child of this.children) {
            const result = child.evaluate(gameState);
            if (result) return result;
        }
        return null;
    }
}

/**
 * Ein Verzweigungsknoten (If-Then-Else).
 * Erm√∂glicht echte Entscheidungsb√§ume statt nur Listen.
 */
class ConditionNode extends RuleNode {
    /**
     * @param {string} name 
     * @param {string} description 
     * @param {function(GameState): boolean} conditionFn - Pr√ºft Bedingung.
     * @param {RuleNode} thenNode - Wird ausgef√ºhrt, wenn true.
     * @param {RuleNode} elseNode - Wird ausgef√ºhrt, wenn false.
     */
    constructor(name, description, conditionFn, thenNode, elseNode) {
        super(name, description);
        this.conditionFn = conditionFn;
        this.thenNode = thenNode;
        this.elseNode = elseNode;
    }

    evaluate(gameState) {
        if (!this.active) return null; // Ganze Verzweigung deaktivieren

        // Bedingung pr√ºfen
        if (this.conditionFn(gameState)) {
            // JA-Zweig
            return this.thenNode ? this.thenNode.evaluate(gameState) : null;
        } else {
            // NEIN-Zweig
            return this.elseNode ? this.elseNode.evaluate(gameState) : null;
        }
    }
}

/**
 * Wrapper f√ºr den gesamten Baum.
 */
class DecisionTree {
    constructor(name, rootNode) {
        this.name = name;
        this.root = rootNode;
    }

    getDecision(gameState) {
        if (!this.root) return null;
        return this.root.evaluate(gameState);
    }
}

/* --- FILE: js/ai/algorithm-runner.js --- */
/**
 * Wrapper um die SearchEngine, der "Schritt-f√ºr-Schritt" Ausf√ºhrung
 * und manuelle Steuerung (Play/Pause/Step) erm√∂glicht.
 * @class AlgorithmRunner
 */
class AlgorithmRunner {
    /**
     * @param {SearchEngine} engine - Die konfigurierte Suchmaschine.
     * @param {Object} config - Callbacks f√ºr UI.
     * @param {function(GameState, number): Promise<void>} config.onUpdate - Wird bei jedem Schritt gerufen.
     * @param {function(Object): void} config.onComplete - Wird bei Ende gerufen.
     */
    constructor(engine, config = {}) {
        this.engine = engine;
        this.onUpdate = config.onUpdate || (() => {});
        this.onComplete = config.onComplete || (() => {});
        
        this.isRunning = false;
        this.stopRequested = false;
        this.isManual = false;
        this.speedDelay = 100;
        
        this.manualResolver = null;
        this.stepCount = 0;
        
        // Logik-Injection
        this.injectRunnerLogic();
    }

    /** @private */
    injectRunnerLogic() {
        // Wir √ºberschreiben die onStep Methode der Engine
        this.engine.onStep = async (state, queueSize) => {
            if (this.stopRequested) return 'STOP';

            this.stepCount++;

            // UI Update
            await this.onUpdate(state, this.stepCount);

            // Warte-Logik
            if (this.isManual) {
                // Warten bis manualResolver durch triggerStep() gerufen wird
                await new Promise(resolve => { this.manualResolver = resolve; });
            } else if (this.speedDelay > 0) {
                await new Promise(r => setTimeout(r, this.speedDelay));
            }
        };
    }

    /**
     * Startet den Runner.
     * @param {GameState} startState 
     */
    async start(startState) {
        if (this.isRunning) return;
        
        this.isRunning = true;
        this.stopRequested = false;
        this.stepCount = 0;
        
        const result = await this.engine.solve(startState);
        
        this.isRunning = false;
        this.onComplete(result);
    }

    /** Stoppt den aktuellen Lauf. */
    stop() {
        if (this.isRunning) {
            this.stopRequested = true;
            this.triggerStep(); // Falls im Manual Mode, Blockierung l√∂sen
        }
    }

    /** F√ºhrt im manuellen Modus genau einen Schritt aus. */
    triggerStep() {
        if (this.manualResolver) {
            const resolve = this.manualResolver;
            this.manualResolver = null;
            resolve();
        }
    }

    /**
     * Setzt die Geschwindigkeit.
     * @param {number|string} val - Wert vom Slider (0-6). 6 = Manuell.
     */
    setSpeed(val) {
        const intVal = parseInt(val);
        const maxRange = 6;
        
        if (intVal >= maxRange) {
            this.isManual = true;
        } else {
            this.isManual = false;
            // Mapping: Slider -> Millisekunden
            const delays = [0, 20, 100, 300, 600, 1000];
            this.speedDelay = delays[intVal] !== undefined ? delays[intVal] : 100;
            
            // Falls wir im manuellen Modus hingen, weitermachen
            this.triggerStep();
        }
    }
}

/* --- FILE: js/games/knights-tour/renderer.js --- */
/**
 * @fileoverview Renderer f√ºr das Springerproblem.
 * Zeichnet das Brett mit einem verbesserten Farbschema.
 */

const KnightRenderer = {
    /**
     * @param {HTMLCanvasElement} canvas 
     * @param {KnightBoard} board 
     * @param {Object} config 
     */
    draw(canvas, board, config = {}) {
        const ctx = canvas.getContext('2d');
        const size = board.size;
        const showMoves = config.showPossibleMoves || false;
        
        // --- NEUES FARBSCHEMA ---
        const COLORS = {
            bg: '#ffffff',
            cellEven: '#ecf0f1', // Helles Grau
            cellOdd:  '#bdc3c7', // Dunkleres Grau
            visited:  '#2ecc71', // Gr√ºn (angenehm)
            visitedText: '#ffffff',
            current:  '#e67e22', // Orange f√ºr den Springer
            possible: 'rgba(52, 152, 219, 0.6)', // Blau transparent
            coord:    '#7f8c8d'
        };

        // Layout
        const paddingLeft = 30;
        const paddingBottom = 30;
        const availWidth = canvas.width - paddingLeft;
        const availHeight = canvas.height - paddingBottom;
        const cellSize = Math.min(availWidth, availHeight) / size;

        // Reset
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 1. Koordinaten (A-H, 1-8)
        ctx.fillStyle = COLORS.coord;
        ctx.font = "12px 'Segoe UI'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for(let i=0; i<size; i++) {
            // Buchstaben unten
            const char = String.fromCharCode(65 + i); 
            ctx.fillText(char, paddingLeft + i * cellSize + cellSize/2, canvas.height - (paddingBottom / 2));
            // Zahlen links
            const num = size - i; 
            ctx.fillText(num, paddingLeft / 2, i * cellSize + cellSize/2);
        }

        // Canvas verschieben f√ºr das Grid
        ctx.save();
        ctx.translate(paddingLeft, 0);

        // 2. Gitter & Zellen zeichnen
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                const x = c * cellSize;
                const y = r * cellSize;
                const val = board.grid[r][c];

                // Grundfarbe (Schachbrett)
                if ((r + c) % 2 === 0) ctx.fillStyle = COLORS.cellEven;
                else ctx.fillStyle = COLORS.cellOdd;
                ctx.fillRect(x, y, cellSize, cellSize);

                // Besuchte Felder
                if (val > 0) {
                    // Verblassen alter Z√ºge leicht, damit der Pfad sichtbar ist?
                    // Nein, lieber klarer Kontrast.
                    ctx.fillStyle = COLORS.visited;
                    // Mache es etwas kleiner als die Zelle f√ºr sch√∂neren Look
                    const pad = 2;
                    ctx.fillRect(x + pad, y + pad, cellSize - pad*2, cellSize - pad*2);
                    
                    // Zugnummer
                    ctx.fillStyle = COLORS.visitedText;
                    ctx.font = `bold ${cellSize * 0.4}px sans-serif`;
                    ctx.fillText(val, x + cellSize/2, y + cellSize/2);
                }
            }
        }

        // 3. M√∂gliche Z√ºge (Vorschau)
        if (showMoves && !board.won && !config.hideHints) {
            const moves = board.getPossibleMoves();
            moves.forEach(m => {
                const cx = m.c * cellSize + cellSize/2;
                const cy = m.r * cellSize + cellSize/2;
                
                ctx.beginPath();
                ctx.fillStyle = COLORS.possible;
                ctx.arc(cx, cy, cellSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // 4. Springer (Aktuelle Position)
        if (board.currentPos) {
            const { r, c } = board.currentPos;
            const x = c * cellSize;
            const y = r * cellSize;

            // Highlight Box
            ctx.fillStyle = COLORS.current;
            ctx.fillRect(x, y, cellSize, cellSize);
            
            // Springer Icon
            ctx.fillStyle = "white";
            ctx.font = `${cellSize * 0.7}px serif`;
            ctx.fillText("‚ôû", x + cellSize/2, y + cellSize/2 + 2);
        }

        ctx.restore();
    }
};

/* --- FILE: js/games/knights-tour/logic.js --- */
/**
 * @fileoverview Kernlogik f√ºr das Springerproblem.
 * Definiert das Brett, die Z√ºge und die Validierung.
 */

/**
 * Repr√§sentiert das Schachbrett f√ºr den Springer.
 */
class KnightBoard {
    /**
     * @param {number|string} size - Die Kantenl√§nge des Brettes (z.B. 5 oder 8).
     */
    constructor(size) {
        this.size = parseInt(size);
        /** @type {number[][]} Das Gitter: 0=leer, N=Zugnummer */
        this.grid = [];
        /** @type {Array<{r:number, c:number}>} Historie der Z√ºge */
        this.history = [];
        this.moveCount = 0;
        /** @type {{r:number, c:number}|null} Aktuelle Position */
        this.currentPos = null;
        this.won = false;

        this.initGrid();
    }

    /** Initialisiert das leere Grid. */
    initGrid() {
        this.grid = Array(this.size).fill(null).map(() => Array(this.size).fill(0));
    }

    /**
     * Pr√ºft, ob Koordinaten auf dem Brett liegen.
     * @param {number} r - Zeile
     * @param {number} c - Spalte
     * @returns {boolean}
     */
    isInside(r, c) {
        return r >= 0 && r < this.size && c >= 0 && c < this.size;
    }

    /**
     * Pr√ºft, ob ein Zug g√ºltig ist (innerhalb und Feld leer).
     * @param {number} r 
     * @param {number} c 
     * @returns {boolean}
     */
    isValidMove(r, c) {
        if (!this.isInside(r, c)) return false;
        return this.grid[r][c] === 0; 
    }

    /**
     * F√ºhrt einen Zug aus (oder setzt Startfigur).
     * @param {number} r 
     * @param {number} c 
     * @returns {boolean} True bei Erfolg.
     */
    move(r, c) {
        // Wenn schon eine Figur steht, muss der Zug valide (L-Form) sein
        if (this.currentPos) {
            const dr = Math.abs(r - this.currentPos.r);
            const dc = Math.abs(c - this.currentPos.c);
            // Springerzug: 2+1 oder 1+2
            if (!((dr === 2 && dc === 1) || (dr === 1 && dc === 2))) return false;
        }

        // Ziel muss frei sein
        if (!this.isValidMove(r, c)) return false;

        this.moveCount++;
        this.grid[r][c] = this.moveCount;
        this.currentPos = { r, c };
        this.history.push({ r, c });

        // Siegpr√ºfung: Brett voll?
        if (this.moveCount === this.size * this.size) this.won = true;
        return true;
    }

    /** Macht den letzten Zug r√ºckg√§ngig. */
    undo() {
        if (this.history.length === 0) return;
        const last = this.history.pop();
        this.grid[last.r][last.c] = 0;
        this.moveCount--;
        
        if (this.history.length > 0) {
            this.currentPos = this.history[this.history.length - 1];
        } else {
            this.currentPos = null;
        }
        this.won = false;
    }

    /**
     * Liefert alle m√∂glichen Z√ºge von der aktuellen Position.
     * @returns {Array<{r:number, c:number}>}
     */
    getPossibleMoves() {
        if (!this.currentPos) return [];
        return this._getMovesFrom(this.currentPos.r, this.currentPos.c);
    }

    /**
     * Warnsdorf-Logik: Z√§hlt freie Nachbarn von einer Koordinate aus.
     * @param {number} r 
     * @param {number} c 
     * @returns {number} Grad (Anzahl m√∂glicher Weiterz√ºge)
     */
    getDegree(r, c) {
        const moves = this._getMovesFrom(r, c);
        return moves.length;
    }
    
    /** KI-Interface: Ist das Ziel erreicht? */
    isGoal() {
        return this.moveCount === this.size * this.size;
    }

    /** KI-Interface: Eindeutiger State-String */
    getStateKey() {
        return this.grid.map(row => row.join(',')).join('|') + `:${this.currentPos.r},${this.currentPos.c}`;
    }

    /** KI-Interface: Nachfolgezust√§nde generieren */
    getNextStates() {
        const moves = this.getPossibleMoves();
        const successors = [];

        for (const m of moves) {
            const nextBoard = this.clone();
            nextBoard.move(m.r, m.c);
            
            successors.push({
                move: m, 
                state: nextBoard
            });
        }
        return successors;
    }

    /**
     * Erstellt eine tiefe Kopie des Boards.
     * @returns {KnightBoard}
     */
    clone() {
        const newBoard = new KnightBoard(this.size);
        // Grid kopieren
        newBoard.grid = this.grid.map(row => [...row]);
        newBoard.moveCount = this.moveCount;
        if (this.currentPos) newBoard.currentPos = { ...this.currentPos };
        // History kopieren
        newBoard.history = this.history.map(h => ({...h}));
        return newBoard;
    }

    /** Interne Hilfsfunktion f√ºr Z√ºge */
    _getMovesFrom(r, c) {
        const moves = [];
        const offsets = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
        offsets.forEach(([dr, dc]) => {
            const nr = r + dr;
            const nc = c + dc;
            if (this.isValidMove(nr, nc)) {
                moves.push({ r: nr, c: nc });
            }
        });
        return moves;
    }
}

/* --- FILE: js/games/knights-tour/controller.js --- */
/**
 * @fileoverview Controller f√ºr das Springerproblem.
 * Steuert Interaktionen, KI-L√∂sung und Unterbrechung.
 */

const Game = {
    /** @type {KnightBoard|null} */
    board: null,
    /** @type {HTMLCanvasElement|null} */
    canvas: null,
    
    /** @type {boolean} L√§uft der Solver gerade? */
    isSolving: false,
    /** @type {boolean} Wurde Stopp angefordert? */
    stopRequested: false,
    
    init() {
        this.canvas = document.getElementById('boardCanvas');
        // Maus und Touch Events
        this.canvas.addEventListener('mousedown', (e) => this.handleInput(e));
        
        document.getElementById('sizeSelect').onchange = () => this.reset();
        document.getElementById('chkShowMoves').onchange = () => this.draw();

        this.reset();
    },

    /**
     * Resettet das Spiel und stoppt laufende KI-Prozesse.
     */
    reset() {
        // Falls KI l√§uft: Stoppen!
        if (this.isSolving) {
            this.stopRequested = true;
            // Wir lassen der KI kurz Zeit zu stoppen, bevor wir das Board tauschen,
            // sonst zeichnet sie evtl. noch einmal auf das alte Board.
            // Aber: User will sofort Reset. 
            // L√∂sung: Wir tauschen das Board, die KI schreibt evtl. noch einen Frame ins Leere (egal).
        }

        const sizeVal = document.getElementById('sizeSelect').value;
        const size = parseInt(sizeVal);
        
        this.board = new KnightBoard(size);
        
        // Canvas Gr√∂√üe an Container anpassen oder fix lassen
        this.canvas.width = 600; 
        this.canvas.height = 600; 
        
        this.updateUI();
        this.draw();
    },

    /**
     * Wechselt zwischen "L√∂sen" und "Stoppen".
     */
    toggleSolver() {
        if (this.isSolving) {
            this.stopRequested = true;
            // UI wird im Loop aktualisiert
        } else {
            this.solveFast();
        }
    },

    /**
     * Startet die KI-L√∂sung.
     */
    async solveFast() {
        if (!this.board.currentPos) {
            alert("Bitte setze zuerst eine Startfigur auf das Brett!");
            return;
        }
        if (this.board.won) return;

        // Status setzen
        this.isSolving = true;
        this.stopRequested = false;
        this.updateUI();

        // Engine konfigurieren
        const engine = new SearchEngine({
            strategy: 'DFS', 
            maxDepth: 2000,
            checkDuplicates: true, // Zyklen vermeiden
            
            // Warnsdorf-Heuristik: W√§hle Feld mit wenigsten Nachfolgern
            sortSuccessors: (nodeA, nodeB) => {
                const degA = nodeA.state.getPossibleMoves().length;
                const degB = nodeB.state.getPossibleMoves().length;
                return degA - degB;
            },
            
            // Callback pro Schritt (f√ºr Animation & Abbruch)
            onStep: async (state) => {
                // 1. Abbruch pr√ºfen
                if (this.stopRequested) {
                    return 'STOP'; // Signal an SearchEngine
                }

                // 2. Zeichnen
                const delay = parseInt(document.getElementById('solveSpeed').value);
                
                // Um Performance zu sparen bei 0 Delay nicht jeden Frame zeichnen
                if (delay > 0 || Math.random() < 0.05) {
                    KnightRenderer.draw(this.canvas, state, { showPossibleMoves: false });
                    if (delay > 0) await new Promise(r => setTimeout(r, delay));
                }
            }
        });

        // Starten
        const result = await engine.solve(this.board);
        
        // Aufr√§umen
        this.isSolving = false;
        this.stopRequested = false;
        
        if (result.stopped) {
            // Wurde abgebrochen -> UI updaten, Board so lassen wie es ist
            this.updateUI();
            return; 
        }

        if (!result.success) {
            alert("Sackgasse! Keine L√∂sung von hier.");
            this.draw(); // Originalzustand zeichnen
        } else {
            // L√∂sung gefunden -> Auf echtes Board anwenden
            // (Die Visualisierung lief auf Kopien)
            // Wir "beamen" das Board in den Endzustand oder spielen schnell ab
            for (const move of result.path) {
                this.board.move(move.r, move.c);
            }
            this.draw();
            setTimeout(() => alert("Gel√∂st!"), 50);
        }
        this.updateUI();
    },

    handleInput(e) {
        // Eingabe sperren w√§hrend KI l√§uft
        if (this.board.won || this.isSolving) return;

        const rect = this.canvas.getBoundingClientRect();
        // Skalierung beachten, falls CSS Canvas Gr√∂√üe √§ndert
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;

        const x = (e.clientX - rect.left) * scaleX; 
        const y = (e.clientY - rect.top) * scaleY; 
        
        const padding = 30; // Muss mit Renderer √ºbereinstimmen
        const availableW = this.canvas.width - padding;
        const cellSize = availableW / this.board.size;

        // Klick im Padding (links)?
        if (x < padding) return;

        const col = Math.floor((x - padding) / cellSize);
        const row = Math.floor(y / cellSize);

        if (row >= 0 && row < this.board.size && col >= 0 && col < this.board.size) {
            if (this.board.move(row, col)) {
                this.draw();
                this.updateUI();
                if (this.board.won) setTimeout(() => alert("Gewonnen!"), 100);
            }
        }
    },

    undo() {
        if (this.isSolving) return;
        this.board.undo();
        this.draw();
        this.updateUI();
    },

    updateUI() {
        const max = this.board.size * this.board.size;
        document.getElementById('stats').innerText = `Z√ºge: ${this.board.moveCount} / ${max}`;
        
        // Button Text und Style √§ndern
        const btn = document.getElementById('solveBtn');
        if (this.isSolving) {
            btn.innerText = "‚èπ Stoppen";
            btn.className = "viz-btn btn-danger"; // Rot
        } else {
            btn.innerText = "‚ö° Automatisch L√∂sen";
            btn.className = "viz-btn btn-action"; // Blau/Gr√ºn
        }
    },

    draw() {
        const showMoves = document.getElementById('chkShowMoves').checked;
        
        KnightRenderer.draw(this.canvas, this.board, { 
            showPossibleMoves: showMoves,
            showWarnsdorf: false, 
            highContrast: false 
        });
    }
};

window.onload = () => Game.init();

/* --- FILE: js/games/tictactoe/3d-controller.js --- */
/**
 * @fileoverview Controller f√ºr 3D Tic-Tac-Toe.
 * Verwaltet User Input, KI-Turns und Rendering.
 */
const ThreeDController = {
    game: null, 
    canvas: null, 
    isoCanvas: null, 
    axis: 'z', 
    size: 3, 
    isProcessing: false,

    /** Initialisiert das Spiel. */
    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.isoCanvas = document.getElementById('isoCanvas');
        this.canvas.addEventListener('mousedown', (e) => this.click(e));
        
        // KI Dropdowns √ºberwachen
        document.getElementById('p1Type').onchange = () => this.checkTurn();
        document.getElementById('p2Type').onchange = () => this.checkTurn();
        this.reset();
    },

    /** √Ñndert die Brettgr√∂√üe (3 oder 4). */
    setSize(s) {
        this.size = s;
        document.querySelectorAll('.size-btn').forEach(b => {
            b.classList.remove('active');
            if(b.innerText.includes(s)) b.classList.add('active');
        });
        this.reset();
    },

    /** √Ñndert die Ansichtsachse. */
    setAxis(a) {
        this.axis = a;
        document.querySelectorAll('.view-btn').forEach(b => {
            b.classList.remove('active');
            // Einfacher String-Check f√ºr Button-Highlighting
            if(b.innerText.toLowerCase().includes(a === 'z' ? 'oben' : a === 'y' ? 'vorne' : 'seite')) b.classList.add('active');
        });
        this.draw();
    },

    /** Resettet das Spiel. */
    reset() {
        this.game = new TTT3DBoard(this.size);
        this.isProcessing = false;
        this.updateUI(); 
        this.draw(); 
        this.checkTurn();
    },

    /** Pr√ºft, ob eine KI am Zug ist. */
    checkTurn() {
        if(this.game.winner || this.game.getAllValidMoves().length===0) return this.updateUI();
        
        const p1 = document.getElementById('p1Type').value;
        const p2 = document.getElementById('p2Type').value;
        const current = (this.game.currentPlayer === 1) ? p1 : p2;
        this.updateUI();

        if (current !== 'human') {
            this.isProcessing = true;
            const speed = document.getElementById('aiSpeed').value;
            setTimeout(() => {
                // KI Instanzieren (Random oder Regel)
                const agent = (current==='random') ? new RandomAgent() : new RuleBasedAgent(createStrategyTree('3d'));
                const action = agent.getAction(this.game);
                
                if(action) this.game.makeMove(action.move);
                
                this.isProcessing = false;
                this.draw(); 
                this.checkTurn();
            }, speed);
        }
    },

    /** Verarbeitet Klicks auf das Canvas. */
    click(e) {
        if(this.isProcessing || this.game.winner) return;
        
        // --- INPUT SCALING FIX ---
        const rect = this.canvas.getBoundingClientRect();
        
        // Verh√§ltnis Canvas-Pixel zu Display-Pixel
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;

        // Mausposition im Canvas-Koordinatensystem
        const mx = (e.clientX - rect.left) * scaleX;
        const my = (e.clientY - rect.top) * scaleY;
        
        // Layout-Konstanten (identisch zum Renderer)
        const w = this.canvas.width, h = this.canvas.height, s = this.size;
        const pad = 20;
        const availW = w - (pad*2);
        const availH = h - (pad*2);
        const boxSize = Math.min(availW / s, availH);
        const gap = boxSize * 0.1;
        const boardS = boxSize - gap; // Effektive Brettgr√∂√üe
        const startX = (w - s*boxSize)/2 + gap/2;
        const startY = (h - boardS)/2 + 10;

        // Hit-Testing: Welches Slice (k)?
        for(let k=0; k<s; k++) {
            const ox = startX + k*boxSize;
            // Pr√ºfen ob Klick im Bereich dieses Boards liegt
            if(mx >= ox && mx <= ox+boardS && my >= startY && my <= startY+boardS) {
                // Zeile und Spalte berechnen
                const c = Math.floor((mx-ox)/(boardS/s));
                const r = Math.floor((my-startY)/(boardS/s));
                
                // Mapping auf 3D Koordinaten
                let x,y,z;
                if(this.axis==='z') { z=k; y=r; x=c; }
                else if(this.axis==='y') { y=k; x=c; z=(s-1)-r; }
                else { x=k; y=c; z=(s-1)-r; }

                // Index berechnen
                const idx = z*(s*s) + y*s + x;
                
                // Zug ausf√ºhren
                if(this.game.makeMove(idx)) { 
                    this.draw(); 
                    this.checkTurn(); 
                }
                break;
            }
        }
    },

    updateUI() {
        const stats = document.getElementById('statusText');
        if(this.game.winner) stats.innerText = "SIEG: " + (this.game.winner===1?"BLAU":"ROT");
        else stats.innerText = (this.game.currentPlayer===1?"BLAU":"ROT") + " ist dran";
    },
    
    draw() {
        TTTRenderer.draw3DSlices(this.canvas, this.game, this.axis);
        TTTRenderer.drawIsoView(this.isoCanvas, this.game);
    }
};
window.onload = () => ThreeDController.init();

/* --- FILE: js/games/tictactoe/renderer.js --- */
/**
 * @fileoverview Renderer-Sammlung f√ºr alle Tic-Tac-Toe Varianten.
 * Enth√§lt 2D, Ultimate und 3D Visualisierungen.
 */

const TTTRenderer = {
    
    /**
     * Zeichnet das klassische 3x3 Board.
     * @param {HTMLCanvasElement} canvas 
     * @param {TTTRegularBoard} game 
     */
    drawRegular(canvas, game) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const s = w / 3;

        ctx.clearRect(0, 0, w, h);
        
        // Gitterlinien
        ctx.strokeStyle = "#2c3e50"; 
        ctx.lineWidth = 6; 
        ctx.lineCap = "round";
        
        ctx.beginPath();
        ctx.moveTo(s, 10); ctx.lineTo(s, h-10); 
        ctx.moveTo(s*2, 10); ctx.lineTo(s*2, h-10);
        ctx.moveTo(10, s); ctx.lineTo(w-10, s); 
        ctx.moveTo(10, s*2); ctx.lineTo(w-10, s*2);
        ctx.stroke();

        // Symbole
        for(let i=0; i<9; i++) {
            if(game.grid[i] === 0) continue;
            const cx = (i % 3) * s + s/2;
            const cy = Math.floor(i / 3) * s + s/2;
            this._drawSymbol(ctx, cx, cy, s/3.5, game.grid[i]);
        }
    },

    /**
     * Zeichnet das Ultimate TTT Board.
     * @param {HTMLCanvasElement} canvas 
     * @param {UltimateBoard} game 
     */
    drawUltimate(canvas, game) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const bigS = w / 3;
        const smallS = bigS / 3;

        ctx.clearRect(0, 0, w, h);

        // 1. Highlights: Wo darf gespielt werden?
        if (game.winner === 0) {
            if (game.nextBoardIdx !== -1) {
                // Bestimmtes Board highlighten
                const bx = (game.nextBoardIdx % 3) * bigS;
                const by = Math.floor(game.nextBoardIdx / 3) * bigS;
                ctx.fillStyle = "#eafaed"; // Hellgr√ºn
                ctx.fillRect(bx, by, bigS, bigS);
            } else {
                // Freie Wahl -> Alles leicht gr√ºn
                ctx.fillStyle = "#eafaed"; 
                ctx.fillRect(0,0,w,h);
            }
        }

        // 2. Makro-Board Status (Farbige Hintergr√ºnde f√ºr gewonnene Boards)
        for (let i=0; i<9; i++) {
            const bx = (i%3)*bigS;
            const by = Math.floor(i/3)*bigS;
            
            if (game.macroBoard[i] !== 0) {
                const winner = game.macroBoard[i];
                
                // Hintergrundfarbe transparent
                if (winner === 1) ctx.fillStyle = "rgba(52, 152, 219, 0.15)"; // Blau
                else if (winner === 2) ctx.fillStyle = "rgba(231, 76, 60, 0.15)"; // Rot
                else ctx.fillStyle = "rgba(127, 140, 141, 0.2)"; // Grau/Remis
                
                ctx.fillRect(bx, by, bigS, bigS);
                
                // Gro√ües Symbol dar√ºber zeichnen (sehr transparent)
                ctx.save();
                ctx.globalAlpha = 0.3; 
                this._drawSymbol(ctx, bx+bigS/2, by+bigS/2, bigS/3, winner, 15);
                ctx.restore();
            }
        }

        // 3. Kleines Gitter (D√ºnn)
        ctx.lineWidth = 1; 
        ctx.strokeStyle = "#bdc3c7";
        ctx.beginPath();
        for (let i=1; i<9; i++) {
            if (i%3===0) continue; 
            ctx.moveTo(i*smallS, 0); ctx.lineTo(i*smallS, h);
            ctx.moveTo(0, i*smallS); ctx.lineTo(w, i*smallS);
        }
        ctx.stroke();

        // 4. Gro√ües Gitter (Dick)
        ctx.lineWidth = 4; 
        ctx.strokeStyle = "#2c3e50";
        ctx.beginPath();
        for (let i=1; i<=2; i++) {
            ctx.moveTo(i*bigS, 0); ctx.lineTo(i*bigS, h);
            ctx.moveTo(0, i*bigS); ctx.lineTo(w, i*bigS);
        }
        ctx.stroke();

        // 5. Kleine Spielsteine
        for (let b=0; b<9; b++) {
            for (let s=0; s<9; s++) {
                if (game.boards[b][s] === 0) continue;
                const bx = (b%3)*bigS; 
                const by = Math.floor(b/3)*bigS;
                const sx = (s%3)*smallS; 
                const sy = Math.floor(s/3)*smallS;
                
                this._drawSymbol(ctx, bx+sx+smallS/2, by+sy+smallS/2, smallS/3, game.boards[b][s], 3);
            }
        }
    },

    /**
     * Zeichnet die 2D-Schnittebenen (Slices) f√ºr das 3D-Spiel.
     * @param {HTMLCanvasElement} canvas 
     * @param {TTT3DBoard} game 
     * @param {string} axis - 'x', 'y' oder 'z'.
     */
    draw3DSlices(canvas, game, axis) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const s = game.size; 

        ctx.clearRect(0,0,w,h);
        
        // Layout-Konstanten (M√ºssen mit Controller-Hit-Detection √ºbereinstimmen!)
        const padding = 20;
        const availW = w - (padding*2);
        const availH = h - (padding*2);
        // Boxgr√∂√üe so berechnen, dass s Boxen nebeneinander passen
        const boxSize = Math.min(availW / s, availH);
        const gap = boxSize * 0.1;
        const boardSize = boxSize - gap;
        
        const totalW = s * boxSize;
        const startX = (w - totalW) / 2 + gap/2;
        const startY = (h - boardSize) / 2 + 10;

        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";

        const sliceName = (axis === 'z') ? 'Z' : (axis === 'y') ? 'Y' : 'X';
        
        for (let k = 0; k < s; k++) {
            const ox = startX + k * boxSize;
            const oy = startY;

            // Label
            ctx.fillStyle = "#2c3e50"; 
            ctx.font = "bold 14px sans-serif";
            ctx.fillText(`${sliceName}${k+1}`, ox + boardSize/2, oy - 15);

            // Hintergrund
            ctx.fillStyle = "#ecf0f1"; 
            ctx.fillRect(ox, oy, boardSize, boardSize);
            ctx.strokeStyle = "#bdc3c7"; 
            ctx.lineWidth = 2; 
            ctx.strokeRect(ox, oy, boardSize, boardSize);

            // Gitterlinien
            const cellS = boardSize / s;
            ctx.beginPath();
            for(let i=1; i<s; i++) {
                ctx.moveTo(ox + i*cellS, oy); ctx.lineTo(ox + i*cellS, oy + boardSize);
                ctx.moveTo(ox, oy + i*cellS); ctx.lineTo(ox + boardSize, oy + i*cellS);
            }
            ctx.stroke();

            // Inhalte
            for(let r=0; r<s; r++) { 
                for(let c=0; c<s; c++) { 
                    // Koordinaten Mapping
                    let x, y, z;
                    if (axis === 'z') { z = k; y = r; x = c; } 
                    else if (axis === 'y') { y = k; x = c; z = (s - 1) - r; } 
                    else { x = k; y = c; z = (s - 1) - r; }

                    const idx = z*(s*s) + y*s + x;
                    const val = game.grid[idx];

                    if (val !== 0) {
                        const cx = ox + c*cellS + cellS/2;
                        const cy = oy + r*cellS + cellS/2;
                        this._drawSymbol(ctx, cx, cy, cellS/3.5, val, 3);
                    }
                }
            }
        }
    },

    /**
     * Zeichnet die isometrische 3D Ansicht.
     * @param {HTMLCanvasElement} canvas 
     * @param {TTT3DBoard} game 
     */
    drawIsoView(canvas, game) {
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const s = game.size;

        ctx.clearRect(0,0,w,h);

        let boardSize = w * 0.55; 
        if (s === 4) boardSize = w * 0.45;

        const offX = boardSize * 0.2;
        const offY = -boardSize * 0.4;
        
        const startX = (w - (boardSize + (s-1)*offX))/2 + 20;
        const startY = h - 50;

        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "right"; 
        ctx.textBaseline = "middle";

        // Zeichnen von hinten (z=0) nach vorne (z=s-1)
        for (let z=0; z<s; z++) {
            const ox = startX + z * offX;
            const oy = startY + z * offY;

            // Transparenz f√ºr Tiefeneffekt
            ctx.save();
            // Hintere Ebenen transparenter
            ctx.globalAlpha = 0.4 + (0.6 * (z+1)/s);

            // Label
            ctx.fillStyle = "#7f8c8d";
            ctx.fillText(`z${z+1}`, ox - 10, oy + 20);

            // Ebene Boden
            ctx.fillStyle = "rgba(52, 152, 219, 0.05)"; 
            ctx.fillRect(ox, oy - boardSize, boardSize, boardSize);
            ctx.strokeStyle = "rgba(44, 62, 80, 0.2)"; 
            ctx.lineWidth = 1; 
            ctx.strokeRect(ox, oy - boardSize, boardSize, boardSize);

            // Gitterlinien
            const cellS = boardSize / s;
            ctx.beginPath();
            for(let i=1; i<s; i++) {
                ctx.moveTo(ox + i*cellS, oy); ctx.lineTo(ox + i*cellS, oy - boardSize);
                ctx.moveTo(ox, oy - i*cellS); ctx.lineTo(ox + boardSize, oy - i*cellS);
            }
            ctx.stroke();

            // Steine
            for(let y=0; y<s; y++) {
                for(let x=0; x<s; x++) {
                    const idx = z*(s*s) + y*s + x;
                    const val = game.grid[idx];
                    
                    if (val !== 0) {
                        const cx = ox + x*cellS + cellS/2;
                        const cy = (oy - boardSize) + y*cellS + cellS/2;
                        const r = cellS/3.5;

                        // Kleiner Schatten
                        ctx.fillStyle = "rgba(0,0,0,0.1)";
                        ctx.beginPath(); ctx.arc(cx+2, cy+2, r, 0, Math.PI*2); ctx.fill();

                        this._drawSymbol(ctx, cx, cy, r, val, 2);
                    }
                }
            }
            ctx.restore();
        }
    },

    /**
     * Interner Helfer: Zeichnet Kreis (1) oder Kreuz (2).
     */
    _drawSymbol(ctx, x, y, r, player, lw=5) {
        ctx.lineWidth = lw;
        if (player === 1) { // Blau
            ctx.strokeStyle = "#3498db"; 
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke();
        } else if (player === 2) { // Rot
            ctx.strokeStyle = "#e74c3c"; 
            ctx.beginPath(); 
            ctx.moveTo(x-r, y-r); ctx.lineTo(x+r, y+r);
            ctx.moveTo(x+r, y-r); ctx.lineTo(x-r, y+r); 
            ctx.stroke();
        }
    }
};

/* --- FILE: js/games/tictactoe/regular-controller.js --- */
/** * @fileoverview Controller f√ºr 3x3 Tic-Tac-Toe.
 */
const RegularController = {
    game: null, canvas: null, isProcessing: false,

    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.canvas.addEventListener('mousedown', (e) => this.handleClick(e));
        document.getElementById('p1Type').onchange = () => this.checkTurn();
        document.getElementById('p2Type').onchange = () => this.checkTurn();
        this.reset();
    },

    reset() {
        this.game = new TTTRegularBoard();
        this.isProcessing = false;
        this.updateUI(); this.draw(); this.checkTurn();
    },

    checkTurn() {
        if(this.game.winner || this.game.getAllValidMoves().length===0) return this.updateUI();
        
        const p1 = document.getElementById('p1Type').value;
        const p2 = document.getElementById('p2Type').value;
        const current = (this.game.currentPlayer === 1) ? p1 : p2;
        this.updateUI();

        if (current !== 'human') {
            this.isProcessing = true;
            const speed = document.getElementById('aiSpeed').value;
            setTimeout(() => {
                // KI Zug
                const agent = (current==='random') ? new RandomAgent() : new RuleBasedAgent(createStrategyTree('regular'));
                const action = agent.getAction(this.game);
                if(action) this.game.makeMove(action.move);
                
                this.isProcessing = false;
                this.draw(); this.checkTurn();
            }, speed);
        }
    },

    handleClick(e) {
        if(this.isProcessing || this.game.winner) return;
        
        const rect = this.canvas.getBoundingClientRect();
        // Scaling ber√ºcksichtigen
        const scale = this.canvas.width / rect.width;
        const x = (e.clientX - rect.left) * scale;
        const y = (e.clientY - rect.top) * scale;
        
        const s = this.canvas.width / 3;
        const c = Math.floor(x/s), r = Math.floor(y/s);
        
        if(c>=0 && c<3 && r>=0 && r<3) {
            if(this.game.makeMove(r*3+c)) { 
                this.draw(); 
                this.checkTurn(); 
            }
        }
    },

    updateUI() {
        const stats = document.getElementById('statusText');
        if(this.game.winner) stats.innerText = "SIEG: " + (this.game.winner===1?"BLAU":"ROT");
        else if(this.game.getAllValidMoves().length===0) stats.innerText = "REMIS";
        else stats.innerText = (this.game.currentPlayer===1?"BLAU":"ROT") + " ist dran";
    },
    
    draw() { TTTRenderer.drawRegular(this.canvas, this.game); }
};
window.onload = () => RegularController.init();

/* --- FILE: js/games/tictactoe/logic.js --- */
/**
 * @fileoverview Zentrale Spiellogik f√ºr die Tic-Tac-Toe Varianten.
 * Beinhaltet die Klassen f√ºr Regular (3x3), 3D (NxNxN) und Ultimate.
 * Implementiert das GameState Interface.
 */

/**
 * Abstrakte Basisklasse f√ºr Tic-Tac-Toe Spiele.
 * @abstract
 */
class TTTBase {
    constructor() {
        /** * Aktueller Spieler. 
         * 1 = Spieler 1 (Blau/Kreis), 2 = Spieler 2 (Rot/Kreuz).
         * @type {number} 
         */
        this.currentPlayer = 1;

        /**
         * Gewinner des Spiels.
         * 0 = Laufend, 1 = Spieler 1, 2 = Spieler 2, 3 = Remis.
         * @type {number}
         */
        this.winner = 0;
    }

    /**
     * Wechselt den aktiven Spieler (1 -> 2 -> 1).
     */
    switchPlayer() {
        this.currentPlayer = (this.currentPlayer === 1) ? 2 : 1;
    }
}

/**
 * Klassisches 3x3 Tic-Tac-Toe Board.
 * @extends TTTBase
 */
class TTTRegularBoard extends TTTBase {
    constructor() {
        super();
        /** * Das 3x3 Gitter als flaches Array (Indizes 0-8).
         * 0 = Leer, 1 = Spieler 1, 2 = Spieler 2.
         * @type {number[]} 
         */
        this.grid = Array(9).fill(0);
    }

    /**
     * Liefert alle Indizes von leeren Feldern.
     * Liste der m√∂glichen Z√ºge.
     * @returns {number[]} 
     */
    getAllValidMoves() {
        if (this.winner !== 0) return [];
        // Map erzeugt Array gleicher L√§nge, filter entfernt die -1er
        return this.grid.map((val, idx) => val === 0 ? idx : -1).filter(idx => idx !== -1);
    }

    /**
     * F√ºhrt einen Zug an der Position index aus.
     * - Index des Feldes (0-8).
     * @param {number} index 
     * True, wenn der Zug g√ºltig war.
     * @returns {boolean} 
     */
    makeMove(index) {
        // Validierung: Index im Bereich, Feld leer, Spiel l√§uft
        if (index < 0 || index >= 9 || this.grid[index] !== 0 || this.winner !== 0) {
            return false;
        }

        // Setzen
        this.grid[index] = this.currentPlayer;

        // Status pr√ºfen
        this.checkWin();

        // Spielerwechsel (nur wenn Spiel nicht vorbei)
        if (this.winner === 0) {
            this.switchPlayer();
        }
        return true;
    }

    /**
     * √úberpr√ºft alle 8 Gewinnlinien auf 3 Gleiche.
     * Setzt this.winner entsprechend.
     */
    checkWin() {
        const lines = [
            [0,1,2], [3,4,5], [6,7,8], // Horizontal
            [0,3,6], [1,4,7], [2,5,8], // Vertikal
            [0,4,8], [2,4,6]           // Diagonal
        ];

        for (const line of lines) {
            const [a, b, c] = line;
            if (this.grid[a] !== 0 && 
                this.grid[a] === this.grid[b] && 
                this.grid[b] === this.grid[c]) {
                this.winner = this.grid[a];
                return;
            }
        }

        // Remis Check (Brett voll, kein Gewinner)
        if (!this.grid.includes(0)) {
            this.winner = 3;
        }
    }

    /**
     * Erstellt eine tiefe Kopie des Boards (f√ºr KI-Simulationen).
     * @returns {TTTRegularBoard}
     */
    clone() {
        const copy = new TTTRegularBoard();
        copy.grid = [...this.grid];
        copy.currentPlayer = this.currentPlayer;
        copy.winner = this.winner;
        return copy;
    }

    /**
     * Generiert einen eindeutigen String f√ºr diesen Zustand.
     *  Hash Key.
     * @returns {string}
     */
    getStateKey() {
        return this.grid.join('') + this.currentPlayer;
    }
}

/**
 * 3D Tic-Tac-Toe Board (W√ºrfel).
 * Unterst√ºtzt variable Gr√∂√üen (z.B. 3x3x3 oder 4x4x4).
 * @extends TTTBase
 */
class TTT3DBoard extends TTTBase {
    /**
     * @param {number} [size=3] - Kantenl√§nge des W√ºrfels.
     */
    constructor(size = 3) {
        super();
        this.size = size;
        this.totalCells = size * size * size;
        /** * Das 3D Gitter als flaches Array.
         * Index = z * size^2 + y * size + x
         * @type {number[]} 
         */
        this.grid = Array(this.totalCells).fill(0);
    }

    /**
     * Liefert alle leeren Felder im W√ºrfel.
     * @returns {number[]}
     */
    getAllValidMoves() {
        if (this.winner !== 0) return [];
        const moves = [];
        for (let i = 0; i < this.totalCells; i++) {
            if (this.grid[i] === 0) moves.push(i);
        }
        return moves;
    }

    /**
     * Setzt einen Stein an index.
     * - Berechneter Index im flachen Array.
     * @param {number} index 
     * @returns {boolean}
     */
    makeMove(index) {
        if (index < 0 || index >= this.totalCells || this.grid[index] !== 0 || this.winner !== 0) {
            return false;
        }

        this.grid[index] = this.currentPlayer;
        this.checkWin();

        if (this.winner === 0) {
            this.switchPlayer();
        }
        return true;
    }

    /**
     * Pr√ºft alle m√∂glichen Gewinnlinien im 3D Raum.
     * Es gibt 13 Richtungsvektoren (Achsen, Fl√§chendiagonalen, Raumdiagonalen).
     */
    checkWin() {
        // Richtungsvektoren (dx, dy, dz)
        const directions = [
            [1,0,0], [0,1,0], [0,0,1],       // 3 Achsen
            [1,1,0], [1,-1,0], [1,0,1], [1,0,-1], [0,1,1], [0,1,-1], // 6 Fl√§chendiagonalen
            [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1] // 4 Raumdiagonalen
        ];

        // Wir iterieren durch jede Zelle als potentiellen Startpunkt
        for (let z = 0; z < this.size; z++) {
            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    const idx = this._getIndex(x, y, z);
                    const player = this.grid[idx];

                    if (player === 0) continue;

                    // Von hier aus in alle Richtungen pr√ºfen
                    for (const dir of directions) {
                        if (this._checkLine(x, y, z, dir[0], dir[1], dir[2], player)) {
                            this.winner = player;
                            return;
                        }
                    }
                }
            }
        }

        // Remis
        if (!this.grid.includes(0)) {
            this.winner = 3;
        }
    }

    /**
     * Pr√ºft eine spezifische Linie vom Startpunkt (x,y,z) in Richtung (dx,dy,dz).
     * @private
     */
    _checkLine(x, y, z, dx, dy, dz, player) {
        // 1. Pr√ºfen, ob die Linie √ºberhaupt lang genug sein kann (Bounds Check am Endpunkt)
        const endX = x + dx * (this.size - 1);
        const endY = y + dy * (this.size - 1);
        const endZ = z + dz * (this.size - 1);

        if (endX < 0 || endX >= this.size ||
            endY < 0 || endY >= this.size ||
            endZ < 0 || endZ >= this.size) {
            return false;
        }

        // 2. Linie ablaufen
        for (let i = 1; i < this.size; i++) {
            const nx = x + dx * i;
            const ny = y + dy * i;
            const nz = z + dz * i;
            if (this.grid[this._getIndex(nx, ny, nz)] !== player) {
                return false;
            }
        }
        return true;
    }

    /** * Hilfsmethode: x,y,z zu Array-Index 
     * @private 
     */
    _getIndex(x, y, z) {
        return z * (this.size * this.size) + y * this.size + x;
    }

    clone() {
        const c = new TTT3DBoard(this.size);
        c.grid = [...this.grid];
        c.currentPlayer = this.currentPlayer;
        c.winner = this.winner;
        return c;
    }
    
    getStateKey() { return this.grid.join('') + this.currentPlayer; }
}

/**
 * Ultimate Tic-Tac-Toe.
 * 9 kleine Boards (3x3) in einem gro√üen Board.
 * @extends TTTBase
 */
class UltimateBoard extends TTTBase {
    constructor() {
        super();
        /** 
         * 9 Arrays √† 9 Felder.
         * @type {number[][]} 
         */
        this.boards = Array(9).fill(null).map(() => Array(9).fill(0));
        
        /** 
         * Status der 9 gro√üen Felder (Makro-Board). 0=Offen, 1/2=Sieg, 3=Remis. 
         * @type {number[]} 
         * */
        this.macroBoard = Array(9).fill(0);
        
        /** 
         * Index des Boards, in das der n√§chste Spieler setzen MUSS. -1 = Freie Wahl. 
         * @type {number} 
         * */
        this.nextBoardIdx = -1;
    }

    /**
     * Liefert alle g√ºltigen Z√ºge als Objekte {big, small}.
     * @returns {Array<{big:number, small:number}>}
     */
    getAllValidMoves() {
        if (this.winner !== 0) return [];
        const moves = [];
        
        let targetBoards = [];
        
        // Regel: Wenn man in ein Board geschickt wird, das nicht voll/gewonnen ist, MUSS man dort spielen.
        if (this.nextBoardIdx !== -1 && !this._isBoardFullOrWon(this.nextBoardIdx)) {
            targetBoards = [this.nextBoardIdx];
        } else {
            // Sonst: Freie Wahl auf allen nicht vollen/gewonnenen Boards
            for (let i = 0; i < 9; i++) {
                if (!this._isBoardFullOrWon(i)) targetBoards.push(i);
            }
        }

        // Alle freien Felder in den Ziel-Boards sammeln
        for (const bIdx of targetBoards) {
            for (let sIdx = 0; sIdx < 9; sIdx++) {
                if (this.boards[bIdx][sIdx] === 0) {
                    moves.push({ big: bIdx, small: sIdx });
                }
            }
        }
        return moves;
    }

    /**
     * F√ºhrt einen Zug aus.
     * - Index des gro√üen Boards (0-8).
     * @param {number} big 
     * - Index des kleinen Feldes (0-8).
     * @param {number} small
     * True bei Erfolg. 
     * @returns {boolean} 
     */
    makeMove(big, small) {
        // 1. Basis-Checks
        if (this.winner !== 0) return false;
        
        // 2. Regel-Check: Darf ich in dieses 'big' Board setzen?
        // Wenn nextBoardIdx aktiv (-1) ist und das Zielboard noch offen ist,
        // muss 'big' gleich 'nextBoardIdx' sein.
        if (this.nextBoardIdx !== -1 && !this._isBoardFullOrWon(this.nextBoardIdx)) {
            if (big !== this.nextBoardIdx) return false; // Ung√ºltiges Board gew√§hlt!
        }
        // Zusatz: Auch bei freier Wahl darf man nicht in ein volles Board setzen
        if (this._isBoardFullOrWon(big)) return false;

        // 3. Feld belegt?
        if (this.boards[big][small] !== 0) return false;

        // --- ZUG AUSF√úHREN ---
        this.boards[big][small] = this.currentPlayer;

        // 4. Pr√ºfen, ob das kleine Board gewonnen wurde
        // (Nur wenn es noch nicht entschieden war)
        if (this.macroBoard[big] === 0) {
            const w = this._checkSmallWin(this.boards[big]);
            if (w !== 0) {
                this.macroBoard[big] = w; // Board gewonnen
            } else if (!this.boards[big].includes(0)) {
                this.macroBoard[big] = 3; // Board voll (Remis)
            }
        }

        // 5. Pr√ºfen, ob das gro√üe Board (Spiel) gewonnen wurde
        const gameWin = this._checkSmallWin(this.macroBoard);
        if (gameWin !== 0) {
            this.winner = gameWin;
        } else if (!this.macroBoard.includes(0)) {
            // Alle gro√üen Felder entschieden, aber keine Reihe -> Remis
            this.winner = 3; 
        }

        if (this.winner === 0) {
            this.switchPlayer();
        }

        // 6. N√§chstes Board bestimmen
        // Der Spieler wird in das Board geschickt, das dem 'small' Index entspricht.
        this.nextBoardIdx = small;
        
        // Wenn das Zielboard aber schon voll/gewonnen ist, hat der n√§chste Spieler freie Wahl.
        if (this._isBoardFullOrWon(this.nextBoardIdx)) {
            this.nextBoardIdx = -1;
        }

        return true;
    }

    /** Pr√ºft, ob ein kleines Board nicht mehr bespielbar ist. */
    _isBoardFullOrWon(idx) {
        // Makroboard nicht 0 (=Sieg/Remis) ODER keine Nullen im Grid (=Voll)
        return this.macroBoard[idx] !== 0 || !this.boards[idx].includes(0);
    }

    /** Hilfsfunktion: 3-in-einer-Reihe auf einem 9er Array. */
    _checkSmallWin(grid) {
        const wins = [[0,1,2],[3,4,5],[6,7,8], [0,3,6],[1,4,7],[2,5,8], [0,4,8],[2,4,6]];
        for (const w of wins) {
            // Ignoriere 0 (leer) und 3 (Remis-Marker) bei der Gewinnpr√ºfung
            if (grid[w[0]] !== 0 && grid[w[0]] !== 3 &&
                grid[w[0]] === grid[w[1]] && 
                grid[w[1]] === grid[w[2]]) {
                return grid[w[0]];
            }
        }
        return 0;
    }

    clone() {
        const c = new UltimateBoard();
        // Arrays kopieren
        c.boards = this.boards.map(r => [...r]);
        c.macroBoard = [...this.macroBoard];
        c.currentPlayer = this.currentPlayer;
        c.nextBoardIdx = this.nextBoardIdx;
        c.winner = this.winner;
        return c;
    }
    
    getStateKey() { 
        return JSON.stringify(this.boards) + this.currentPlayer; 
    }
}

/* --- FILE: js/games/tictactoe/ultimate-controller.js --- */
/** * @fileoverview Controller f√ºr Ultimate Tic-Tac-Toe.
 */
const UltimateController = {
    game: null, canvas: null, isProcessing: false,

    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.canvas.addEventListener('mousedown', (e) => this.click(e));
        document.getElementById('p1Type').onchange = () => this.checkTurn();
        document.getElementById('p2Type').onchange = () => this.checkTurn();
        this.reset();
    },

    reset() {
        this.game = new UltimateBoard();
        this.isProcessing = false;
        this.updateUI(); this.draw(); this.checkTurn();
    },

    checkTurn() {
        if(this.game.winner || this.game.getAllValidMoves().length===0) return this.updateUI();
        const p1 = document.getElementById('p1Type').value;
        const p2 = document.getElementById('p2Type').value;
        const current = (this.game.currentPlayer === 1) ? p1 : p2;
        this.updateUI();

        if (current !== 'human') {
            this.isProcessing = true;
            const speed = document.getElementById('aiSpeed').value;
            setTimeout(() => {
                const agent = (current==='random') ? new RandomAgent() : new RuleBasedAgent(createStrategyTree('ultimate'));
                const action = agent.getAction(this.game);
                // Ultimate Move: {big, small}
                if(action) this.game.makeMove(action.move.big, action.move.small);
                this.isProcessing = false;
                this.draw(); this.checkTurn();
            }, speed);
        }
    },

    click(e) {
        if(this.isProcessing || this.game.winner) return;
        const rect = this.canvas.getBoundingClientRect();
        
        // Scaling
        const scale = this.canvas.width / rect.width;
        const x = (e.clientX - rect.left) * scale;
        const y = (e.clientY - rect.top) * scale;
        
        const bigS = this.canvas.width/3, smallS = bigS/3;
        
        const bX = Math.floor(x/bigS), bY = Math.floor(y/bigS);
        const sX = Math.floor((x%bigS)/smallS), sY = Math.floor((y%bigS)/smallS);
        
        if(bX>=0 && bX<3 && bY>=0 && bY<3) {
            // makeMove validiert, ob der Zug im erlaubten Board ist
            if(this.game.makeMove(bY*3+bX, sY*3+sX)) { 
                this.draw(); 
                this.checkTurn(); 
            }
        }
    },

    updateUI() {
        const stats = document.getElementById('statusText');
        if(this.game.winner) stats.innerText = "SIEG: " + (this.game.winner===1?"BLAU":"ROT");
        else stats.innerText = (this.game.currentPlayer===1?"BLAU":"ROT") + " ist dran";
    },
    
    draw() { TTTRenderer.drawUltimate(this.canvas, this.game); }
};
window.onload = () => UltimateController.init();

/* --- FILE: js/games/rotatebox/renderer.js --- */
/**
 * @fileoverview Renderer und Animations-Logik f√ºr RotateBox.
 */

const COLORS = ['#e74c3c', '#2ecc71', '#f1c40f', '#3498db', '#e67e22', '#9b59b6', '#1abc9c', '#bdc3c7', '#34495e', '#f39c12'];

/**
 * Zeichnet das Board auf den Canvas.
 * @param {RotateBoard} board - Das Spielbrett.
 * @param {HTMLCanvasElement} canvas - Das Canvas-Element.
 * @param {CanvasRenderingContext2D} ctx - Der Kontext.
 */
function drawRotateBoard(board, canvas, ctx) {
    if (!board || !board.grid) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const padding = 40; 
    const maxDim = Math.max(board.rows, board.cols);
    
    if (maxDim === 0) return;

    const bs = (canvas.width - padding) / maxDim; 
    const ox = (canvas.width - (board.cols * bs)) / 2;
    const oy = (canvas.height - (board.rows * bs)) / 2;

    for (let r = 0; r < board.rows; r++) {
        for (let c = 0; c < board.cols; c++) {
            const v = board.grid[r][c];
            const x = ox + c * bs;
            const y = oy + r * bs;
            
            if (v === -2) { 
                ctx.fillStyle = '#2c3e50'; 
                ctx.fillRect(x, y, bs, bs); 
            } else if (v === -3) { 
                ctx.fillStyle = '#ecf0f1'; 
                ctx.fillRect(x, y, bs, bs);
                ctx.strokeStyle = '#e74c3c'; 
                ctx.lineWidth = 2; 
                ctx.strokeRect(x+2, y+2, bs-4, bs-4);
            } else if (v >= 0) {
                // Animation Offset beachten
                const off = (board.fallOffsets && board.fallOffsets[v]) ? board.fallOffsets[v] : 0;
                ctx.fillStyle = COLORS[v % COLORS.length];
                ctx.fillRect(x + 1, y - (off * bs) + 1, bs - 2, bs - 2);
            }
        }
    }
}

/**
 * Animiert das Fallen der Bl√∂cke.
 * @param {RotateBoard} board 
 * @param {HTMLCanvasElement} canvas 
 * @param {CanvasRenderingContext2D} ctx 
 * @param {number} speed - Dummy parameter, Geschwindigkeit ist hardcoded.
 * @param {function} renderCallback - Callback zum Neuzeichnen nach jedem Frame.
 * @returns {Promise<void>}
 */
async function animateRelax(board, canvas, ctx, speed, renderCallback) {
    board.isFalling = true;
    let changed = true;
    while (changed) {
        changed = false;
        let toFall = new Set();
        // Identifizieren
        for (let r = 0; r < board.rows; r++) {
            for (let c = 0; c < board.cols; c++) {
                const id = board.grid[r][c];
                if (id >= 0 && !toFall.has(id) && board.canFall(id)) toFall.add(id);
            }
        }
        // Animieren
        if (toFall.size > 0) {
            changed = true;
            // Logik update
            toFall.forEach(id => board.moveDown(id));
            
            // Visuelle Interpolation
            await new Promise(res => {
                let off = 1.0;
                function frame() {
                    off -= 0.15;
                    toFall.forEach(id => board.fallOffsets[id] = off);
                    renderCallback();
                    if (off > 0) requestAnimationFrame(frame);
                    else { 
                        toFall.forEach(id => delete board.fallOffsets[id]); 
                        res(); 
                    }
                }
                frame();
            });
        }
    }
    board.isFalling = false;
}

/* --- FILE: js/games/rotatebox/logic.js --- */
/**
 * Kernlogik f√ºr das RotateBox Spiel.
 * @fileoverview 
 * Definiert den Spielzustand, das Parsen der Level und die Physik.
 */

/**
 * Repr√§sentiert das Spielbrett und dessen Zustand.
 * Implementiert das GameState Interface f√ºr die KI.
 * @implements {GameState}
 */
class RotateBoard {
    /**
     * Erstellt eine neue Board-Instanz.
     * @param {string|null} idOrData - Die Level-ID ('0'-'3') oder null (f√ºr leeres Board/Klonen).
     */
    constructor(idOrData) {
        /** @type {number} Anzahl der get√§tigten Z√ºge. */
        this.moves = 0;
        /** @type {boolean} Gibt an, ob das Ziel erreicht wurde. */
        this.won = false;
        /** @type {boolean} Flag f√ºr laufende Fall-Animationen. */
        this.isFalling = false;
        /** @type {Object.<number, number>} Speichert visuelle Offsets f√ºr fallende Boxen. */
        this.fallOffsets = {};
        
        // Grid Dimensionen
        this.rows = 0;
        this.cols = 0;
        /** 
         * Das Spielfeld als 2D-Array (-2=Wand, -1=Leer, -3=Ziel, >=0 BoxID).
         * @type {number[][]} 
         *  */
        this.grid = [];

        // Bei null (z.B. beim Klonen) keine Initialisierung durchf√ºhren
        if (idOrData === null) return;
        
        // Level laden (Default zu '0' falls ung√ºltig)
        const id = (typeof idOrData === 'string') ? idOrData : '0';
        this.initFromId(id);
    }

    /**
     * L√§dt die Leveldaten aus den Strings.
     * WICHTIG: Die Strings enthalten Leerzeichen, die f√ºr das Layout essenziell sind.
     * @param {string} id 
     */
    initFromId(id) {
        const levels = {
            '0': "5###### 0 ##10 ##10 ####x#",
            '1': "8#########     0##     0##112222##33   4##55   4##666  4####x####",
            '2': "12#############          ##     01   ##     01   ##     01   ##    222222##  34    5 ##  34    5 ## 634    5 ## 63477775 ## 63888885 #######x#####",
            '3': "10###########        ##        ##        ##    7775##   11  5##   2 888##990233  ##44066666######x####"
        };
        
        const str = levels[id] || levels['0'];
        
        // Dimensionen parsen: Zahl am Anfang = Zeilen
        let offset = 0; 
        while (offset < str.length && str[offset] !== '#') offset++;
        
        this.rows = parseInt(str.substring(0, offset));
        const content = str.substring(offset);
        this.cols = Math.floor(content.length / this.rows);
        
        // Grid bef√ºllen
        this.grid = [];
        for (let r = 0; r < this.rows; r++) {
            let row = [];
            for (let c = 0; c < this.cols; c++) {
                const idx = r * this.cols + c;
                if (idx < content.length) {
                    const char = content[idx];
                    let val = -1; // Standard: Leer
                    
                    if (char === '#') val = -2;      // Wand
                    else if (char === 'x') val = -3; // Ziel
                    else if (char !== ' ') {         // Box (Zahl)
                        const p = parseInt(char);
                        if (!isNaN(p)) val = p;
                    }
                    row.push(val);
                } else {
                    row.push(-1);
                }
            }
            this.grid.push(row);
        }
    }

    /**
     * Rotiert das Spielfeld um 90 Grad.
     * - True f√ºr Rechtsdrehung, False f√ºr Links.
     * @param {boolean} [clockwise=true] 
     */
    rotate(clockwise = true) {
        const newGrid = Array.from({ length: this.cols }, () => Array(this.rows).fill(-1));
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                if (clockwise) newGrid[c][this.rows - 1 - r] = this.grid[r][c];
                else newGrid[this.cols - 1 - c][r] = this.grid[r][c];
            }
        }
        this.grid = newGrid;
        // Dimensionen tauschen
        [this.rows, this.cols] = [this.cols, this.rows];
        this.moves++;
    }

    /**
     * Pr√ºft, ob eine Box physikalisch fallen kann.
     *  Die ID der Box.
     * @param {number} id
     * True, wenn der Weg nach unten frei ist.
     * @returns {boolean} 
     */
    canFall(id) {
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                if (this.grid[r][c] === id) {
                    // Boden erreicht?
                    if (r + 1 >= this.rows) return false;
                    
                    const target = this.grid[r + 1][c];
                    // Blockiert, wenn darunter NICHT (Leer ODER Ziel ODER Selbst) ist
                    if (target !== -1 && target !== -3 && target !== id) return false;
                }
            }
        }
        return true;
    }

    /**
     * Bewegt eine Box logisch um ein Feld nach unten.
     * Die ID der Box.
     * @param {number} id 
     */
    moveDown(id) {
        let reachedExit = false;
        // Wichtig: Iteration von unten nach oben, um √úberschreiben zu vermeiden
        for (let r = this.rows - 1; r >= 0; r--) {
            for (let c = 0; c < this.cols; c++) {
                if (this.grid[r][c] === id) {
                    // Pr√ºfen ob Ziel erreicht (-3)
                    if (this.grid[r + 1][c] === -3) reachedExit = true;
                    
                    // Box an neue Position setzen (au√üer sie verschwindet im Ziel)
                    if (this.grid[r + 1][c] !== -3) {
                        this.grid[r + 1][c] = id;
                    }
                    
                    // Alte Position leeren
                    this.grid[r][c] = -1;
                }
            }
        }
        if (reachedExit) this.won = true;
    }

    /**
     * L√§sst alle Boxen fallen, bis sie stabil liegen.
     * Wird synchron ausgef√ºhrt (ohne Animation), z.B. f√ºr KI-Vorberechnung.
     */
    relaxBoardSync() {
        let changed = true;
        while (changed) {
            changed = false;
            let seen = new Set();
            // Scan von unten nach oben
            for (let r = this.rows - 2; r >= 0; r--) {
                for (let c = 0; c < this.cols; c++) {
                    const id = this.grid[r][c];
                    // Wenn es eine Box ist (>=0), wir sie noch nicht bewegt haben und sie fallen kann
                    if (id >= 0 && !seen.has(id) && this.canFall(id)) {
                        this.moveDown(id); 
                        seen.add(id); 
                        changed = true;
                    }
                }
            }
        }
    }

    /**
     * Erstellt eine tiefe Kopie des aktuellen Boards.
     * Die Kopie.
     * @returns {RotateBoard} 
     */
    clone() {
        const c = new RotateBoard(null);
        c.rows = this.rows; 
        c.cols = this.cols; 
        c.won = this.won;
        c.grid = this.grid.map(row => [...row]);
        c.moves = this.moves;
        return c;
    }

    // --- KI Interface Methoden ---

    /**
     * Generiert einen eindeutigen Schl√ºssel f√ºr den Zustand (f√ºr HashMaps).
     * String-Repr√§sentation des Grids.
     * @returns {string} 
     */
    getStateKey() { 
        return this.grid.map(r => r.join(',')).join('|'); 
    }

    /**
     * Pr√ºft, ob das Spiel gewonnen ist.
     * @returns {boolean}
     */
    isGoal() { 
        return this.won; 
    }
    
    /**
     * Liefert alle m√∂glichen Nachfolgezust√§nde.
     * @returns {Array<{move: string, state: RotateBoard}>}
     */
    getNextStates() {
        if (this.won) return [];
        // RotateBox hat immer zwei m√∂gliche Z√ºge: Links (L) und Rechts (R)
        return ['L', 'R'].map(dir => {
            const next = this.clone();
            next.rotate(dir === 'R'); // Rotation ausf√ºhren
            next.relaxBoardSync();    // Physik anwenden (Fallen)
            return { move: dir, state: next };
        });
    }
}

/* --- FILE: js/games/rotatebox/solver.js --- */
/**
 * @fileoverview KI-Solver Wrapper f√ºr RotateBox.
 * Nutzt die generische SearchEngine, um das Level zu l√∂sen.
 */

/**
 * Findet den k√ºrzesten Weg mittels Breitensuche (BFS).
 * Wrapper f√ºr SearchEngine, der asynchron l√§uft um das UI nicht zu blockieren.
 * * @param {RotateBoard} startBoard - Der Startzustand.
 * @returns {Promise<{path: string[], nodes: number}|null>} Das Ergebnisobjekt oder null.
 */
async function solveBFS(startBoard) {
    if (!startBoard) return null;

    // SearchEngine aus shared/js/ai/search-algorithms.js nutzen
    const engine = new SearchEngine({
        strategy: 'BFS', 
        maxDepth: 100, // Sicherheitslimit
        checkDuplicates: true
    });

    // Promise Wrapper f√ºr Asynchronit√§t
    return new Promise((resolve) => {
        // Kleiner Timeout gibt dem Browser Zeit zum Rendern
        setTimeout(async () => {
            const result = await engine.solve(startBoard);
            
            if (result.success) {
                resolve({
                    path: result.path, // Array von Z√ºgen ['L', 'R', ...]
                    nodes: result.nodesVisited
                });
            } else {
                resolve(null);
            }
        }, 10);
    });
}

/* --- FILE: js/games/rotatebox/controller.js --- */
/**
 * Controller RotateBox.
 * @fileoverview 
 */
const RotateController = {
    currentBoard: null,
    optimalPath: [],
    isOffPath: false,
    isAnimating: false,
    canvas: null,
    ctx: null,

    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');

        document.getElementById('boardSelect').onchange = () => this.reset();
        document.getElementById('resetBtn').onclick = () => this.reset();
        document.getElementById('solveBtn').onclick = () => this.runAISolver();
        
        const animBtn = document.getElementById('animateBtn');
        if (animBtn) animBtn.onclick = () => this.playSolution();

        window.addEventListener('keydown', (e) => {
            if (["ArrowLeft", "ArrowRight"].includes(e.key)) e.preventDefault();
            if (e.key === 'ArrowLeft') this.handleMove(false);
            if (e.key === 'ArrowRight') this.handleMove(true);
        });

        this.reset();
    },

    reset() {
        const selector = document.getElementById('boardSelect');
        this.currentBoard = new RotateBoard(selector.value);
        this.optimalPath = []; 
        this.isOffPath = false;
        this.isAnimating = false;
      
        document.getElementById('winMessage').classList.add('hidden');
        document.getElementById('aiOutput').classList.add('hidden');
        document.getElementById('pathWarning').classList.add('hidden');
        document.getElementById('solutionPath').innerHTML = '';
        
        document.getElementById('solveBtn').disabled = false;
        document.getElementById('solveBtn').innerText = "KI L√∂sung suchen üß†";
        
        this.updateStats();
        this.render();
    },

    async handleMove(isRight) {
        if (!this.currentBoard || this.currentBoard.won || this.isAnimating) return;
        
        const moveChar = isRight ? 'R' : 'L';
        this.currentBoard.rotate(isRight);

        // Pfad-Check
        if (this.optimalPath.length > 0 && !this.isOffPath) {
            // moves ist 1-basiert, Array ist 0-basiert
            if (moveChar !== this.optimalPath[this.currentBoard.moves - 1]) {
                this.isOffPath = true;
                document.getElementById('pathWarning').classList.remove('hidden');
            }
        }

        // --- HIGHLIGHTING LOGIK ---
        this.updatePathHighlighting();

        const useAnimation = document.getElementById('animateToggle').checked;
        if (useAnimation) {
            this.isAnimating = true;
            await animateRelax(this.currentBoard, this.canvas, this.ctx, 0.15, () => this.render());
            this.isAnimating = false;
        } else {
            this.currentBoard.relaxBoardSync(); 
            this.render();
        }
        
        if (this.currentBoard.won) {
            document.getElementById('winMessage').classList.remove('hidden');
        }
        this.updateStats();
        this.render();
    },

    updatePathHighlighting() {
        // 1. Alle entfernen
        document.querySelectorAll('.step-badge').forEach(el => el.classList.remove('active'));
        
        // 2. Aktuellen finden
        // Wir suchen das Badge mit der ID "step-X", wobei X der aktuelle Move-Count ist.
        // Bsp: Nach 1. Zug (moves=1) soll Badge "step-1" leuchten.
        const currentMove = this.currentBoard.moves;
        const activeBadge = document.getElementById(`step-${currentMove}`);
        
        if (activeBadge) {
            activeBadge.classList.add('active');
            // Auto-Scroll, damit das Badge sichtbar bleibt
            activeBadge.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
    },

    render() {
        if (!this.currentBoard) return;
        drawRotateBoard(this.currentBoard, this.canvas, this.ctx);
    },
    
    updateStats() {
        document.getElementById('moveCount').innerText = this.currentBoard.moves;
    },

    async runAISolver() {
        const btn = document.getElementById('solveBtn');
        btn.disabled = true;
        btn.innerText = "Rechne...";
        
        const simBoard = this.currentBoard.clone(); 
        const result = await solveBFS(simBoard);
        
        if (result) {
            this.optimalPath = result.path;
            
            document.getElementById('aiOutput').classList.remove('hidden');
            document.getElementById('stat-depth').innerText = result.path.length;
            document.getElementById('stat-nodes').innerText = result.nodes;
            
            const pathDiv = document.getElementById('solutionPath');
            pathDiv.innerHTML = '';
            
            // Badges rendern
            // Start-Offset: Falls User schon 5 Z√ºge gemacht hat, beginnt der Pfad bei Schritt 6.
            const startMove = this.currentBoard.moves;
            
            result.path.forEach((dir, i) => {
                const span = document.createElement('span');
                span.className = 'step-badge';
                // ID generieren: step-(Start + Index + 1)
                span.id = `step-${startMove + i + 1}`;
                span.innerText = dir;
                pathDiv.appendChild(span);
            });
            
            this.isOffPath = false;
            document.getElementById('pathWarning').classList.add('hidden');
            btn.innerText = "L√∂sung anzeigen";
        } else {
            alert("Keine L√∂sung gefunden!");
            btn.innerText = "Nichts gefunden";
        }
        
        btn.disabled = false;
    },

    async playSolution() {
        if (this.optimalPath.length === 0 || this.isAnimating) return;
        
        this.reset();
        await new Promise(r => setTimeout(r, 200));
        await this.runAISolver(); 
        
        for (const move of this.optimalPath) {
            if(this.currentBoard.won) break;
            await this.handleMove(move === 'R');
            await new Promise(r => setTimeout(r, 250));
        }
    }
};

window.onload = () => RotateController.init();

/* --- FILE: js/games/rotatebox/tree-adapter.js --- */
/**
 * @fileoverview Adapter, der RotateBox-Zust√§nde in einen Visualisierungs-Baum wandelt.
 */

const RotateBoxAdapter = {
    
    /**
     * Generiert den Suchbaum.
     * @param {RotateBoard} startBoard - Der Startzustand.
     * @param {Object} options - Parameter (Tiefe, Algo, Duplikate).
     * @returns {TreeNode} Der Wurzelknoten.
     */
    generateTree(startBoard, options = {}) {
        const {
            maxDepth = 3,
            checkDuplicates = true,
            algorithm = 'BFS', // 'BFS' oder 'DFS'
            continueAfterSolution = false
        } = options;

        let nodeId = 0;
        // TreeNode Klasse muss global verf√ºgbar sein (durch tree-engine.js)
        const root = new TreeNode(nodeId++, startBoard.clone(), 0);
        
        // Speicher f√ºr besuchte Zust√§nde: Map<StateHash, Depth>
        const visitedStates = new Map();
        visitedStates.set(startBoard.getStateKey(), 0);

        // Queue/Stack f√ºr die Traversierung
        let toVisit = [root];

        while (toVisit.length > 0) {
            // Strategie w√§hlen: BFS (Queue/Shift) oder DFS (Stack/Pop)
            const currentNode = (algorithm === 'DFS') ? toVisit.pop() : toVisit.shift();

            // 1. Abbruchbedingungen
            if (currentNode.depth >= maxDepth) continue;
            
            // Wenn Knoten als Duplikat markiert wurde, hier stoppen (keine Kinder)
            if (currentNode.isDuplicate) continue; 
            
            // Wenn L√∂sung gefunden und wir nicht weitermachen sollen -> Stopp
            if (currentNode.isSolution && !continueAfterSolution) continue;

            // 2. Nachfolger generieren
            // RotateBox hat immer Z√ºge: 'L' und 'R'
            // F√ºr DFS drehen wir die Reihenfolge um, damit die Abarbeitung nat√ºrlich wirkt
            const moves = (algorithm === 'DFS') ? ['R', 'L'] : ['L', 'R'];

            moves.forEach(move => {
                // Neuen Zustand berechnen
                const nextBoard = currentNode.data.clone();
                nextBoard.rotate(move === 'R');
                nextBoard.relaxBoardSync(); // Physik anwenden
                
                const child = new TreeNode(nodeId++, nextBoard, currentNode.depth + 1, move);
                const stateKey = nextBoard.getStateKey();

                // Zielpr√ºfung
                if (nextBoard.won) {
                    child.isSolution = true;
                    child.annotation = "ZIEL";
                }

                // Duplikatspr√ºfung
                let isDup = false;
                if (checkDuplicates) {
                    if (visitedStates.has(stateKey)) {
                        const previousDepth = visitedStates.get(stateKey);
                        
                        // Wenn wir diesen Zustand schon mal auf gleicher oder besserer Ebene hatten
                        if (child.depth >= previousDepth) {
                            isDup = true;
                            child.isDuplicate = true;
                            child.annotation = "Duplikat";
                        } else {
                            // Besserer Weg gefunden (passiert bei DFS oft) -> Update
                            visitedStates.set(stateKey, child.depth);
                        }
                    } else {
                        // Neu entdeckt
                        visitedStates.set(stateKey, child.depth);
                    }
                }

                currentNode.children.push(child);

                // Zur Liste hinzuf√ºgen, wenn kein Duplikat (oder wir weitersuchen)
                if (!isDup) {
                    // Wenn es eine L√∂sung ist und wir stoppen sollen -> nicht in Queue
                    if (!child.isSolution || continueAfterSolution) {
                        toVisit.push(child);
                    }
                }
            });
        }

        return root;
    }
};

/* --- FILE: learning/viewer.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Lernpfad Viewer</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        body { display: flex; height: 100vh; overflow: hidden; margin: 0; background: #2c3e50; }
        
        /* Sidebar Styles */
        .sidebar { width: 280px; background: #2c3e50; color: white; display: flex; flex-direction: column; border-right: 1px solid #34495e; }
        .sidebar-header { padding: 20px; background: #1a252f; }
        .back-link { color: #bdc3c7; text-decoration: none; font-size: 0.9rem; display: block; margin-bottom: 10px; }
        .path-title { font-size: 1.1rem; font-weight: bold; color: #ecf0f1; }
        
        .step-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex: 1; }
        .step-item { padding: 15px 20px; border-bottom: 1px solid #34495e; cursor: pointer; transition: background 0.2s; color: #bdc3c7; }
        .step-item:hover { background: #34495e; color: white; }
        .step-item.active { background: #3498db; color: white; font-weight: bold; border-left: 5px solid #f1c40f; }
        
        /* Content Area */
        .content-area { flex: 1; display: flex; flex-direction: column; background: white; position: relative; }
        iframe { flex: 1; border: none; width: 100%; height: 100%; }
        
        /* Navigation Bar unten */
        .nav-bar { 
            height: 60px; background: #f8f9fa; border-top: 1px solid #ddd; 
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px; 
        }
        .progress-text { font-weight: bold; color: #7f8c8d; }
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="sidebar-header">
            <a href="../index.html" class="back-link">‚¨Ö Hauptmen√º</a>
            <div id="pathTitle" class="path-title">Lade Kurs...</div>
        </div>
        <ul id="stepList" class="step-list"></ul>
    </div>

    <div class="content-area">
        <iframe id="contentFrame" name="contentFrame"></iframe>
        
        <div class="nav-bar">
            <button class="viz-btn btn-back" id="prevBtn" onclick="Viewer.prev()">Zur√ºck</button>
            <span id="progressText" class="progress-text">-- / --</span>
            <button class="viz-btn btn-action" id="nextBtn" onclick="Viewer.next()">Weiter ‚ñ∂</button>
        </div>
    </div>

    <script src="data/paths.js"></script>

    <script>
        const Viewer = {
            pathId: null,
            currentStepIndex: 0,
            pathData: null,

            init() {
                // Liest ?path=xyz aus der URL
                const params = new URLSearchParams(window.location.search);
                this.pathId = params.get('path');

                if (!this.pathId || !LEARNING_PATHS[this.pathId]) {
                    alert("Lernpfad nicht gefunden!");
                    window.location.href = "../index.html";
                    return;
                }

                this.pathData = LEARNING_PATHS[this.pathId];
                this.renderSidebar();
                this.loadStep(0);
            },

            renderSidebar() {
                document.getElementById('pathTitle').innerText = this.pathData.title;
                const list = document.getElementById('stepList');
                list.innerHTML = '';

                this.pathData.steps.forEach((step, index) => {
                    const li = document.createElement('li');
                    li.className = 'step-item';
                    li.id = `step-btn-${index}`;
                    li.innerText = step.title;
                    li.onclick = () => this.loadStep(index);
                    list.appendChild(li);
                });
            },

            loadStep(index) {
                if (index < 0 || index >= this.pathData.steps.length) return;
                
                this.currentStepIndex = index;
                const step = this.pathData.steps[index];

                // WICHTIG: Pfad zum Modul bauen (modules/ + Unterordner/Datei)
                const modulePath = `modules/${step.file}`;
                document.getElementById('contentFrame').src = modulePath;

                // UI Updates
                document.querySelectorAll('.step-item').forEach(el => el.classList.remove('active'));
                const activeBtn = document.getElementById(`step-btn-${index}`);
                if(activeBtn) activeBtn.classList.add('active');
                if(activeBtn) activeBtn.scrollIntoView({ block: 'nearest' });

                document.getElementById('progressText').innerText = 
                    `Schritt ${index + 1} von ${this.pathData.steps.length}`;

                // Buttons
                document.getElementById('prevBtn').disabled = (index === 0);
                
                const nextBtn = document.getElementById('nextBtn');
                if (index === this.pathData.steps.length - 1) {
                    nextBtn.innerText = "Abschlie√üen üèÅ";
                    nextBtn.className = "viz-btn btn-restart"; // Gelb
                    nextBtn.onclick = () => {
                        if(confirm("Gl√ºckwunsch! Zur√ºck zum Men√º?")) window.location.href = "../index.html";
                    };
                } else {
                    nextBtn.innerText = "Weiter ‚ñ∂";
                    nextBtn.className = "viz-btn btn-action"; // Gr√ºn/Blau
                    nextBtn.onclick = () => this.next();
                }
            },

            next() { this.loadStep(this.currentStepIndex + 1); },
            prev() { this.loadStep(this.currentStepIndex - 1); }
        };

        window.onload = () => Viewer.init();
    </script>
</body>
</html>

/* --- FILE: learning/modules/search/bfs-demo.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="stylesheet" href="../../../css/style.css">
    <link rel="stylesheet" href="../../../css/tree-viz.css">
    <style>
        body { padding: 20px; background: white; height: 100vh; display: flex; flex-direction: column; box-sizing: border-box; }
        .layout { display: flex; gap: 20px; flex: 1; min-height: 0; }
        .text-col { flex: 1; overflow-y: auto; padding-right: 15px; }
        .viz-col { flex: 1.5; display: flex; flex-direction: column; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9; }
        .canvas-area { flex: 1; position: relative; overflow: hidden; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div class="layout">
        <div class="text-col">
            <h2>Breitensuche (BFS)</h2>
            <p>Die Breitensuche arbeitet sich Schicht f√ºr Schicht vor. Sie ist optimal, um den k√ºrzesten Weg zu finden.</p>
            
            <div class="viz-control-group">
                <label class="viz-label">Maximale Tiefe:</label>
                <input type="range" id="depthInput" min="1" max="6" value="3" oninput="updateDemo()">
                <span id="depthVal">3</span>
            </div>
            
            <p><strong>Beobachtung:</strong><br>
            Achte darauf, wie der Baum gleichm√§√üig in die Breite w√§chst. Alle Knoten auf Tiefe 1 werden besucht, bevor Tiefe 2 beginnt.</p>
        </div>

        <div class="viz-col">
            <div class="canvas-area" id="canvasContainer">
                <canvas id="treeCanvas"></canvas>
            </div>
        </div>
    </div>

    <script src="../../../js/core/game-state.js"></script>
    <script src="../../../js/games/rotatebox/logic.js"></script>
    <script src="../../../js/games/rotatebox/tree-adapter.js"></script>
    <script src="../../../js/games/rotatebox/renderer.js"></script>
    <script src="../../../js/viz/tree-engine.js"></script>

    <script>
        // Kleiner Inline-Controller f√ºr dieses Modul
        let viz;
        
        window.onload = () => {
            viz = new TreeVisualizer('treeCanvas');
            updateDemo();
        };

        function updateDemo() {
            const depth = parseInt(document.getElementById('depthInput').value);
            document.getElementById('depthVal').innerText = depth;

            // 1. Board erstellen (Level 1)
            const board = new RotateBoard('1');
            
            // 2. Baum generieren (BFS)
            const root = RotateBoxAdapter.generateTree(board, {
                maxDepth: depth,
                algorithm: 'BFS',
                checkDuplicates: true
            });

            // 3. Zeichnen
            viz.drawTree(root, {
                drawNodeFn: (ctx, data, size) => {
                    const mock = { width: size, height: size };
                    drawRotateBoard(data, mock, ctx);
                },
                config: { nodeSize: 50, levelHeight: 80 }
            });
        }
    </script>
</body>
</html>

/* --- FILE: learning/modules/what-is-state-html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Was ist ein Zustand?</title>
    <link rel="stylesheet" href="../../../css/style.css">
    <style>
        body { padding: 40px; background: white; max-width: 800px; margin: 0 auto; line-height: 1.6; }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .box { background: #ecf0f1; padding: 20px; border-left: 5px solid #3498db; margin: 20px 0; border-radius: 4px; }
        .img-placeholder { width: 100%; height: 200px; background: #eee; display: flex; align-items: center; justify-content: center; color: #7f8c8d; border: 1px dashed #bdc3c7; margin: 20px 0; }
    </style>
</head>
<body>

    <h1>Was ist ein "Zustand"?</h1>

    <p>Bevor wir √ºber Algorithmen wie <strong>Breitensuche</strong> oder <strong>Minimax</strong> sprechen k√∂nnen, m√ºssen wir verstehen, wie ein Computer die Welt sieht.</p>

    <div class="box">
        <strong>Definition:</strong> Ein Zustand (State) ist eine Momentaufnahme des Spiels, die alle Informationen enth√§lt, die n√∂tig sind, um das Spiel fortzusetzen.
    </div>

    <h3>Beispiel: RotateBox</h3>
    <p>In unserem RotateBox Spiel besteht der Zustand aus:</p>
    <ul>
        <li>Der Position aller Kisten (bunte Quadrate).</li>
        <li>Der Position der W√§nde (grau).</li>
        <li>Der Orientierung des Brettes (oben/unten).</li>
    </ul>

    <div class="img-placeholder">
        (Hier k√∂nnte eine Canvas-Visualisierung eines statischen Boards sein)
    </div>

    <h3>Warum ist das wichtig?</h3>
    <p>Algorithmen "denken" nicht wie Menschen. Sie betrachten das L√∂sen eines Problems als eine Reise von <strong>Zustand zu Zustand</strong>.</p>
    <p>Im n√§chsten Schritt schauen wir uns an, wie wir aus einem Zustand einen Baum aus M√∂glichkeiten generieren.</p>

</body>
</html>

/* --- FILE: learning/data/paths.js --- */
/**
 * @typedef {Object} LearningStep
 * @property {string} file - Der Pfad zur Modul-Datei (relativ zu learning/modules/).
 * @property {string} title - Der Titel des Schritts f√ºr die Anzeige.
 */

/**
 * @typedef {Object} LearningPath
 * @property {string} title - Der Gesamttitel des Kurses.
 * @property {LearningStep[]} steps - Die Schritte des Kurses.
 */

/**
 * Definition aller verf√ºgbaren Lernpfade.
 * Wird vom viewer.html geladen.
 * * @type {Object.<string, LearningPath>}
 */
const LEARNING_PATHS = {
    "search-algo": {
        "title": "Grundlagen der Suche",
        "steps": [
            { 
                "file": "intro/what-is-state.html", 
                "title": "1. Was ist ein Zustand?" 
            },
            { 
                "file": "search/bfs-demo.html", 
                "title": "2. Interaktiv: Breitensuche (BFS)" 
            }
        ]
    },
    "minimax": {
        "title": "Unschlagbare KI (Minimax)",
        "steps": [
            { 
                "file": "intro/what-is-state.html", 
                "title": "1. Wiederholung: Zust√§nde" 
            },
            { 
                "file": "adversarial/intro-minimax.html", 
                "title": "2. Das Minimax Prinzip" 
            }
        ]
    }
};

/* --- FILE: playground/rotatebox-viz.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suchbaum Visualisierung</title>
    
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/tree-viz.css">
    
    <style>
        /* Override f√ºr Full-Screen Layout */
        body { 
            margin: 0; 
            font-family: 'Segoe UI', sans-serif; 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            overflow: hidden; 
            background: #f0f3f4;
        }
    </style>
</head>
<body>

    <div class="viz-toolbar">
        <a href="../index.html" class="viz-btn btn-back">‚¨Ö Men√º</a>
        
        <div class="viz-control-group">
            <label class="viz-label">Level</label>
            <select id="levelSelect" class="viz-select">
                <option value="0">Tutorial</option>
                <option value="1">Level 1 (Einfach)</option>
                <option value="2">Level 2 (Mittel)</option>
                <option value="3">Level 3 (Komplex)</option>
            </select>
        </div>

        <div class="viz-control-group">
            <label class="viz-label">Tiefe</label>
            <input type="number" id="depthInput" value="4" min="1" max="15" class="viz-input" style="width: 60px;">
        </div>

        <div class="viz-control-group">
            <label class="viz-label">Algo</label>
            <select id="algoSelect" class="viz-select">
                <option value="BFS">Breitensuche (BFS)</option>
                <option value="DFS">Tiefensuche (DFS)</option>
            </select>
        </div>

        <div class="viz-checkboxes">
            <label class="viz-checkbox-label">
                <input type="checkbox" id="chkDuplicates" checked> Duplikate markieren
            </label>
            <label class="viz-checkbox-label">
                <input type="checkbox" id="chkContinueSol"> Nach Ziel weiter
            </label>
            <button class="viz-btn btn-action" onclick="updateTree()">Baum generieren</button>
        </div>

        <div id="stats" class="viz-stats">Bereit.</div>

        
    </div>

    <div class="viz-container">
        <canvas id="treeCanvas" class="viz-canvas"></canvas>
    </div>

    <script src="../js/core/game-state.js"></script>
    
    <script src="../js/games/rotatebox/logic.js"></script>
    
    <script src="../js/viz/tree-engine.js"></script>
    <script src="../js/games/rotatebox/tree-adapter.js"></script>

    <script>
        // Visualisierer initialisieren
        const viz = new TreeVisualizer('treeCanvas');

        /**
         * Hilfsfunktion: Zeichnet das Board kompakt in den Node.
         * Zeichnet einfache Rechtecke statt der aufw√§ndigen Grafik des Hauptspiels,
         * um Performance zu sparen und bei kleinen Nodes lesbar zu bleiben.
         */
        function drawCompactBoard(ctx, board, size) {
            const COLORS = ['#e74c3c', '#2ecc71', '#f1c40f', '#3498db', '#e67e22'];
            
            const maxDim = Math.max(board.rows, board.cols);
            if (maxDim === 0) return;
            
            // Blockgr√∂√üe berechnen
            const bs = size / maxDim; 
            const ox = (size - (board.cols * bs)) / 2;
            const oy = (size - (board.rows * bs)) / 2;

            for (let r = 0; r < board.rows; r++) {
                for (let c = 0; c < board.cols; c++) {
                    const v = board.grid[r][c];
                    const x = ox + c * bs;
                    const y = oy + r * bs;
                    
                    if (v === -2) { // Wand
                        ctx.fillStyle = '#2c3e50'; 
                        ctx.fillRect(x, y, bs, bs); 
                    } else if (v === -3) { // Ziel
                        ctx.fillStyle = '#ecf0f1';
                        ctx.fillRect(x, y, bs, bs);
                        ctx.strokeStyle = '#e74c3c'; 
                        ctx.lineWidth = 2; 
                        ctx.strokeRect(x+1, y+1, bs-2, bs-2);
                    } else if (v >= 0) { // Box
                        ctx.fillStyle = COLORS[v % COLORS.length];
                        ctx.fillRect(x+1, y+1, bs-2, bs-2);
                    }
                }
            }
        }

        /**
         * Wird beim Klick auf "Generieren" aufgerufen.
         */
        function updateTree() {
            // 1. UI Werte lesen
            const levelId = document.getElementById('levelSelect').value;
            const options = {
                maxDepth: parseInt(document.getElementById('depthInput').value),
                algorithm: document.getElementById('algoSelect').value,
                checkDuplicates: document.getElementById('chkDuplicates').checked,
                continueAfterSolution: document.getElementById('chkContinueSol').checked
            };

            // 2. Startzustand laden
            const startBoard = new RotateBoard(levelId); // Nutzt logic.js
            
            // 3. Baum generieren (Adapter)
            const root = RotateBoxAdapter.generateTree(startBoard, options);

            // 4. Statistik (Nodes z√§hlen)
            let count = 0;
            const countNodes = (n) => { count++; n.children.forEach(countNodes); };
            countNodes(root);
            document.getElementById('stats').innerText = `Nodes: ${count}`;

            // 5. Zeichnen (Engine)
            viz.drawTree(root, { 
                drawNodeFn: drawCompactBoard,
                config: { nodePadding: 2 } 
            });
        }

        // Starten beim Laden
        window.onload = updateTree;
    </script>
</body>
</html>

/* --- FILE: playground/arena.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>KI Arena</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        .arena-card { background: white; padding: 20px; border-radius: 8px; width: 280px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 10px; }
        .vs-badge { font-size: 2rem; font-weight: bold; color: #bdc3c7; margin: 0 20px; }
        .result-box { display: flex; justify-content: space-between; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 1.1rem; }
    </style>
</head>
<body>
    <div class="viz-toolbar">
        <a href="../index.html" class="viz-btn btn-back">‚¨Ö Men√º</a>
        <span style="margin-left:10px; font-weight:bold; color:white;">KI Arena Simulator</span>
    </div>

    <div class="main-area" style="flex-direction: row; align-items: flex-start; gap: 30px; padding-top: 40px; flex-wrap: wrap; justify-content: center;">
        
        <div class="arena-card">
            <h3 style="color:#3498db; margin:0; border-bottom:2px solid #3498db; padding-bottom:5px;">Spieler 1 (Blau)</h3>
            <div class="viz-control-group">
                <label class="viz-label">Agent Typ</label>
                <select id="p1Select" class="viz-select">
                    <option value="random">Random Agent</option>
                    <option value="rulebased">Rule Based Agent</option>
                </select>
            </div>
            <div class="result-box">
                <span>Siege:</span>
                <strong id="resP1" style="color:#3498db">0</strong>
            </div>
        </div>

        <div style="display:flex; flex-direction:column; align-items:center; gap:15px; background:white; padding:20px; border-radius:8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
            <div class="vs-badge">VS</div>
            <div class="viz-control-group" style="width: 100%;">
                <label class="viz-label">Spielart</label>
                <select id="gameTypeSelect" class="viz-select">
                    <option value="regular">TTT Klassik</option>
                    <option value="ultimate">Ultimate TTT</option>
                    <option value="3d">3D TTT</option>
                </select>
            </div>
            <div class="viz-control-group" style="width: 100%;">
                <label class="viz-label">Runden Anzahl</label>
                <input type="number" id="roundsInput" value="100" class="viz-input">
            </div>
            <button class="viz-btn btn-action" style="width:100%" onclick="runArena()">Simulation Starten</button>
            
            <div id="status" style="margin-top:10px; color:#7f8c8d; font-size:0.9rem;">Bereit</div>
            
            <div class="result-box" style="width: 100%; box-sizing: border-box;">
                <span>Remis:</span>
                <strong id="resDraw">0</strong>
            </div>
             <div class="result-box" style="width: 100%; box-sizing: border-box;">
                <span>Zeit:</span>
                <strong id="resTime">-</strong>
            </div>
        </div>

        <div class="arena-card">
            <h3 style="color:#e74c3c; margin:0; border-bottom:2px solid #e74c3c; padding-bottom:5px;">Spieler 2 (Rot)</h3>
            <div class="viz-control-group">
                <label class="viz-label">Agent Typ</label>
                <select id="p2Select" class="viz-select">
                    <option value="random" selected>Random Agent</option>
                    <option value="rulebased">Rule Based Agent</option>
                </select>
            </div>
            <div class="result-box">
                <span>Siege:</span>
                <strong id="resP2" style="color:#e74c3c">0</strong>
            </div>
        </div>

    </div>

    <script src="../js/core/game-state.js"></script>
    <script src="../js/core/agent.js"></script>
    <script src="../js/ai/agents/random-agent.js"></script>
    <script src="../js/ai/agents/rule-based-agent.js"></script>
    <script src="../js/ai/rules/rule-structure.js"></script>
    <script src="../js/ai/rules/ttt-rules.js"></script>
    <script src="../js/games/tictactoe/logic.js"></script>
    <script src="../js/ai/arena.js"></script>

    <script>
        async function runArena() {
            const rounds = parseInt(document.getElementById('roundsInput').value);
            const gameType = document.getElementById('gameTypeSelect').value;
            const status = document.getElementById('status');
            
            // Factory Pattern f√ºr die Spiele
            const factory = {
                create: () => {
                    if (gameType === 'regular') return new TTTRegularBoard();
                    if (gameType === 'ultimate') return new UltimateBoard();
                    if (gameType === '3d') return new TTT3DBoard();
                }
            };

            // Agent Factory
            const createAgent = (type) => {
                if (type === 'random') return new RandomAgent();
                if (type === 'rulebased') return new RuleBasedAgent(createStrategyTree(gameType));
            };

            const p1 = createAgent(document.getElementById('p1Select').value);
            const p2 = createAgent(document.getElementById('p2Select').value);

            status.innerText = "Simuliere " + rounds + " Spiele...";
            
            const arena = new Arena(factory, p1, p2);
            
            // Start
            const res = await arena.runSeries(rounds);
            
            // Ergebnisse
            document.getElementById('resP1').innerText = res.stats[1];
            document.getElementById('resP2').innerText = res.stats[2];
            document.getElementById('resDraw').innerText = res.stats[0];
            document.getElementById('resTime').innerText = res.duration.toFixed(0) + "ms";
            
            status.innerText = "Simulation beendet.";
        }
    </script>
</body>
</html>

/* --- FILE: playground/rules-lab.html --- */
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>KI Regel-Labor</title>
    <link rel="stylesheet" href="../css/lab-style.css">
    <style>
        /* Spezifische Overrides f√ºr das Lab Layout */
        .col-game {
            /* Fixe Breite etwas verkleinert, damit Platz f√ºr Regeln bleibt */
            flex: 0 0 420px; 
            min-width: 420px;
        }
        
        /* Damit Canvas nicht ausbricht */
        .canvas-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 10px 0;
        }
        
        canvas {
            max-width: 100%;
            height: auto; /* Aspect Ratio erhalten */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        
        /* 3D Container Anpassung */
        .iso-container {
            margin-top: 15px;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 5px;
            background: #fafafa;
        }
    </style>
</head>
<body>

    <div class="lab-toolbar">
        <a href="../index.html" class="viz-btn viz-btn-back">‚¨Ö Men√º</a>
        
        <div class="viz-control-group" style="margin-left: 20px;">
            <label class="viz-label">Szenario:</label>
            <select id="gameTypeSelector" class="viz-select" onchange="Lab.changeGameType()">
                <option value="regular">Klassik 3x3</option>
                <option value="3d">3D 3x3x3</option>
                <option value="ultimate">Ultimate</option>
            </select>
        </div>

        <div style="flex-grow: 1;"></div> 

        <div class="viz-control-group">
            <button class="viz-btn viz-btn-action" onclick="Lab.stepAI()">‚ñ∂ Schritt</button>
            <button class="viz-btn viz-btn-action" id="btnAuto" onclick="Lab.toggleAutoMatch()">‚è© Auto</button>
            <button class="viz-btn viz-btn-restart" onclick="Lab.reset()">‚Ü∫ Reset</button>
        </div>
    </div>

    <div class="lab-grid">
        
        <div class="col-tree">
            <div class="panel-header" style="border-left: 5px solid #3498db;">
                <span>üß†</span> KI Blau
            </div>
            <div class="tree-container" id="treeDisplayP1"></div>
        </div>

        <div class="col-game">
            <div class="game-card">
                <div id="controls3D" class="view-controls hidden">
                    <button class="view-btn active" onclick="Lab.setAxis('z')">Ebenen</button>
                    <button class="view-btn" onclick="Lab.setAxis('y')">Vorne</button>
                    <button class="view-btn" onclick="Lab.setAxis('x')">Seite</button>
                </div>

                <div class="canvas-container">
                    <canvas id="gameCanvas" width="400" height="400"></canvas>
                </div>
                
                <div id="isoWrapper" class="iso-container hidden">
                    <div style="font-size:0.7rem; color:#888; text-align:center; margin-bottom:2px;">3D Vorschau</div>
                    <canvas id="isoCanvas" width="200" height="200"></canvas>
                </div>

                <div id="statusText" class="stats-display" style="margin-top:10px;">Bereit</div>
            </div>

            <div class="log-box" id="log">
                <div class="log-line">System bereit.</div>
            </div>
        </div>

        <div class="col-tree">
            <div class="panel-header" style="border-left: 5px solid #e74c3c;">
                <span>ü§ñ</span> KI Rot
            </div>
            <div class="tree-container" id="treeDisplayP2"></div>
        </div>
    </div>

    <script src="../js/core/game-state.js"></script>
    
    <script src="../js/games/tictactoe/logic.js"></script>
    <script src="../js/games/tictactoe/renderer.js"></script>
    
    <script src="../js/ai/rules/rule-structure.js"></script>
    <script src="../js/ai/rules/ttt-rules.js"></script>
    
    <script src="../js/viz/flowchart-visualizer.js"></script>

    <script>
        const Lab = {
            game: null, canvas: null, isoCanvas: null,
            vizP1: null, vizP2: null, trees: { 1: null, 2: null },
            gameType: 'regular', axis3D: 'z', isAuto: false,
            
            // Verz√∂gerung f√ºr Auto-Mode (in ms)
            // L√§nger, damit man das Highlighting sieht
            delay: 600, 

            init() {
                this.canvas = document.getElementById('gameCanvas');
                this.isoCanvas = document.getElementById('isoCanvas');
                this.canvas.addEventListener('mousedown', (e) => this.handleClick(e));
                this.changeGameType();
            },

            changeGameType() {
                this.gameType = document.getElementById('gameTypeSelector').value;
                const controls = document.getElementById('controls3D');
                const isoWrap = document.getElementById('isoWrapper');
                
                // Canvas Gr√∂√üen Reset
                this.canvas.width = 400; 
                this.canvas.height = 400;

                if (this.gameType === '3d') {
                    controls.classList.remove('hidden');
                    isoWrap.classList.remove('hidden');
                    // Slices brauchen weniger H√∂he (rechteckig)
                    this.canvas.height = 250; 
                } else if (this.gameType === 'ultimate') {
                    controls.classList.add('hidden');
                    isoWrap.classList.add('hidden');
                    // Ultimate braucht mehr Details -> Gr√∂√üeres internes Canvas (wird per CSS runterskaliert)
                    this.canvas.width = 600; 
                    this.canvas.height = 600;
                } else {
                    controls.classList.add('hidden');
                    isoWrap.classList.add('hidden');
                }

                // B√§ume neu laden
                this.trees[1] = createStrategyTree(this.gameType);
                this.trees[2] = createStrategyTree(this.gameType);
                
                this.vizP1 = new FlowchartVisualizer('treeDisplayP1', this.trees[1], (n) => this.toggleRule(1, n));
                this.vizP2 = new FlowchartVisualizer('treeDisplayP2', this.trees[2], (n) => this.toggleRule(2, n));
                
                this.vizP1.render();
                this.vizP2.render();
                
                this.reset();
            },

            reset() {
                if(this.gameType === 'regular') this.game = new TTTRegularBoard();
                else if(this.gameType === '3d') this.game = new TTT3DBoard(3);
                else this.game = new UltimateBoard();
                
                this.isAuto = false;
                document.getElementById('btnAuto').innerText = "‚è© Auto";
                document.getElementById('log').innerHTML = ''; // Log leeren
                this.log("--- NEUES SPIEL ---");
                
                this.vizP1.clearHighlights();
                this.vizP2.clearHighlights();
                this.draw();
                this.updateStatus();
            },

            toggleRule(player, name) {
                const toggle = (n) => {
                    if (n.name === name) n.active = !n.active;
                    if (n.children) n.children.forEach(toggle);
                    if (n.thenNode) toggle(n.thenNode);
                    if (n.elseNode) toggle(n.elseNode);
                };
                toggle(this.trees[player].root);
                if(player===1) this.vizP1.render(); else this.vizP2.render();
            },

            setAxis(axis) {
                this.axis3D = axis;
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                // Button Index Hack (z=0, y=1, x=2)
                const idx = axis==='z'?0 : axis==='y'?1 : 2;
                document.querySelectorAll('.view-btn')[idx].classList.add('active');
                this.draw();
            },

            /** Input Handler mit korrekter 3D-Berechnung */
            handleClick(e) {
                if (this.game.winner !== 0 || this.isAuto) return;

                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const mx = (e.clientX - rect.left) * scaleX;
                const my = (e.clientY - rect.top) * scaleY;

                let success = false;

                if (this.gameType === '3d') {
                    // 3D Layout Berechnung (Analog Renderer)
                    const s = 3; 
                    const w = this.canvas.width, h = this.canvas.height;
                    const pad = 20;
                    const availW = w - (pad*2), availH = h - (pad*2);
                    const boxSize = Math.min(availW/s, availH); // Max Boxgr√∂√üe
                    const gap = boxSize * 0.1;
                    const boardS = boxSize - gap;
                    
                    // Zentrierung
                    const startX = (w - s*boxSize)/2 + gap/2;
                    const startY = (h - boardS)/2 + 10;

                    for(let k=0; k<s; k++) {
                        const ox = startX + k*boxSize;
                        if(mx >= ox && mx <= ox+boardS && my >= startY && my <= startY+boardS) {
                            const c = Math.floor((mx-ox)/(boardS/s));
                            const r = Math.floor((my-startY)/(boardS/s));
                            let x,y,z;
                            if(this.axis3D==='z') { z=k; y=r; x=c; }
                            else if(this.axis3D==='y') { y=k; x=c; z=(s-1)-r; }
                            else { x=k; y=c; z=(s-1)-r; }
                            success = this.game.makeMove(z*9 + y*3 + x);
                            break;
                        }
                    }
                } 
                else if (this.gameType === 'ultimate') {
                    const bigS = this.canvas.width/3, smallS = bigS/3;
                    const bx = Math.floor(mx/bigS), by = Math.floor(my/bigS);
                    const sx = Math.floor((mx%bigS)/smallS), sy = Math.floor((my%bigS)/smallS);
                    if(bx>=0 && bx<3 && by>=0 && by<3) {
                        success = this.game.makeMove(by*3+bx, sy*3+sx);
                    }
                } 
                else { // Regular
                    const s = this.canvas.width/3;
                    const c = Math.floor(mx/s), r = Math.floor(my/s);
                    if(c>=0 && c<3 && r>=0 && r<3) success = this.game.makeMove(r*3+c);
                }

                if(success) {
                    this.draw();
                    this.checkWin();
                }
            },

            draw() {
                const c = this.canvas;
                if(this.gameType === 'regular') TTTRenderer.drawRegular(c, this.game);
                else if(this.gameType === 'ultimate') TTTRenderer.drawUltimate(c, this.game);
                else {
                    TTTRenderer.draw3DSlices(c, this.game, this.axis3D);
                    TTTRenderer.drawIsoView(this.isoCanvas, this.game);
                }
            },

            // --- KI ---
            async stepAI(fast = false) {
                if(this.game.winner !== 0) return;
                const p = this.game.currentPlayer;
                const viz = (p===1) ? this.vizP1 : this.vizP2;
                const tree = this.trees[p];

                viz.clearHighlights();
                this.updateStatus(`KI ${p===1?'Blau':'Rot'} rechnet...`);

                // Visualisierung mit Delay, auch im Auto-Mode (wenn Auto nicht zu schnell sein soll)
                // Hier nutzen wir 'evaluateVisual' direkt, um den Pfad zu zeigen
                
                const move = await this.evaluateVisual(tree.root, this.game, viz, fast ? 0 : this.delay);

                if (move) {
                    if (this.gameType === 'ultimate' && typeof move === 'object') 
                        this.game.makeMove(move.big, move.small);
                    else 
                        this.game.makeMove(move);
                    
                    this.draw();
                    this.checkWin();
                } else {
                    this.log(`KI ${p} findet keinen Zug!`);
                }
            },

            async evaluateVisual(node, gameState, viz, ms) {
                if (!node || !node.active) return null;
                
                if (ms > 0) {
                    viz.highlightCheck(node.name);
                    await new Promise(r => setTimeout(r, ms));
                }

                // Condition
                if (node.conditionFn) {
                    const res = node.conditionFn(gameState);
                    if (res) return await this.evaluateVisual(node.thenNode, gameState, viz, ms);
                    else return await this.evaluateVisual(node.elseNode, gameState, viz, ms);
                }
                
                // Group
                if (node.children && node.children.length > 0) {
                    for (const child of node.children) {
                        const result = await this.evaluateVisual(child, gameState, viz, ms);
                        if (result) return result;
                    }
                    return null;
                }

                // Rule
                const result = node.evaluate(gameState);
                if (result) {
                    if (ms > 0) viz.highlightSuccess(node.name);
                    return result.move;
                }
                return null;
            },

            toggleAutoMatch() {
                this.isAuto = !this.isAuto;
                const btn = document.getElementById('btnAuto');
                if (this.isAuto) {
                    btn.innerHTML = "‚èπ Stopp";
                    btn.style.background = "#c0392b";
                    this.loop();
                } else {
                    btn.innerHTML = "‚è© Auto";
                    btn.style.background = "#8e44ad";
                }
            },

            loop() {
                if(!this.isAuto || this.game.winner !== 0) {
                    this.isAuto = false;
                    document.getElementById('btnAuto').innerText = "‚è© Auto";
                    document.getElementById('btnAuto').style.background = "#8e44ad";
                    return;
                }
                // Wir rufen stepAI mit fast=false auf, damit man das Highlighting sieht!
                // Aber wir warten, bis der Step fertig ist (Async)
                this.stepAI(false).then(() => {
                    if(this.isAuto) setTimeout(() => this.loop(), 200);
                });
            },

            checkWin() {
                if(this.game.winner) {
                    const w = this.game.winner;
                    const msg = w===3 ? "Remis" : `Sieg ${w===1?'Blau':'Rot'}`;
                    this.updateStatus(msg);
                    this.log(msg);
                } else {
                    const p = this.game.currentPlayer;
                    this.updateStatus(`${p===1?'Blau':'Rot'} ist dran`);
                }
            },
            updateStatus(msg) { document.getElementById('statusText').innerText = msg || "Bereit"; },
            log(msg) { 
                const l = document.getElementById('log'); 
                l.innerHTML += `<div class="log-entry">${msg}</div>`; 
                l.scrollTop = l.scrollHeight;
            }
        };
        window.onload = () => Lab.init();
    </script>
</body>
</html>